###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         26/Nov/2024  12:15:53
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                 =  thumb
#    Endian                   =  little
#    Source file              =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\SiliconLabs\platform\service\iostream\src\sl_iostream_uart.c
#    Command line             =
#        -f
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_14552146716814908185.dir\sl_iostream_uart.o.rsp
#        (C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\SiliconLabs\platform\service\iostream\src\sl_iostream_uart.c
#        -D EFR32FG23A020F512GM40=1 -D SL_COMPONENT_CATALOG_PRESENT=1 -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -lC
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\src_14552146716814908185.dir
#        --diag_suppress Pa050 -o
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_14552146716814908185.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse -e --fpu=VFPv5_sp --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\.\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\AppConfigs\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\autogen\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\HAL\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\NVM\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\buffer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\event_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\list_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\queue_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\timer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\hif\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\raw_uart_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\debug_console\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\Device\SiliconLabs\EFR32FG23\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\device_init\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\mpu\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\toolchain\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\system\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\network-manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\RAIL_TRX\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MAC\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\wisun_modified\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\FANApp\AppInc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_callbacks\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ip\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\multicast\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\rpl\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\OS_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\L2_L3_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\cpu\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\contiki_mac_interface_layer\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\mac_sicslowpan_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emlib\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\platform\p3_lp_dk\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\common\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\efr32xg1x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_protocol\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_rssi\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MeterApp\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\FLASH\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\APP_LOG\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\NVM\nvm3\inc\
#        -On --use_c++_inline) --dependencies=n
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_14552146716814908185.dir\sl_iostream_uart.o.iar_deps
#    Locale                   =  C
#    List file                =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\src_14552146716814908185.dir\sl_iostream_uart.lst
#    Object file              =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_14552146716814908185.dir\sl_iostream_uart.o
#    Runtime model:              
#      __CPP_Runtime          =  1
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\SiliconLabs\platform\service\iostream\src\sl_iostream_uart.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief IO Stream UART Component.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2019 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          // Define module name for Power Manager debug feature
     31          #define CURRENT_MODULE_NAME    "IOSTREAM_UART"
     32          
     33          #if defined(SL_COMPONENT_CATALOG_PRESENT)
     34          #include "sl_component_catalog.h"
     35          #endif
     36          
     37          #include "sl_status.h"
     38          #include "sl_iostream.h"
     39          #include "sl_iostream_uart.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __vfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40A             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R3,??DataTable7
   \       0x14   0x0001             MOVS     R1,R0
   \       0x16   0xB249             SXTB     R1,R1
   \       0x18   0x0949             LSRS     R1,R1,#+5
   \       0x1A   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40E             BMI.N    ??__NVIC_DisableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R3,??DataTable7_1
   \       0x14   0x0001             MOVS     R1,R0
   \       0x16   0xB249             SXTB     R1,R1
   \       0x18   0x0949             LSRS     R1,R1,#+5
   \       0x1A   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \       0x1E   0xF3BF 0x8F4F      DSB      SY
   \       0x22   0xF3BF 0x8F6F      ISB      SY
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \       0x26   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD40A             BMI.N    ??__NVIC_ClearPendingIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R3,??DataTable7_2
   \       0x14   0x0001             MOVS     R1,R0
   \       0x16   0xB249             SXTB     R1,R1
   \       0x18   0x0949             LSRS     R1,R1,#+5
   \       0x1A   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x1E   0x4770             BX       LR
     40          #include "sli_iostream_uart.h"
     41          #include "sl_atomic.h"
     42          #include "sl_string.h"
     43          
     44          #if (defined(SL_CATALOG_KERNEL_PRESENT))
     45          #include "cmsis_os2.h"
     46          #include "sl_cmsis_os2_common.h"
     47          #endif
     48          
     49          #if (defined(SL_CATALOG_POWER_MANAGER_PRESENT))
     50          #include "sl_power_manager.h"
     51          #endif
     52          
     53          #include <string.h>
     54          #include <stdbool.h>
     55          #include <stddef.h>
     56          #include <stdint.h>
     57          
     58          #include "em_device.h"
     59          #include "em_core.h"
     60          #include "em_gpio.h"
     61          
     62          #if !defined(DMA_PRESENT) && !defined(LDMA_PRESENT)
     63          #error Missing (L)DMA peripheral
     64          #endif
     65          
     66          /*******************************************************************************
     67           *********************   LOCAL FUNCTION PROTOTYPES   ***************************
     68           ******************************************************************************/
     69          static sl_status_t uart_deinit(void *stream);
     70          
     71          static sl_status_t uart_write(void *context,
     72                                        const void *buffer,
     73                                        size_t buffer_length);
     74          
     75          static sl_status_t uart_read(void *context,
     76                                       void *buffer,
     77                                       size_t buffer_length,
     78                                       size_t *bytes_read);
     79          
     80          static void set_auto_cr_lf(void *context,
     81                                     bool on);
     82          
     83          static bool get_auto_cr_lf(void *context);
     84          
     85          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
     86          #if !defined(SL_CATALOG_KERNEL_PRESENT)
     87          static sl_power_manager_on_isr_exit_t sleep_on_isr_exit(void *context);
     88          #endif
     89          
     90          static void set_rx_energy_mode_restriction(void *context,
     91                                                     bool on);
     92          
     93          static bool get_rx_energy_mode_restriction(void *context);
     94          #endif
     95          
     96          #if defined(SL_CATALOG_KERNEL_PRESENT)
     97          static void set_read_block(void *context,
     98                                     bool on);
     99          
    100          static bool get_read_block(void *context);
    101          #endif
    102          
    103          static void scan_for_ctrl_char(sl_iostream_uart_context_t * uart_context);
    104          
    105          static sl_status_t nolock_uart_write(void *context,
    106                                               const void *buffer,
    107                                               size_t buffer_length);
    108          
    109          static bool dma_irq_handler(unsigned int chan,
    110                                      unsigned int seq,
    111                                      void* user_param);
    112          
    113          __STATIC_INLINE uint8_t* get_write_ptr(const sl_iostream_uart_context_t* uart_context);
    114          
    115          static void update_ring_buffer(sl_iostream_uart_context_t *uart_context);
    116          
    117          static size_t read_rx_buffer(sl_iostream_uart_context_t * uart_context,
    118                                       uint8_t * buffer,
    119                                       size_t buffer_len);
    120          
    121          /*******************************************************************************
    122           **************************   GLOBAL FUNCTIONS   *******************************
    123           ******************************************************************************/
    124          
    125          /***************************************************************************//**
    126           * UART Stream init
    127           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    128          sl_status_t sli_iostream_uart_context_init(sl_iostream_uart_t *uart,
    129                                                     sl_iostream_uart_context_t *context,
    130                                                     sl_iostream_uart_config_t *config,
    131                                                     sl_status_t (*tx)(void *context, char c),
    132                                                     void (*tx_completed)(void *context, bool enable),
    133                                                     void (*set_next_byte_detect)(void *context),
    134                                                     sl_status_t (*deinit)(void *context),
    135                                                     uint8_t rx_em_req,
    136                                                     uint8_t tx_em_req)
    137          {
   \                     sli_iostream_uart_context_init: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0x0015             MOVS     R5,R2
   \        0xC   0xF8DD 0xA044      LDR      R10,[SP, #+68]
   \       0x10   0x9E12             LDR      R6,[SP, #+72]
    138            (void)rx_em_req;
    139            (void)tx_em_req;
    140            Ecode_t ecode;
    141          
    142            // Configure iostream struct and context
    143            memset(context, 0, sizeof(*context));
   \       0x12   0x2738             MOVS     R7,#+56
   \       0x14   0xF05F 0x0800      MOVS     R8,#+0
   \       0x18   0x46A3             MOV      R11,R4
   \       0x1A   0x4642             MOV      R2,R8
   \       0x1C   0x0039             MOVS     R1,R7
   \       0x1E   0x4658             MOV      R0,R11
   \       0x20   0x.... 0x....      BL       __aeabi_memset
    144            context->dma.cfg = config->dma_cfg;
   \       0x24   0xE9D5 0x0100      LDRD     R0,R1,[R5, #+0]
   \       0x28   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
    145            context->rx_data_available = false;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x7620             STRB     R0,[R4, #+24]
    146            context->rx_buffer = config->rx_buffer;
   \       0x30   0x68E8             LDR      R0,[R5, #+12]
   \       0x32   0x60E0             STR      R0,[R4, #+12]
    147            context->rx_buffer_len = config->rx_buffer_length;
   \       0x34   0x6928             LDR      R0,[R5, #+16]
   \       0x36   0x6120             STR      R0,[R4, #+16]
    148            context->rx_read_ptr = context->rx_buffer;
   \       0x38   0x68E0             LDR      R0,[R4, #+12]
   \       0x3A   0x6160             STR      R0,[R4, #+20]
    149            context->lf_to_crlf = config->lf_to_crlf;
   \       0x3C   0x7D28             LDRB     R0,[R5, #+20]
   \       0x3E   0xF884 0x002C      STRB     R0,[R4, #+44]
    150            context->sw_flow_control = config->sw_flow_control;
   \       0x42   0x7DA8             LDRB     R0,[R5, #+22]
   \       0x44   0xF884 0x002D      STRB     R0,[R4, #+45]
    151            context->ctrl_char_scan_ptr = context->rx_read_ptr;
   \       0x48   0x6960             LDR      R0,[R4, #+20]
   \       0x4A   0x6320             STR      R0,[R4, #+48]
    152            context->xon = true;
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xF884 0x0034      STRB     R0,[R4, #+52]
    153            context->remote_xon = true;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xF884 0x0035      STRB     R0,[R4, #+53]
    154            context->tx = tx;
   \       0x58   0x9806             LDR      R0,[SP, #+24]
   \       0x5A   0x61E0             STR      R0,[R4, #+28]
    155            context->tx_completed = tx_completed;
   \       0x5C   0x9810             LDR      R0,[SP, #+64]
   \       0x5E   0x6220             STR      R0,[R4, #+32]
    156            context->set_next_byte_detect = set_next_byte_detect;
   \       0x60   0xF8C4 0xA024      STR      R10,[R4, #+36]
    157            context->deinit = deinit;
   \       0x64   0x62A6             STR      R6,[R4, #+40]
    158            context->rx_irq_number = config->rx_irq_number;
   \       0x66   0x7A28             LDRB     R0,[R5, #+8]
   \       0x68   0xF884 0x0036      STRB     R0,[R4, #+54]
    159            #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    160            context->tx_irq_number = config->tx_irq_number;
    161            #endif
    162            uart->stream.context = context;
   \       0x6C   0xF8C9 0x4000      STR      R4,[R9, #+0]
    163          
    164            uart->stream.write = uart_write;
   \       0x70   0x.... 0x....      ADR.W    R0,uart_write
   \       0x74   0xF8C9 0x0004      STR      R0,[R9, #+4]
    165            uart->stream.read = uart_read;
   \       0x78   0x.... 0x....      ADR.W    R0,uart_read
   \       0x7C   0xF8C9 0x0008      STR      R0,[R9, #+8]
    166            uart->set_auto_cr_lf = set_auto_cr_lf;
   \       0x80   0x.... 0x....      ADR.W    R0,set_auto_cr_lf
   \       0x84   0xF8C9 0x0010      STR      R0,[R9, #+16]
    167            uart->get_auto_cr_lf = get_auto_cr_lf;
   \       0x88   0x.... 0x....      ADR.W    R0,get_auto_cr_lf
   \       0x8C   0xF8C9 0x0014      STR      R0,[R9, #+20]
    168            uart->deinit = uart_deinit;
   \       0x90   0x.... 0x....      ADR.W    R0,uart_deinit
   \       0x94   0xF8C9 0x000C      STR      R0,[R9, #+12]
    169          
    170            // Init the LDMA
    171            ecode = DMADRV_Init();
   \       0x98   0x.... 0x....      BL       DMADRV_Init
   \       0x9C   0x4683             MOV      R11,R0
    172            if (ecode != ECODE_OK && ecode != ECODE_EMDRV_DMADRV_ALREADY_INITIALIZED) {
   \       0x9E   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xA2   0xD005             BEQ.N    ??sli_iostream_uart_context_init_0
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0xA8   0x4583             CMP      R11,R0
   \       0xAA   0xD001             BEQ.N    ??sli_iostream_uart_context_init_0
    173              return SL_STATUS_INITIALIZATION;
   \       0xAC   0x2010             MOVS     R0,#+16
   \       0xAE   0xE02B             B.N      ??sli_iostream_uart_context_init_1
    174            }
    175            // Allocate the LDMA channel
    176            ecode = DMADRV_AllocateChannel((unsigned int *)&context->dma.channel,
    177                                           NULL);
   \                     ??sli_iostream_uart_context_init_0: (+1)
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0xB6   0x.... 0x....      BL       DMADRV_AllocateChannel
   \       0xBA   0x0007             MOVS     R7,R0
    178            if (ecode != ECODE_OK) {
   \       0xBC   0x2F00             CMP      R7,#+0
   \       0xBE   0xD001             BEQ.N    ??sli_iostream_uart_context_init_2
    179              return SL_STATUS_INITIALIZATION;
   \       0xC0   0x2010             MOVS     R0,#+16
   \       0xC2   0xE021             B.N      ??sli_iostream_uart_context_init_1
    180            }
    181          
    182          #if defined(SL_CATALOG_KERNEL_PRESENT)
    183            uart->set_read_block = set_read_block;
    184            uart->get_read_block = get_read_block;
    185            context->block = true;
    186          
    187            osMutexAttr_t m_attr;
    188            m_attr.name = "Read Lock";
    189            m_attr.attr_bits = 0u;
    190            m_attr.cb_mem = context->read_lock_cb;
    191            m_attr.cb_size = osMutexCbSize;
    192            context->read_lock = osMutexNew(&m_attr);
    193            EFM_ASSERT(context->read_lock != NULL);
    194          
    195            m_attr.name = "Write Lock";
    196            m_attr.attr_bits = 0u;
    197            m_attr.cb_mem = context->write_lock_cb;
    198            context->write_lock = osMutexNew(&m_attr);
    199            EFM_ASSERT(context->write_lock != NULL);
    200          
    201            osSemaphoreAttr_t s_attr;
    202            s_attr.name = "Read Signal";
    203            s_attr.attr_bits = 0u;
    204            s_attr.cb_mem = context->read_signal_cb;
    205            s_attr.cb_size = osSemaphoreCbSize;
    206            context->read_signal = osSemaphoreNew(1, 0u, &s_attr);
    207            EFM_ASSERT(context->read_signal != NULL);
    208          
    209          #endif
    210          
    211          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    212            #if !defined(SL_CATALOG_KERNEL_PRESENT)
    213            uart->sleep_on_isr_exit = sleep_on_isr_exit;
    214            context->sleep = SL_POWER_MANAGER_IGNORE;
    215            #endif // SL_CATALOG_KERNEL_PRESENT
    216          
    217            uart->set_rx_energy_mode_restriction = set_rx_energy_mode_restriction;
    218            uart->get_rx_energy_mode_restriction = get_rx_energy_mode_restriction;
    219            context->tx_em = (sl_power_manager_em_t)tx_em_req;
    220            context->rx_em = (sl_power_manager_em_t)rx_em_req;
    221            context->em_req_added = false;
    222            context->tx_idle = true;
    223            set_rx_energy_mode_restriction(context, config->rx_when_sleeping);
    224            NVIC_ClearPendingIRQ(config->tx_irq_number);
    225            NVIC_EnableIRQ(config->tx_irq_number);
    226          #endif // SL_CATALOG_POWER_MANAGER_PRESENT
    227          
    228            // Start the (L)DMA to handle RXDATAV
    229            ecode = DMADRV_PeripheralMemory(context->dma.channel,
    230                                            context->dma.cfg.peripheral_signal,
    231                                            context->rx_buffer,
    232                                            context->dma.cfg.src,
    233                                            true,
    234                                            context->rx_buffer_len,
    235                                            dmadrvDataSize1,
    236                                            dma_irq_handler,
    237                                            context);
   \                     ??sli_iostream_uart_context_init_2: (+1)
   \       0xC4   0x9404             STR      R4,[SP, #+16]
   \       0xC6   0x.... 0x....      ADR.W    R0,dma_irq_handler
   \       0xCA   0x9003             STR      R0,[SP, #+12]
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0x9002             STR      R0,[SP, #+8]
   \       0xD0   0x6920             LDR      R0,[R4, #+16]
   \       0xD2   0x9001             STR      R0,[SP, #+4]
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0x9000             STR      R0,[SP, #+0]
   \       0xD8   0x6863             LDR      R3,[R4, #+4]
   \       0xDA   0x68E2             LDR      R2,[R4, #+12]
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x7A20             LDRB     R0,[R4, #+8]
   \       0xE0   0x.... 0x....      BL       DMADRV_PeripheralMemory
   \       0xE4   0x4680             MOV      R8,R0
    238          
    239            if (ecode != ECODE_OK) {
   \       0xE6   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xEA   0xD001             BEQ.N    ??sli_iostream_uart_context_init_3
    240              return SL_STATUS_INITIALIZATION;
   \       0xEC   0x2010             MOVS     R0,#+16
   \       0xEE   0xE00B             B.N      ??sli_iostream_uart_context_init_1
    241            }
    242          
    243            NVIC_ClearPendingIRQ(config->rx_irq_number);
   \                     ??sli_iostream_uart_context_init_3: (+1)
   \       0xF0   0xF995 0x0008      LDRSB    R0,[R5, #+8]
   \       0xF4   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    244            NVIC_EnableIRQ(config->rx_irq_number);
   \       0xF8   0xF995 0x0008      LDRSB    R0,[R5, #+8]
   \       0xFC   0x.... 0x....      BL       __NVIC_EnableIRQ
    245          
    246            sl_iostream_set_system_default(&uart->stream);
   \      0x100   0x4648             MOV      R0,R9
   \      0x102   0x.... 0x....      BL       sl_iostream_set_default
    247          
    248            return SL_STATUS_OK;
   \      0x106   0x2000             MOVS     R0,#+0
   \                     ??sli_iostream_uart_context_init_1: (+1)
   \      0x108   0xB007             ADD      SP,SP,#+28
   \      0x10A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    249          }
    250          
    251          /**************************************************************************//**
    252           * @brief On ISR exit
    253           *****************************************************************************/
    254          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT) && !defined(SL_CATALOG_KERNEL_PRESENT)
    255          static sl_power_manager_on_isr_exit_t sleep_on_isr_exit(void *context)
    256          {
    257            if (context == NULL) {
    258              return SL_POWER_MANAGER_IGNORE;
    259            }
    260          
    261            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    262          
    263            if ((uart_context->tx_idle) && (uart_context->sleep == SL_POWER_MANAGER_SLEEP)) {
    264              sl_power_manager_on_isr_exit_t sleep = uart_context->sleep;
    265              uart_context->sleep = SL_POWER_MANAGER_IGNORE;
    266              return sleep;
    267            } else if ((uart_context->sleep == SL_POWER_MANAGER_WAKEUP)) {
    268              sl_power_manager_on_isr_exit_t sleep = uart_context->sleep;
    269              uart_context->sleep = SL_POWER_MANAGER_IGNORE;
    270              return sleep;
    271            } else {
    272              return SL_POWER_MANAGER_IGNORE;
    273            }
    274          }
    275          #endif
    276          
    277          /**************************************************************************//**
    278           * Set LF to CRLF conversion
    279           *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    280          static void set_auto_cr_lf(void *context,
    281                                     bool on)
    282          {
    283            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
   \                     set_auto_cr_lf: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    284          
    285            sl_atomic_store(uart_context->lf_to_crlf, on);
   \        0x2   0xF882 0x102C      STRB     R1,[R2, #+44]
    286          }
   \        0x6   0x4770             BX       LR
    287          
    288          /**************************************************************************//**
    289           * Get LF to CRLF conversion
    290           *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    291          static bool get_auto_cr_lf(void *context)
    292          {
   \                     get_auto_cr_lf: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    293            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
   \        0x2   0x0011             MOVS     R1,R2
    294            bool conversion;
    295          
    296            sl_atomic_load(conversion, uart_context->lf_to_crlf);
   \        0x4   0xF891 0x002C      LDRB     R0,[R1, #+44]
    297          
    298            return conversion;
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x4770             BX       LR
    299          }
    300          
    301          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    302          /**************************************************************************//**
    303           * Set Rx when sleeping
    304           *****************************************************************************/
    305          static void set_rx_energy_mode_restriction(void *context,
    306                                                     bool on)
    307          {
    308            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    309            bool em_req_added;
    310          
    311            sl_atomic_load(em_req_added, uart_context->em_req_added);
    312            if ((on == true)
    313                && (em_req_added == false)) {
    314              sl_power_manager_add_em_requirement(uart_context->rx_em);
    315              sl_atomic_store(uart_context->em_req_added, true);
    316            } else if ((on == false)
    317                       && (em_req_added == true)) {
    318              sl_power_manager_remove_em_requirement(uart_context->rx_em);
    319              sl_atomic_store(uart_context->em_req_added, false);
    320            }
    321          }
    322          #endif
    323          
    324          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    325          /**************************************************************************//**
    326           * Get Rx when sleeping
    327           *****************************************************************************/
    328          static bool get_rx_energy_mode_restriction(void *context)
    329          {
    330            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    331            bool em_req_added;
    332          
    333            sl_atomic_load(em_req_added, uart_context->em_req_added);
    334            return em_req_added;
    335          }
    336          #endif
    337          
    338          #if (defined(SL_CATALOG_KERNEL_PRESENT))
    339          /**************************************************************************//**
    340           * Set read blocking mode
    341           *****************************************************************************/
    342          static void set_read_block(void *context,
    343                                     bool on)
    344          {
    345            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    346            bool block;
    347            osKernelState_t state;
    348            osStatus_t status;
    349          
    350            sl_atomic_load(block, uart_context->block);
    351            state = osKernelGetState();
    352            if (state == osKernelRunning) {
    353              // When re-enabling block mode, re-initialize the semaphore to reflect the current state
    354              if (on == true && block == false) {
    355                // Read-signal should have been deinit when non-blocking
    356                EFM_ASSERT(uart_context->read_signal == NULL);
    357          
    358                // Init the read_signal boolean semaphore
    359                osSemaphoreAttr_t s_attr;
    360                s_attr.name = "Read Signal";
    361                s_attr.attr_bits = 0u;
    362                s_attr.cb_mem = uart_context->read_signal_cb;
    363                s_attr.cb_size = osSemaphoreCbSize;
    364                uart_context->read_signal = osSemaphoreNew(1, 0u, &s_attr);
    365                EFM_ASSERT(uart_context->read_signal != NULL);
    366          
    367                // Set the semaphore to reflect the current state
    368                if (uart_context->rx_data_available == true) {
    369                  status = osSemaphoreRelease(uart_context->read_signal);
    370                  EFM_ASSERT(status == osOK);
    371                }
    372              }
    373              // When disabling block mode, deinit the read_signal semaphore
    374              else if (on == false && block == true) {
    375                status = osSemaphoreDelete(uart_context->read_signal);
    376                EFM_ASSERT(status == osOK);
    377                uart_context->read_signal = NULL;
    378              }
    379            }
    380            // Set the block context variable
    381            sl_atomic_store(uart_context->block, on);
    382          }
    383          #endif
    384          
    385          #if (defined(SL_CATALOG_KERNEL_PRESENT))
    386          /**************************************************************************//**
    387           * Get read blocking mode
    388           *****************************************************************************/
    389          static bool get_read_block(void *context)
    390          {
    391            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    392            bool block;
    393          
    394            sl_atomic_load(block, uart_context->block);
    395            return block;
    396          }
    397          #endif
    398          
    399          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT) && !defined(SL_IOSTREAM_UART_FLUSH_TX_BUFFER)
    400          /**************************************************************************//**
    401           * Signal transmit complete
    402           *****************************************************************************/
    403          void sli_uart_txc(void *context)
    404          {
    405            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    406          
    407            if (uart_context->tx_idle == false) {
    408              EFM_ASSERT(uart_context->tx_completed != NULL);
    409              uart_context->tx_completed(context, false);
    410              uart_context->tx_idle = true;
    411              sl_power_manager_remove_em_requirement(uart_context->tx_em);
    412          #if !defined(SL_CATALOG_KERNEL_PRESENT)
    413              uart_context->sleep = SL_POWER_MANAGER_SLEEP;
    414          #endif
    415            }
    416          }
    417          #endif
    418          
    419          /*******************************************************************************
    420           **************************   LOCAL FUNCTIONS   ********************************
    421           ******************************************************************************/
    422          
    423          /***************************************************************************//**
    424           * UART Stream De-init
    425           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    426          static sl_status_t uart_deinit(void *stream)
    427          {
   \                     uart_deinit: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
    428            sl_iostream_uart_t *uart = (sl_iostream_uart_t *)stream;
   \        0x6   0x4656             MOV      R6,R10
    429            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)uart->stream.context;
   \        0x8   0x6837             LDR      R7,[R6, #+0]
    430            sl_iostream_t *default_stream;
    431            sl_status_t status = SL_STATUS_OK;
   \        0xA   0xF05F 0x0800      MOVS     R8,#+0
    432            Ecode_t ecode = ECODE_OK;
   \        0xE   0x2500             MOVS     R5,#+0
    433          #if (defined(SL_CATALOG_KERNEL_PRESENT))
    434            if (osKernelGetState() == osKernelRunning) {
    435              // Acquire locks to ensure no others task try to perform operation on the stream at sametime
    436              EFM_ASSERT(osMutexAcquire(uart_context->write_lock, osWaitForever) == osOK);  // If deinit is called twice in a
    437                                                                                            // row, the assert will trigger
    438              // Bypass lock if we print before the kernel is running
    439              EFM_ASSERT(osMutexAcquire(uart_context->read_lock, osWaitForever) == osOK);   // If deinit is called twice in a
    440                                                                                            //row, the assert will trigger
    441            }
    442          #endif
    443          
    444            default_stream = sl_iostream_get_default();
   \       0x10   0x.... 0x....      BL       sl_iostream_get_default
   \       0x14   0x4681             MOV      R9,R0
    445          
    446            // Check if uart stream is the default and if it's the case,
    447            // remove it's reference as the default
    448            if ((sl_iostream_uart_t*)default_stream == uart) {
   \       0x16   0x45B1             CMP      R9,R6
   \       0x18   0xD102             BNE.N    ??uart_deinit_0
    449              sl_iostream_set_system_default(NULL);
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x.... 0x....      BL       sl_iostream_set_default
    450            }
    451          
    452            NVIC_ClearPendingIRQ(uart_context->rx_irq_number);
   \                     ??uart_deinit_0: (+1)
   \       0x20   0xF997 0x0036      LDRSB    R0,[R7, #+54]
   \       0x24   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    453            NVIC_DisableIRQ(uart_context->rx_irq_number);
   \       0x28   0xF997 0x0036      LDRSB    R0,[R7, #+54]
   \       0x2C   0x.... 0x....      BL       __NVIC_DisableIRQ
    454          
    455          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    456            NVIC_ClearPendingIRQ(uart_context->tx_irq_number);
    457            NVIC_DisableIRQ(uart_context->tx_irq_number);
    458          #endif
    459          
    460          #if defined(SL_CATALOG_KERNEL_PRESENT)
    461            // Delete Kernel synchronization objects.
    462            status = osSemaphoreDelete(uart_context->read_signal);
    463            EFM_ASSERT(status == osOK);
    464          
    465            status = osMutexDelete(uart_context->read_lock);
    466            EFM_ASSERT(status == osOK);
    467          
    468            status = osMutexDelete(uart_context->write_lock);
    469            EFM_ASSERT(status == osOK);
    470          #endif
    471          
    472            // Stop the DMA
    473            ecode = DMADRV_StopTransfer(uart_context->dma.channel);
   \       0x30   0x7A38             LDRB     R0,[R7, #+8]
   \       0x32   0x.... 0x....      BL       DMADRV_StopTransfer
   \       0x36   0x0004             MOVS     R4,R0
    474            EFM_ASSERT(ecode == ECODE_OK);
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD101             BNE.N    ??uart_deinit_1
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE000             B.N      ??uart_deinit_2
   \                     ??uart_deinit_1: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??uart_deinit_2: (+1)
   \       0x42   0xB2C0             UXTB     R0,R0
    475          
    476            // Free the DMA channel
    477            ecode = DMADRV_FreeChannel(uart_context->dma.channel);
   \       0x44   0x7A38             LDRB     R0,[R7, #+8]
   \       0x46   0x.... 0x....      BL       DMADRV_FreeChannel
   \       0x4A   0x0005             MOVS     R5,R0
    478            EFM_ASSERT(ecode == ECODE_OK);
   \       0x4C   0x2D00             CMP      R5,#+0
   \       0x4E   0xD101             BNE.N    ??uart_deinit_3
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??uart_deinit_4
   \                     ??uart_deinit_3: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??uart_deinit_4: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
    479          
    480            // Try to deinit the DMADRV
    481            ecode = DMADRV_DeInit();
   \       0x58   0x.... 0x....      BL       DMADRV_DeInit
   \       0x5C   0x0004             MOVS     R4,R0
    482            EFM_ASSERT(ecode == ECODE_OK || ecode == ECODE_EMDRV_DMADRV_IN_USE);
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD002             BEQ.N    ??uart_deinit_5
   \       0x62   0x....             LDR.N    R0,??DataTable7_4
   \       0x64   0x4284             CMP      R4,R0
   \       0x66   0xD101             BNE.N    ??uart_deinit_6
   \                     ??uart_deinit_5: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xE000             B.N      ??uart_deinit_7
   \                     ??uart_deinit_6: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??uart_deinit_7: (+1)
   \       0x6E   0xB2C0             UXTB     R0,R0
    483          
    484            // Clear iostream struct and context
    485            uart->stream.context = NULL;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6030             STR      R0,[R6, #+0]
    486            uart->stream.write = NULL;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x6070             STR      R0,[R6, #+4]
    487            uart->stream.read = NULL;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x60B0             STR      R0,[R6, #+8]
    488            uart->set_auto_cr_lf = NULL;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x6130             STR      R0,[R6, #+16]
    489            uart->get_auto_cr_lf = NULL;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6170             STR      R0,[R6, #+20]
    490          
    491            status = uart_context->deinit(uart_context);
   \       0x84   0x0038             MOVS     R0,R7
   \       0x86   0x6AB9             LDR      R1,[R7, #+40]
   \       0x88   0x4788             BLX      R1
    492          
    493            return status;
   \       0x8A   0xE8BD 0x87F0      POP      {R4-R10,PC}
    494          }
    495          
    496          /***************************************************************************//**
    497           * Scan the RX Buffer from the last received byte to the last scanned position.
    498           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    499          static void scan_for_ctrl_char(sl_iostream_uart_context_t * uart_context)
    500          {
   \                     scan_for_ctrl_char: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    501            uint8_t *newest_byte, *current_byte;
    502          
    503            // No data to be scanned
    504            if (uart_context->rx_data_available == false) {
   \        0x4   0x7E20             LDRB     R0,[R4, #+24]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD108             BNE.N    ??scan_for_ctrl_char_0
    505              EFM_ASSERT(uart_context->ctrl_char_scan_ptr == uart_context->rx_read_ptr);
   \        0xA   0x6B21             LDR      R1,[R4, #+48]
   \        0xC   0x6960             LDR      R0,[R4, #+20]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD101             BNE.N    ??scan_for_ctrl_char_1
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xE000             B.N      ??scan_for_ctrl_char_2
   \                     ??scan_for_ctrl_char_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \                     ??scan_for_ctrl_char_2: (+1)
   \       0x18   0xB2C0             UXTB     R0,R0
    506              return;
   \       0x1A   0xE029             B.N      ??scan_for_ctrl_char_3
    507            }
    508          
    509            #if defined(DMA_PRESENT)
    510            Ecode_t ecode = DMADRV_PauseTransfer(uart_context->dma.channel);
    511            EFM_ASSERT(ecode == ECODE_OK);
    512            #endif // DMA_PRESENT
    513          
    514            // Get the newest byte received
    515            newest_byte = get_write_ptr(uart_context) - 1;
   \                     ??scan_for_ctrl_char_0: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       get_write_ptr
   \       0x22   0x1E40             SUBS     R0,R0,#+1
    516          
    517            #if defined(DMA_PRESENT)
    518            ecode = DMADRV_ResumeTransfer(uart_context->dma.channel);
    519            EFM_ASSERT(ecode == ECODE_OK);
    520            #endif // DMA_PRESENT
    521          
    522            // Wrap newest byte ptr around the ring buffer
    523            if (newest_byte < uart_context->rx_buffer) {
   \       0x24   0x68E1             LDR      R1,[R4, #+12]
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD204             BCS.N    ??scan_for_ctrl_char_4
    524              newest_byte = uart_context->rx_buffer + (uart_context->rx_buffer_len - 1);
   \       0x2A   0x68E2             LDR      R2,[R4, #+12]
   \       0x2C   0x6921             LDR      R1,[R4, #+16]
   \       0x2E   0x4411             ADD      R1,R2,R1
   \       0x30   0x1E49             SUBS     R1,R1,#+1
   \       0x32   0x0008             MOVS     R0,R1
    525            }
    526          
    527            // Scan the entire buffer until we reach the position of the last scan,
    528            // or until we find the newest control character
    529            current_byte = newest_byte;
   \                     ??scan_for_ctrl_char_4: (+1)
   \       0x34   0x0001             MOVS     R1,R0
    530            while (current_byte != uart_context->ctrl_char_scan_ptr) {
   \                     ??scan_for_ctrl_char_5: (+1)
   \       0x36   0x6B22             LDR      R2,[R4, #+48]
   \       0x38   0x4291             CMP      R1,R2
   \       0x3A   0xD018             BEQ.N    ??scan_for_ctrl_char_6
    531              // Found XOFF character
    532              if (*current_byte == UARTXON || *current_byte == UARTXOFF) {
   \       0x3C   0x780A             LDRB     R2,[R1, #+0]
   \       0x3E   0x2A11             CMP      R2,#+17
   \       0x40   0xD002             BEQ.N    ??scan_for_ctrl_char_7
   \       0x42   0x780A             LDRB     R2,[R1, #+0]
   \       0x44   0x2A13             CMP      R2,#+19
   \       0x46   0xD108             BNE.N    ??scan_for_ctrl_char_8
    533                sl_atomic_store(uart_context->xon, (*current_byte == UARTXON));
   \                     ??scan_for_ctrl_char_7: (+1)
   \       0x48   0x780A             LDRB     R2,[R1, #+0]
   \       0x4A   0x2A11             CMP      R2,#+17
   \       0x4C   0xD101             BNE.N    ??scan_for_ctrl_char_9
   \       0x4E   0x2201             MOVS     R2,#+1
   \       0x50   0xE000             B.N      ??scan_for_ctrl_char_10
   \                     ??scan_for_ctrl_char_9: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \                     ??scan_for_ctrl_char_10: (+1)
   \       0x54   0xF884 0x2034      STRB     R2,[R4, #+52]
    534                break;
   \       0x58   0xE009             B.N      ??scan_for_ctrl_char_6
    535              }
    536          
    537              // Decrement and wrap current byte ptr around the ring buffer
    538              current_byte--;
   \                     ??scan_for_ctrl_char_8: (+1)
   \       0x5A   0x1E49             SUBS     R1,R1,#+1
    539              if (current_byte < uart_context->rx_buffer) {
   \       0x5C   0x68E2             LDR      R2,[R4, #+12]
   \       0x5E   0x4291             CMP      R1,R2
   \       0x60   0xD2E9             BCS.N    ??scan_for_ctrl_char_5
    540                current_byte = uart_context->rx_buffer + (uart_context->rx_buffer_len - 1);
   \       0x62   0x68E3             LDR      R3,[R4, #+12]
   \       0x64   0x6922             LDR      R2,[R4, #+16]
   \       0x66   0x441A             ADD      R2,R3,R2
   \       0x68   0x1E52             SUBS     R2,R2,#+1
   \       0x6A   0x0011             MOVS     R1,R2
   \       0x6C   0xE7E3             B.N      ??scan_for_ctrl_char_5
    541              }
    542            }
    543          
    544            // Update scan pointer
    545            uart_context->ctrl_char_scan_ptr = newest_byte;
   \                     ??scan_for_ctrl_char_6: (+1)
   \       0x6E   0x6320             STR      R0,[R4, #+48]
    546          }
   \                     ??scan_for_ctrl_char_3: (+1)
   \       0x70   0xBD10             POP      {R4,PC}
    547          
    548          /***************************************************************************//**
    549           * Internal stream write implementation
    550           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    551          static sl_status_t nolock_uart_write(void *context,
    552                                               const void *buffer,
    553                                               size_t buffer_length)
    554          {
   \                     nolock_uart_write: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    555            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
   \        0xA   0x465F             MOV      R7,R11
    556            char *c = (char *)buffer;
   \        0xC   0x46A8             MOV      R8,R5
    557            bool lf_to_crlf = false;
   \        0xE   0x2000             MOVS     R0,#+0
    558            sl_status_t status = SL_STATUS_FAIL;
   \       0x10   0x2401             MOVS     R4,#+1
    559            CORE_DECLARE_IRQ_STATE;
    560          
    561            sl_atomic_load(lf_to_crlf, uart_context->lf_to_crlf);
   \       0x12   0xF897 0x102C      LDRB     R1,[R7, #+44]
   \       0x16   0xF88D 0x1001      STRB     R1,[SP, #+1]
    562          
    563          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT) && !defined(SL_IOSTREAM_UART_FLUSH_TX_BUFFER)
    564            CORE_ENTER_ATOMIC();
    565            if (uart_context->tx_idle == true) {
    566              CORE_EXIT_ATOMIC();
    567              sl_power_manager_add_em_requirement(uart_context->tx_em);
    568              CORE_ENTER_ATOMIC();
    569              uart_context->tx_idle = false;
    570            }
    571            CORE_EXIT_ATOMIC();
    572          #endif
    573          
    574            uint32_t i = 0;
   \       0x1A   0xF05F 0x0900      MOVS     R9,#+0
    575            while (i < buffer_length) {
   \                     ??nolock_uart_write_0: (+1)
   \       0x1E   0x45B1             CMP      R9,R6
   \       0x20   0xD232             BCS.N    ??nolock_uart_write_1
    576              bool xon = false;
   \       0x22   0xF05F 0x0A00      MOVS     R10,#+0
    577              if (uart_context->sw_flow_control == true) {
   \       0x26   0xF897 0x002D      LDRB     R0,[R7, #+45]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD108             BNE.N    ??nolock_uart_write_2
    578                CORE_ENTER_ATOMIC();
   \       0x2E   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x32   0x9001             STR      R0,[SP, #+4]
    579                scan_for_ctrl_char(uart_context);
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x.... 0x....      BL       scan_for_ctrl_char
    580                CORE_EXIT_ATOMIC();
   \       0x3A   0x9801             LDR      R0,[SP, #+4]
   \       0x3C   0x.... 0x....      BL       CORE_ExitAtomic
    581              }
    582              sl_atomic_load(xon, uart_context->xon);
   \                     ??nolock_uart_write_2: (+1)
   \       0x40   0xF897 0x0034      LDRB     R0,[R7, #+52]
   \       0x44   0xF88D 0x0000      STRB     R0,[SP, #+0]
    583              if (xon) {
   \       0x48   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD0E6             BEQ.N    ??nolock_uart_write_0
    584                if (lf_to_crlf == true) {
   \       0x50   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x54   0x2801             CMP      R0,#+1
   \       0x56   0xD108             BNE.N    ??nolock_uart_write_3
    585                  if (*c == '\n') {
   \       0x58   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x5C   0x280A             CMP      R0,#+10
   \       0x5E   0xD104             BNE.N    ??nolock_uart_write_3
    586                    status = uart_context->tx(uart_context, '\r');
   \       0x60   0x210D             MOVS     R1,#+13
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0x69FA             LDR      R2,[R7, #+28]
   \       0x66   0x4790             BLX      R2
   \       0x68   0x0004             MOVS     R4,R0
    587                  }
    588                }
    589                status = uart_context->tx(uart_context, *c);
   \                     ??nolock_uart_write_3: (+1)
   \       0x6A   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \       0x6E   0x0038             MOVS     R0,R7
   \       0x70   0x69FA             LDR      R2,[R7, #+28]
   \       0x72   0x4790             BLX      R2
   \       0x74   0x0004             MOVS     R4,R0
    590                if (status != SL_STATUS_OK) {
   \       0x76   0x2C00             CMP      R4,#+0
   \       0x78   0xD001             BEQ.N    ??nolock_uart_write_4
    591                  return status;
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0xE005             B.N      ??nolock_uart_write_5
    592                }
    593                c++;
   \                     ??nolock_uart_write_4: (+1)
   \       0x7E   0xF118 0x0801      ADDS     R8,R8,#+1
    594                i++;
   \       0x82   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x86   0xE7CA             B.N      ??nolock_uart_write_0
    595              }         // Active wait if xon is false
    596            }
    597          
    598          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT) && !defined(SL_IOSTREAM_UART_FLUSH_TX_BUFFER)
    599            uart_context->tx_completed(context, true);
    600          #endif
    601          
    602            return status;
   \                     ??nolock_uart_write_1: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \                     ??nolock_uart_write_5: (+1)
   \       0x8A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    603          }
    604          
    605          /***************************************************************************//**
    606           * Internal stream write implementation
    607           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    608          static sl_status_t uart_write(void *context,
    609                                        const void *buffer,
    610                                        size_t buffer_length)
    611          {
   \                     uart_write: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
    612          #if (defined(SL_CATALOG_KERNEL_PRESENT))
    613            osStatus_t status;
    614            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
    615            if (osKernelGetState() == osKernelRunning) {
    616              // Bypass lock if we print before the kernel is running
    617              status = osMutexAcquire(uart_context->write_lock, osWaitForever);
    618          
    619              if (status != osOK) {
    620                return SL_STATUS_INVALID_STATE;       // Can happen if a task deinit and another try to write at sametime
    621              }
    622            }
    623          #endif
    624          
    625            nolock_uart_write(context, buffer, buffer_length);
   \        0x8   0x002A             MOVS     R2,R5
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0x.... 0x....      BL       nolock_uart_write
    626          
    627          #if (defined(SL_CATALOG_KERNEL_PRESENT))
    628            if (osKernelGetState() == osKernelRunning) {
    629              // Bypass lock if we print before the kernel is running
    630              status = osMutexRelease(uart_context->write_lock);
    631              EFM_ASSERT(status == osOK);
    632            }
    633          #endif
    634            return SL_STATUS_OK;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD70             POP      {R4-R6,PC}
    635          }
    636          
    637          /***************************************************************************//**
    638           * Internal stream read implementation
    639           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    640          static sl_status_t uart_read(void *context,
    641                                       void *buffer,
    642                                       size_t buffer_length,
    643                                       size_t *bytes_read)
    644          {
   \                     uart_read: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
    645            CORE_DECLARE_IRQ_STATE;
    646            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)context;
   \        0xC   0x464F             MOV      R7,R9
    647          
    648             #if (defined(SL_CATALOG_KERNEL_PRESENT))
    649            osStatus_t status;
    650            if (osKernelGetState() == osKernelRunning) {
    651              // Bypass lock if we print before the kernel is running
    652              status = osMutexAcquire(uart_context->read_lock, osWaitForever);
    653          
    654              if (status != osOK) {
    655                return SL_STATUS_INVALID_STATE;   // Can happen if a task deinit and another try to read at sametime
    656              }
    657          
    658              if (uart_context->block) {
    659                EFM_ASSERT(osSemaphoreAcquire(uart_context->read_signal, osWaitForever) == osOK);
    660              }
    661            }
    662            #endif
    663          
    664            CORE_ENTER_ATOMIC();
   \        0xE   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x12   0x4680             MOV      R8,R0
    665            *bytes_read = read_rx_buffer(uart_context, (uint8_t *) buffer, (size_t)buffer_length);
   \       0x14   0x002A             MOVS     R2,R5
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0x0038             MOVS     R0,R7
   \       0x1A   0x.... 0x....      BL       read_rx_buffer
   \       0x1E   0x6030             STR      R0,[R6, #+0]
    666            CORE_EXIT_ATOMIC();
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x.... 0x....      BL       CORE_ExitAtomic
    667          
    668            #if (defined(SL_CATALOG_KERNEL_PRESENT))
    669            if (osKernelGetState() == osKernelRunning) {
    670              // Bypass lock if we print before the kernel is running
    671              EFM_ASSERT(osMutexRelease(uart_context->read_lock) == osOK);
    672            }
    673            #endif
    674          
    675            if (*bytes_read == 0) {
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD101             BNE.N    ??uart_read_0
    676              return SL_STATUS_EMPTY;
   \       0x2C   0x201B             MOVS     R0,#+27
   \       0x2E   0xE000             B.N      ??uart_read_1
    677            } else {
    678              return SL_STATUS_OK;
   \                     ??uart_read_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??uart_read_1: (+1)
   \       0x32   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    679            }
    680          }
    681          
    682          /***************************************************************************//**
    683           * Updates the (L)DMA to re-use whatever space is in the ring buffer.
    684           * Always returns false (no loop, check DMADRV IRQ callbacks documentation
    685           * for more details).
    686           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    687          static bool dma_irq_handler(unsigned int chan, unsigned int seq, void* user_param)
    688          {
   \                     dma_irq_handler: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000E             MOVS     R6,R1
   \        0xA   0x0017             MOVS     R7,R2
    689            (void) seq;
    690            sl_iostream_uart_context_t *uart_context = (sl_iostream_uart_context_t *)user_param;
   \        0xC   0x46B8             MOV      R8,R7
    691            uint8_t *write_ptr;
    692            Ecode_t ecode;
    693            size_t available_space;
    694          
    695            // Compute next write position
    696            {
    697              // DMA is stopped, no need to pause before calling get_write_ptr()
    698              write_ptr = get_write_ptr(uart_context);
   \        0xE   0x4640             MOV      R0,R8
   \       0x10   0x.... 0x....      BL       get_write_ptr
   \       0x14   0x4681             MOV      R9,R0
    699            }
    700          
    701            // Compute available space
    702            if (uart_context->rx_read_ptr >= write_ptr) {
   \       0x16   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x1A   0x4548             CMP      R0,R9
   \       0x1C   0xD304             BCC.N    ??dma_irq_handler_0
    703              available_space = (size_t)(uart_context->rx_read_ptr - write_ptr);
   \       0x1E   0xF8D8 0x5014      LDR      R5,[R8, #+20]
   \       0x22   0xEBB5 0x0509      SUBS     R5,R5,R9
   \       0x26   0xE007             B.N      ??dma_irq_handler_1
    704            } else {
    705              available_space = (size_t)((uart_context->rx_buffer + uart_context->rx_buffer_len) - write_ptr);
   \                     ??dma_irq_handler_0: (+1)
   \       0x28   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \       0x2C   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x30   0xEB01 0x0500      ADD      R5,R1,R0
   \       0x34   0xEBB5 0x0509      SUBS     R5,R5,R9
    706            }
    707          
    708            // Space available in the RX buffer
    709            if (available_space > 0) {
   \                     ??dma_irq_handler_1: (+1)
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD018             BEQ.N    ??dma_irq_handler_2
    710              // Start the DMA transfer
    711              ecode = DMADRV_PeripheralMemory(chan,
    712                                              uart_context->dma.cfg.peripheral_signal,
    713                                              write_ptr,
    714                                              uart_context->dma.cfg.src,
    715                                              true,
    716                                              available_space,
    717                                              dmadrvDataSize1,
    718                                              dma_irq_handler,
    719                                              uart_context);
   \       0x3C   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \       0x40   0x....             LDR.N    R0,??DataTable7_5
   \       0x42   0x9003             STR      R0,[SP, #+12]
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x9002             STR      R0,[SP, #+8]
   \       0x48   0x9501             STR      R5,[SP, #+4]
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0xF8D8 0x3004      LDR      R3,[R8, #+4]
   \       0x52   0x464A             MOV      R2,R9
   \       0x54   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x58   0x4650             MOV      R0,R10
   \       0x5A   0x.... 0x....      BL       DMADRV_PeripheralMemory
   \       0x5E   0x0004             MOVS     R4,R0
    720              EFM_ASSERT(ecode == ECODE_OK);
   \       0x60   0x2C00             CMP      R4,#+0
   \       0x62   0xD101             BNE.N    ??dma_irq_handler_3
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xE000             B.N      ??dma_irq_handler_4
   \                     ??dma_irq_handler_3: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??dma_irq_handler_4: (+1)
   \       0x6A   0xB2C0             UXTB     R0,R0
   \       0x6C   0xE012             B.N      ??dma_irq_handler_5
    721            }
    722            // RX buffer is full
    723            else {
    724              uart_context->rx_buffer_full = true;
   \                     ??dma_irq_handler_2: (+1)
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xF888 0x0019      STRB     R0,[R8, #+25]
    725          
    726              // Send first XOFF. Subsequent XOFFs will be sent by the stream's IRQ handler.
    727              if (uart_context->sw_flow_control) {
   \       0x74   0xF898 0x002D      LDRB     R0,[R8, #+45]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD00B             BEQ.N    ??dma_irq_handler_5
    728                sl_atomic_store(uart_context->remote_xon, false);
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xF888 0x0035      STRB     R0,[R8, #+53]
    729                uart_context->tx(uart_context, UARTXOFF);
   \       0x82   0x2113             MOVS     R1,#+19
   \       0x84   0x4640             MOV      R0,R8
   \       0x86   0xF8D8 0x201C      LDR      R2,[R8, #+28]
   \       0x8A   0x4790             BLX      R2
    730                // Enable the RXDATAV IRQ to check if we receive a control character when buffer is full
    731                uart_context->set_next_byte_detect(uart_context);
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0xF8D8 0x1024      LDR      R1,[R8, #+36]
   \       0x92   0x4788             BLX      R1
    732              }
    733            }
    734            return false;
   \                     ??dma_irq_handler_5: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0xB006             ADD      SP,SP,#+24
   \       0x98   0xE8BD 0x87F0      POP      {R4-R10,PC}
    735          }
    736          
    737          /***************************************************************************//**
    738           * Get the next byte to be written to by the (L)DMA.
    739           * When using a non-linked DMA, you should pause the DMA before calling to ensure
    740           * the validity of the result.
    741           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    742          __STATIC_INLINE uint8_t* get_write_ptr(const sl_iostream_uart_context_t * uart_context)
    743          {
   \                     get_write_ptr: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    744            uint8_t* dst;
    745          
    746            #if defined(DMA_PRESENT)
    747            int remaining;
    748            Ecode_t ecode;
    749            ecode = DMADRV_TransferRemainingCount(uart_context->dma.channel, &remaining);
    750            EFM_ASSERT(ecode == ECODE_OK);
    751          
    752            DMA_DESCRIPTOR_TypeDef* desc = ((DMA_DESCRIPTOR_TypeDef *)(DMA->CTRLBASE)) + uart_context->dma.channel;
    753            dst = ((uint8_t*)desc->DSTEND + 1) - remaining;
    754          
    755            #elif defined(LDMA_PRESENT)
    756            dst = (uint8_t *)LDMA->CH[uart_context->dma.channel].DST;
   \        0x2   0x....             LDR.N    R3,??DataTable7_6
   \        0x4   0x7A0A             LDRB     R2,[R1, #+8]
   \        0x6   0x2030             MOVS     R0,#+48
   \        0x8   0x4342             MULS     R2,R0,R2
   \        0xA   0xEB03 0x0002      ADD      R0,R3,R2
   \        0xE   0x6940             LDR      R0,[R0, #+20]
    757            #endif
    758          
    759            // Check for buffer over/underflow
    760            EFM_ASSERT(dst <= (uart_context->rx_buffer + uart_context->rx_buffer_len)
    761                       && dst >= uart_context->rx_buffer);
   \       0x10   0x68CB             LDR      R3,[R1, #+12]
   \       0x12   0x690A             LDR      R2,[R1, #+16]
   \       0x14   0x441A             ADD      R2,R3,R2
   \       0x16   0x4282             CMP      R2,R0
   \       0x18   0xD304             BCC.N    ??get_write_ptr_0
   \       0x1A   0x68CA             LDR      R2,[R1, #+12]
   \       0x1C   0x4290             CMP      R0,R2
   \       0x1E   0xD301             BCC.N    ??get_write_ptr_0
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0xE000             B.N      ??get_write_ptr_1
   \                     ??get_write_ptr_0: (+1)
   \       0x24   0x2200             MOVS     R2,#+0
   \                     ??get_write_ptr_1: (+1)
   \       0x26   0xB2D2             UXTB     R2,R2
    762          
    763            // Wrap dst around
    764            if (dst == (uart_context->rx_buffer + uart_context->rx_buffer_len)) {
   \       0x28   0x68CB             LDR      R3,[R1, #+12]
   \       0x2A   0x690A             LDR      R2,[R1, #+16]
   \       0x2C   0x441A             ADD      R2,R3,R2
   \       0x2E   0x4290             CMP      R0,R2
   \       0x30   0xD101             BNE.N    ??get_write_ptr_2
    765              dst = uart_context->rx_buffer;
   \       0x32   0x68CA             LDR      R2,[R1, #+12]
   \       0x34   0x0010             MOVS     R0,R2
    766            }
    767          
    768            return dst;
   \                     ??get_write_ptr_2: (+1)
   \       0x36   0x4770             BX       LR
    769          }
    770          
    771          /***************************************************************************//**
    772           * Update ring buffer pointers and DMA descriptor.
    773           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    774          static void update_ring_buffer(sl_iostream_uart_context_t * uart_context)
    775          {
   \                     update_ring_buffer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0007             MOVS     R7,R0
    776            Ecode_t ecode;
    777            bool dma_done, irq_pending;
    778            uint8_t *write_ptr;
    779          
    780            // Made space in the buffer by reading
    781            uart_context->rx_buffer_full = false;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x7678             STRB     R0,[R7, #+25]
    782          
    783            // Pause the DMA to update
    784            ecode = DMADRV_PauseTransfer(uart_context->dma.channel);
   \        0xA   0x7A38             LDRB     R0,[R7, #+8]
   \        0xC   0x.... 0x....      BL       DMADRV_PauseTransfer
   \       0x10   0x0005             MOVS     R5,R0
    785            EFM_ASSERT(ecode == ECODE_OK);
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD101             BNE.N    ??update_ring_buffer_0
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE000             B.N      ??update_ring_buffer_1
   \                     ??update_ring_buffer_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \                     ??update_ring_buffer_1: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0
    786          
    787            // Get next byte to be written by DMA
    788            write_ptr = get_write_ptr(uart_context);
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0x.... 0x....      BL       get_write_ptr
   \       0x24   0x0006             MOVS     R6,R0
    789          
    790            // All data has been read, reset the DMA to re-use all the buffer
    791            if (write_ptr == uart_context->rx_read_ptr) {
   \       0x26   0x6978             LDR      R0,[R7, #+20]
   \       0x28   0x4286             CMP      R6,R0
   \       0x2A   0xD124             BNE.N    ??update_ring_buffer_2
    792              // Reset DMA to the start of the UART Rx Buffer and all control pointers
    793              uart_context->rx_data_available = false;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x7638             STRB     R0,[R7, #+24]
    794              write_ptr = uart_context->rx_buffer;
   \       0x30   0x68F8             LDR      R0,[R7, #+12]
   \       0x32   0x0006             MOVS     R6,R0
    795              uart_context->rx_read_ptr = write_ptr;
   \       0x34   0x617E             STR      R6,[R7, #+20]
    796              if (uart_context->sw_flow_control) {
   \       0x36   0xF897 0x002D      LDRB     R0,[R7, #+45]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??update_ring_buffer_3
    797                uart_context->ctrl_char_scan_ptr = uart_context->rx_read_ptr;
   \       0x3E   0x6978             LDR      R0,[R7, #+20]
   \       0x40   0x6338             STR      R0,[R7, #+48]
    798              }
    799          
    800              // Enable RXDATAV IRQ to signal next incoming byte
    801              uart_context->set_next_byte_detect(uart_context);
   \                     ??update_ring_buffer_3: (+1)
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x6A79             LDR      R1,[R7, #+36]
   \       0x46   0x4788             BLX      R1
    802          
    803              // Start new transfer for all rx_buffer
    804              ecode = DMADRV_PeripheralMemory(uart_context->dma.channel,
    805                                              uart_context->dma.cfg.peripheral_signal,
    806                                              write_ptr,
    807                                              uart_context->dma.cfg.src,
    808                                              true,
    809                                              uart_context->rx_buffer_len,
    810                                              dmadrvDataSize1,
    811                                              dma_irq_handler,
    812                                              uart_context);
   \       0x48   0x9704             STR      R7,[SP, #+16]
   \       0x4A   0x....             LDR.N    R0,??DataTable7_5
   \       0x4C   0x9003             STR      R0,[SP, #+12]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x9002             STR      R0,[SP, #+8]
   \       0x52   0x6938             LDR      R0,[R7, #+16]
   \       0x54   0x9001             STR      R0,[SP, #+4]
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0x687B             LDR      R3,[R7, #+4]
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0x6839             LDR      R1,[R7, #+0]
   \       0x60   0x7A38             LDRB     R0,[R7, #+8]
   \       0x62   0x.... 0x....      BL       DMADRV_PeripheralMemory
   \       0x66   0x0004             MOVS     R4,R0
    813              EFM_ASSERT(ecode == ECODE_OK);
   \       0x68   0x2C00             CMP      R4,#+0
   \       0x6A   0xD101             BNE.N    ??update_ring_buffer_4
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE000             B.N      ??update_ring_buffer_5
   \                     ??update_ring_buffer_4: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??update_ring_buffer_5: (+1)
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0xE025             B.N      ??update_ring_buffer_6
    814            }
    815            // Data still available in buffer
    816            else {
    817              uart_context->rx_data_available = true;
   \                     ??update_ring_buffer_2: (+1)
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0x7638             STRB     R0,[R7, #+24]
    818          
    819              // Unlock read (only in Kernel)
    820              #if defined(SL_CATALOG_KERNEL_PRESENT)
    821              if (uart_context->block) {
    822                EFM_ASSERT(uart_context->rx_data_available);     // Should always be data available here
    823                if (osSemaphoreGetCount(uart_context->read_signal) == 0) {
    824                  osStatus_t status = osSemaphoreRelease(uart_context->read_signal);
    825                  EFM_ASSERT(status == osOK);
    826                }
    827              }
    828              #endif // SL_CATALOG_KERNEL_PRESENT
    829          
    830              // Check if DMA is still active
    831              ecode = DMADRV_TransferDone(uart_context->dma.channel, &dma_done);
   \       0x7A   0xF10D 0x0115      ADD      R1,SP,#+21
   \       0x7E   0x7A38             LDRB     R0,[R7, #+8]
   \       0x80   0x.... 0x....      BL       DMADRV_TransferDone
   \       0x84   0x0004             MOVS     R4,R0
    832              EFM_ASSERT(ecode == ECODE_OK);
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD101             BNE.N    ??update_ring_buffer_7
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0xE000             B.N      ??update_ring_buffer_8
   \                     ??update_ring_buffer_7: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \                     ??update_ring_buffer_8: (+1)
   \       0x90   0xB2C0             UXTB     R0,R0
    833          
    834              // DMA stopped because it was full
    835              if (dma_done) {
   \       0x92   0xF89D 0x0015      LDRB     R0,[SP, #+21]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD013             BEQ.N    ??update_ring_buffer_6
    836                // Check if IRQ is pending
    837                ecode = DMADRV_TransferCompletePending(uart_context->dma.channel, &irq_pending);
   \       0x9A   0xA905             ADD      R1,SP,#+20
   \       0x9C   0x7A38             LDRB     R0,[R7, #+8]
   \       0x9E   0x.... 0x....      BL       DMADRV_TransferCompletePending
   \       0xA2   0x0004             MOVS     R4,R0
    838                EFM_ASSERT(ecode == ECODE_OK);
   \       0xA4   0x2C00             CMP      R4,#+0
   \       0xA6   0xD101             BNE.N    ??update_ring_buffer_9
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0xE000             B.N      ??update_ring_buffer_10
   \                     ??update_ring_buffer_9: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \                     ??update_ring_buffer_10: (+1)
   \       0xAE   0xB2C0             UXTB     R0,R0
    839          
    840                // No IRQ pending
    841                if (irq_pending == false) {
   \       0xB0   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD104             BNE.N    ??update_ring_buffer_6
    842                  // Call IRQ handler to start a new transfer over available space
    843                  dma_irq_handler(uart_context->dma.channel, 0, uart_context);
   \       0xB8   0x003A             MOVS     R2,R7
   \       0xBA   0x2100             MOVS     R1,#+0
   \       0xBC   0x7A38             LDRB     R0,[R7, #+8]
   \       0xBE   0x.... 0x....      BL       dma_irq_handler
    844                }
    845              }
    846            }
    847            // Resume DMA
    848            ecode = DMADRV_ResumeTransfer(uart_context->dma.channel);
   \                     ??update_ring_buffer_6: (+1)
   \       0xC2   0x7A38             LDRB     R0,[R7, #+8]
   \       0xC4   0x.... 0x....      BL       DMADRV_ResumeTransfer
    849            EFM_ASSERT(ecode == ECODE_OK);
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD101             BNE.N    ??update_ring_buffer_11
   \       0xCC   0x2101             MOVS     R1,#+1
   \       0xCE   0xE000             B.N      ??update_ring_buffer_12
   \                     ??update_ring_buffer_11: (+1)
   \       0xD0   0x2100             MOVS     R1,#+0
   \                     ??update_ring_buffer_12: (+1)
   \       0xD2   0xB2C9             UXTB     R1,R1
    850          }
   \       0xD4   0xB007             ADD      SP,SP,#+28
   \       0xD6   0xBDF0             POP      {R4-R7,PC}
    851          
    852          /***************************************************************************//**
    853           * Tries to read the requested amount of data.
    854           * Returns the number of bytes read.
    855           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    856          static size_t read_rx_buffer(sl_iostream_uart_context_t * uart_context,
    857                                       uint8_t * buffer,
    858                                       size_t buffer_len)
    859          {
   \                     read_rx_buffer: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
    860            if (buffer_len == 0) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??read_rx_buffer_0
    861              return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE09A             B.N      ??read_rx_buffer_1
    862            }
    863          
    864            if (uart_context->rx_data_available == false) {
   \                     ??read_rx_buffer_0: (+1)
   \       0x12   0x7E28             LDRB     R0,[R5, #+24]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??read_rx_buffer_2
    865              #if defined(SL_CATALOG_KERNEL_PRESENT)
    866              if (uart_context->block) {
    867                EFM_ASSERT(false);     // Should always have data in blocking mode
    868              }
    869              #endif
    870              return 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE095             B.N      ??read_rx_buffer_1
    871            }
    872            CORE_DECLARE_IRQ_STATE;
    873          
    874            uint8_t *write_ptr;     // Pointer to the next byte to be written by the (L)DMA
    875            size_t read_size = 0;     // Number of bytes processed from the Rx Buffer
   \                     ??read_rx_buffer_2: (+1)
   \       0x1C   0xF05F 0x0800      MOVS     R8,#+0
    876            size_t ret_val = 0;     // Number of bytes written to the user buffer
   \       0x20   0xF05F 0x0B00      MOVS     R11,#+0
    877          
    878            // Compute the read_size
    879            {
    880              #if defined(DMA_PRESENT)
    881              Ecode_t ecode;
    882              ecode = DMADRV_PauseTransfer(uart_context->dma.channel);
    883              EFM_ASSERT(ecode == ECODE_OK);
    884              #endif // DMA_PRESENT
    885          
    886              write_ptr = get_write_ptr(uart_context);
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       get_write_ptr
   \       0x2A   0x4682             MOV      R10,R0
    887          
    888              #if defined(DMA_PRESENT)
    889              ecode = DMADRV_ResumeTransfer(uart_context->dma.channel);
    890              EFM_ASSERT(ecode == ECODE_OK);
    891              #endif // DMA_PRESENT
    892          
    893              if (write_ptr == uart_context->rx_read_ptr) {
   \       0x2C   0x6968             LDR      R0,[R5, #+20]
   \       0x2E   0x4582             CMP      R10,R0
   \       0x30   0xD106             BNE.N    ??read_rx_buffer_3
    894                // (L)DMA is wrapped over rx_read_ptr, make sure it is stopped
    895                EFM_ASSERT(uart_context->rx_buffer_full == true);
   \       0x32   0x7E68             LDRB     R0,[R5, #+25]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD101             BNE.N    ??read_rx_buffer_4
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xE000             B.N      ??read_rx_buffer_5
   \                     ??read_rx_buffer_4: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??read_rx_buffer_5: (+1)
   \       0x3E   0xB2C0             UXTB     R0,R0
    896              }
    897          
    898              // (L)DMA ahead of read ptr, read data in between the (L)DMA and the read ptr
    899              if (write_ptr > uart_context->rx_read_ptr) {
   \                     ??read_rx_buffer_3: (+1)
   \       0x40   0x6968             LDR      R0,[R5, #+20]
   \       0x42   0x4550             CMP      R0,R10
   \       0x44   0xD203             BCS.N    ??read_rx_buffer_6
    900                read_size = write_ptr - uart_context->rx_read_ptr;
   \       0x46   0x696F             LDR      R7,[R5, #+20]
   \       0x48   0xEBBA 0x0707      SUBS     R7,R10,R7
   \       0x4C   0xE005             B.N      ??read_rx_buffer_7
    901              }
    902              // (L)DMA wrapped around RX buffer, read data between read ptr and end of RX buffer
    903              else {
    904                read_size = (uart_context->rx_buffer + uart_context->rx_buffer_len) - uart_context->rx_read_ptr;
   \                     ??read_rx_buffer_6: (+1)
   \       0x4E   0x68E9             LDR      R1,[R5, #+12]
   \       0x50   0x6928             LDR      R0,[R5, #+16]
   \       0x52   0xEB01 0x0700      ADD      R7,R1,R0
   \       0x56   0x6968             LDR      R0,[R5, #+20]
   \       0x58   0x1A3F             SUBS     R7,R7,R0
    905              }
    906          
    907              // read the smallest amount between the data available and the size of the user buffer
    908              read_size = buffer_len < read_size ? buffer_len : read_size;
   \                     ??read_rx_buffer_7: (+1)
   \       0x5A   0x42BC             CMP      R4,R7
   \       0x5C   0xD201             BCS.N    ??read_rx_buffer_8
   \       0x5E   0x0027             MOVS     R7,R4
   \       0x60   0xE7FF             B.N      ??read_rx_buffer_9
    909            }
    910          
    911            // Number of bytes written to user buffer can be different if control character are present
    912            ret_val = read_size;
   \                     ??read_rx_buffer_8: (+1)
   \                     ??read_rx_buffer_9: (+1)
   \       0x62   0x46B8             MOV      R8,R7
    913          
    914            // Read data
    915            {
    916              CORE_ENTER_ATOMIC();
   \       0x64   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x68   0x4681             MOV      R9,R0
    917          
    918              // Handle control character and copy data to the user buffer
    919              if (uart_context->sw_flow_control == true) {
   \       0x6A   0xF895 0x002D      LDRB     R0,[R5, #+45]
   \       0x6E   0x2801             CMP      R0,#+1
   \       0x70   0xD141             BNE.N    ??read_rx_buffer_10
    920                for (size_t bytes_read = 0; bytes_read < read_size; bytes_read++) {
   \       0x72   0x2000             MOVS     R0,#+0
   \                     ??read_rx_buffer_11: (+1)
   \       0x74   0x42B8             CMP      R0,R7
   \       0x76   0xD227             BCS.N    ??read_rx_buffer_12
    921                  // Found control character, update xon
    922                  if (*uart_context->rx_read_ptr == (uint8_t)UARTXON || *uart_context->rx_read_ptr == (uint8_t)UARTXOFF) {
   \       0x78   0x6969             LDR      R1,[R5, #+20]
   \       0x7A   0x7809             LDRB     R1,[R1, #+0]
   \       0x7C   0x2911             CMP      R1,#+17
   \       0x7E   0xD003             BEQ.N    ??read_rx_buffer_13
   \       0x80   0x6969             LDR      R1,[R5, #+20]
   \       0x82   0x7809             LDRB     R1,[R1, #+0]
   \       0x84   0x2913             CMP      R1,#+19
   \       0x86   0xD10F             BNE.N    ??read_rx_buffer_14
    923                    // Current byte is the most recent scanned byte. Apply control character
    924                    if (uart_context->rx_read_ptr == uart_context->ctrl_char_scan_ptr) {
   \                     ??read_rx_buffer_13: (+1)
   \       0x88   0x6969             LDR      R1,[R5, #+20]
   \       0x8A   0x6B2A             LDR      R2,[R5, #+48]
   \       0x8C   0x4291             CMP      R1,R2
   \       0x8E   0xD108             BNE.N    ??read_rx_buffer_15
    925                      sl_atomic_store(uart_context->xon, (*uart_context->rx_read_ptr == (uint8_t)UARTXON));
   \       0x90   0x6969             LDR      R1,[R5, #+20]
   \       0x92   0x7809             LDRB     R1,[R1, #+0]
   \       0x94   0x2911             CMP      R1,#+17
   \       0x96   0xD101             BNE.N    ??read_rx_buffer_16
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0xE000             B.N      ??read_rx_buffer_17
   \                     ??read_rx_buffer_16: (+1)
   \       0x9C   0x2100             MOVS     R1,#+0
   \                     ??read_rx_buffer_17: (+1)
   \       0x9E   0xF885 0x1034      STRB     R1,[R5, #+52]
    926                    }
    927                    ret_val--;
   \                     ??read_rx_buffer_15: (+1)
   \       0xA2   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \       0xA6   0xE003             B.N      ??read_rx_buffer_18
    928                  }
    929                  // No control character, read data and increment user buffer
    930                  else {
    931                    *buffer++ = *uart_context->rx_read_ptr;
   \                     ??read_rx_buffer_14: (+1)
   \       0xA8   0x6969             LDR      R1,[R5, #+20]
   \       0xAA   0x7809             LDRB     R1,[R1, #+0]
   \       0xAC   0x7031             STRB     R1,[R6, #+0]
   \       0xAE   0x1C76             ADDS     R6,R6,#+1
    932                  }
    933          
    934                  // Caught up to most recent scanned byte, increment the scan ptr
    935                  if (uart_context->rx_read_ptr == uart_context->ctrl_char_scan_ptr) {
   \                     ??read_rx_buffer_18: (+1)
   \       0xB0   0x696A             LDR      R2,[R5, #+20]
   \       0xB2   0x6B29             LDR      R1,[R5, #+48]
   \       0xB4   0x428A             CMP      R2,R1
   \       0xB6   0xD102             BNE.N    ??read_rx_buffer_19
    936                    uart_context->ctrl_char_scan_ptr++;
   \       0xB8   0x6B29             LDR      R1,[R5, #+48]
   \       0xBA   0x1C49             ADDS     R1,R1,#+1
   \       0xBC   0x6329             STR      R1,[R5, #+48]
    937                  }
    938          
    939                  // Go to next byte
    940                  uart_context->rx_read_ptr++;
   \                     ??read_rx_buffer_19: (+1)
   \       0xBE   0x6969             LDR      R1,[R5, #+20]
   \       0xC0   0x1C49             ADDS     R1,R1,#+1
   \       0xC2   0x6169             STR      R1,[R5, #+20]
    941                }
   \       0xC4   0x1C40             ADDS     R0,R0,#+1
   \       0xC6   0xE7D5             B.N      ??read_rx_buffer_11
    942          
    943                // Wrap ctrl_char_scan_ptr around the rx_buffer
    944                if (uart_context->ctrl_char_scan_ptr == (uart_context->rx_buffer + uart_context->rx_buffer_len)) {
   \                     ??read_rx_buffer_12: (+1)
   \       0xC8   0x6B28             LDR      R0,[R5, #+48]
   \       0xCA   0x68E9             LDR      R1,[R5, #+12]
   \       0xCC   0x692A             LDR      R2,[R5, #+16]
   \       0xCE   0x4411             ADD      R1,R1,R2
   \       0xD0   0x4288             CMP      R0,R1
   \       0xD2   0xD101             BNE.N    ??read_rx_buffer_20
    945                  uart_context->ctrl_char_scan_ptr = uart_context->rx_buffer;
   \       0xD4   0x68E8             LDR      R0,[R5, #+12]
   \       0xD6   0x6328             STR      R0,[R5, #+48]
    946                }
    947          
    948                EFM_ASSERT(uart_context->ctrl_char_scan_ptr >= uart_context->rx_buffer
    949                           && uart_context->ctrl_char_scan_ptr < (uart_context->rx_buffer + uart_context->rx_buffer_len));
   \                     ??read_rx_buffer_20: (+1)
   \       0xD8   0x6B29             LDR      R1,[R5, #+48]
   \       0xDA   0x68E8             LDR      R0,[R5, #+12]
   \       0xDC   0x4281             CMP      R1,R0
   \       0xDE   0xD307             BCC.N    ??read_rx_buffer_21
   \       0xE0   0x6B28             LDR      R0,[R5, #+48]
   \       0xE2   0x68EA             LDR      R2,[R5, #+12]
   \       0xE4   0x6929             LDR      R1,[R5, #+16]
   \       0xE6   0x4411             ADD      R1,R2,R1
   \       0xE8   0x4288             CMP      R0,R1
   \       0xEA   0xD201             BCS.N    ??read_rx_buffer_21
   \       0xEC   0x2001             MOVS     R0,#+1
   \       0xEE   0xE000             B.N      ??read_rx_buffer_22
   \                     ??read_rx_buffer_21: (+1)
   \       0xF0   0x2000             MOVS     R0,#+0
   \                     ??read_rx_buffer_22: (+1)
   \       0xF2   0xB2C0             UXTB     R0,R0
   \       0xF4   0xE00B             B.N      ??read_rx_buffer_23
    950              }
    951              // Copy the data to the output buffer
    952              else {
    953                memcpy(buffer, uart_context->rx_read_ptr, read_size);
   \                     ??read_rx_buffer_10: (+1)
   \       0xF6   0x9701             STR      R7,[SP, #+4]
   \       0xF8   0x6968             LDR      R0,[R5, #+20]
   \       0xFA   0x9000             STR      R0,[SP, #+0]
   \       0xFC   0x46B3             MOV      R11,R6
   \       0xFE   0x9A01             LDR      R2,[SP, #+4]
   \      0x100   0x9900             LDR      R1,[SP, #+0]
   \      0x102   0x4658             MOV      R0,R11
   \      0x104   0x.... 0x....      BL       __aeabi_memcpy
    954                // Increment rx read ptr
    955                uart_context->rx_read_ptr += read_size;
   \      0x108   0x6968             LDR      R0,[R5, #+20]
   \      0x10A   0x4438             ADD      R0,R0,R7
   \      0x10C   0x6168             STR      R0,[R5, #+20]
    956              }
    957          
    958              // Wrap rx_read_ptr around
    959              if (uart_context->rx_read_ptr == (uart_context->rx_buffer + uart_context->rx_buffer_len)) {
   \                     ??read_rx_buffer_23: (+1)
   \      0x10E   0x6968             LDR      R0,[R5, #+20]
   \      0x110   0x68EA             LDR      R2,[R5, #+12]
   \      0x112   0x6929             LDR      R1,[R5, #+16]
   \      0x114   0x4411             ADD      R1,R2,R1
   \      0x116   0x4288             CMP      R0,R1
   \      0x118   0xD101             BNE.N    ??read_rx_buffer_24
    960                uart_context->rx_read_ptr = uart_context->rx_buffer;
   \      0x11A   0x68E8             LDR      R0,[R5, #+12]
   \      0x11C   0x6168             STR      R0,[R5, #+20]
    961              }
    962          
    963              // Sanity check
    964              EFM_ASSERT(uart_context->rx_read_ptr >= uart_context->rx_buffer
    965                         && uart_context->rx_read_ptr < (uart_context->rx_buffer + uart_context->rx_buffer_len));
   \                     ??read_rx_buffer_24: (+1)
   \      0x11E   0x6969             LDR      R1,[R5, #+20]
   \      0x120   0x68E8             LDR      R0,[R5, #+12]
   \      0x122   0x4281             CMP      R1,R0
   \      0x124   0xD307             BCC.N    ??read_rx_buffer_25
   \      0x126   0x6968             LDR      R0,[R5, #+20]
   \      0x128   0x68EA             LDR      R2,[R5, #+12]
   \      0x12A   0x6929             LDR      R1,[R5, #+16]
   \      0x12C   0x4411             ADD      R1,R2,R1
   \      0x12E   0x4288             CMP      R0,R1
   \      0x130   0xD201             BCS.N    ??read_rx_buffer_25
   \      0x132   0x2001             MOVS     R0,#+1
   \      0x134   0xE000             B.N      ??read_rx_buffer_26
   \                     ??read_rx_buffer_25: (+1)
   \      0x136   0x2000             MOVS     R0,#+0
   \                     ??read_rx_buffer_26: (+1)
   \      0x138   0xB2C0             UXTB     R0,R0
    966            }
    967          
    968            // Update the ring buffer after read
    969            update_ring_buffer(uart_context);
   \      0x13A   0x0028             MOVS     R0,R5
   \      0x13C   0x.... 0x....      BL       update_ring_buffer
    970            CORE_EXIT_ATOMIC();
   \      0x140   0x4648             MOV      R0,R9
   \      0x142   0x.... 0x....      BL       CORE_ExitAtomic
    971          
    972            return ret_val;
   \      0x146   0x4640             MOV      R0,R8
   \                     ??read_rx_buffer_1: (+1)
   \      0x148   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    973          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0xF000'8003        DC32     0xf0008003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0xF000'8005        DC32     0xf0008005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x....'....        DC32     dma_irq_handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x5004'0058        DC32     0x50040058

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   __NVIC_ClearPendingIRQ
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ
      56   dma_irq_handler
        56   -- Indirect call
        56   -> DMADRV_PeripheralMemory
        56   -> get_write_ptr
       0   get_auto_cr_lf
       0   get_write_ptr
      48   nolock_uart_write
        48   -- Indirect call
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> scan_for_ctrl_char
      48   read_rx_buffer
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> __aeabi_memcpy
        48   -> get_write_ptr
        48   -> update_ring_buffer
       8   scan_for_ctrl_char
         8   -> get_write_ptr
       0   set_auto_cr_lf
      64   sli_iostream_uart_context_init
        64   -> DMADRV_AllocateChannel
        64   -> DMADRV_Init
        64   -> DMADRV_PeripheralMemory
        64   -> __NVIC_ClearPendingIRQ
        64   -> __NVIC_EnableIRQ
        64   -> __aeabi_memset
        64   -> sl_iostream_set_default
      32   uart_deinit
        32   -- Indirect call
        32   -> DMADRV_DeInit
        32   -> DMADRV_FreeChannel
        32   -> DMADRV_StopTransfer
        32   -> __NVIC_ClearPendingIRQ
        32   -> __NVIC_DisableIRQ
        32   -> sl_iostream_get_default
        32   -> sl_iostream_set_default
      32   uart_read
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> read_rx_buffer
      16   uart_write
        16   -> nolock_uart_write
      48   update_ring_buffer
        48   -- Indirect call
        48   -> DMADRV_PauseTransfer
        48   -> DMADRV_PeripheralMemory
        48   -> DMADRV_ResumeTransfer
        48   -> DMADRV_TransferCompletePending
        48   -> DMADRV_TransferDone
        48   -> dma_irq_handler
        48   -> get_write_ptr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
      32  __NVIC_ClearPendingIRQ
      40  __NVIC_DisableIRQ
      32  __NVIC_EnableIRQ
     156  dma_irq_handler
      12  get_auto_cr_lf
      56  get_write_ptr
     142  nolock_uart_write
     332  read_rx_buffer
     114  scan_for_ctrl_char
       8  set_auto_cr_lf
     270  sli_iostream_uart_context_init
     142  uart_deinit
      54  uart_read
      22  uart_write
     216  update_ring_buffer

 
 1'656 bytes in section .text
 
 1'656 bytes of CODE memory

Errors: none
Warnings: none
