###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         24/Dec/2024  14:34:32
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\ProAppSrc\HAL\uart_hal.c
#    Command line                 =
#        -f
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir\uart_hal.o.rsp
#        (C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\ProAppSrc\HAL\uart_hal.c
#        -D EFR32FG23A020F512GM40=1 -D SL_COMPONENT_CATALOG_PRESENT=1 -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -lC
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\HAL_18155169353449485031.dir
#        --diag_suppress Pa050 -o
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse -e --fpu=VFPv5_sp --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\.\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\AppConfigs\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\autogen\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\HAL\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\NVM\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\buffer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\event_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\list_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\queue_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\timer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\hif\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\raw_uart_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\debug_console\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\Device\SiliconLabs\EFR32FG23\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\device_init\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\mpu\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\toolchain\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\system\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\network-manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\RAIL_TRX\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MAC\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\wisun_modified\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\FANApp\AppInc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_callbacks\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ip\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\multicast\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\rpl\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\OS_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\L2_L3_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\cpu\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\contiki_mac_interface_layer\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\mac_sicslowpan_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emlib\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\platform\p3_lp_dk\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\common\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\efr32xg1x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_protocol\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_rssi\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MeterApp\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\FLASH\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\APP_LOG\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\NVM\nvm3\inc\
#        -On --use_c++_inline) --dependencies=n
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir\uart_hal.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\HAL_18155169353449485031.dir\uart_hal.lst
#    Object file                  =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir\uart_hal.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\ProAppSrc\HAL\uart_hal.c
      1          /** \file uart_hal.c
      2          *******************************************************************************
      3          ** \brief  Provides APIs for UART driver
      4          **
      5          ** \cond STD_FILE_HEADER
      6          **
      7          ** COPYRIGHT(c) 2023-24 Procubed Innovations Pvt Ltd.
      8          ** All rights reserved.
      9          **
     10          ** THIS SOFTWARE IS PROVIDED BY "AS IS" AND ALL WARRANTIES OF ANY KIND,
     11          ** INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR USE,
     12          ** ARE EXPRESSLY DISCLAIMED.  THE DEVELOPER SHALL NOT BE LIABLE FOR ANY
     13          ** DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. THIS SOFTWARE
     14          ** MAY NOT BE USED IN PRODUCTS INTENDED FOR USE IN IMPLANTATION OR OTHER
     15          ** DIRECT LIFE SUPPORT APPLICATIONS WHERE MALFUNCTION MAY RESULT IN THE DIRECT
     16          ** PHYSICAL HARM OR INJURY TO PERSONS. ALL SUCH IS USE IS EXPRESSLY PROHIBITED.
     17          **
     18          *******************************************************************************
     19          **  \endcond
     20          */
     21          
     22          
     23          /*******************************************************************************
     24          * File inclusion
     25          *******************************************************************************/
     26          
     27          #include "StackPHYConf.h"
     28          #include "pin_config.h"
     29          #include "common.h"
     30          #include "em_device.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __vfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....             LDR.N    R3,??DataTable10
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB249             SXTB     R1,R1
   \       0x16   0x0949             LSRS     R1,R1,#+5
   \       0x18   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_ClearPendingIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....             LDR.N    R3,??DataTable10_1
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB249             SXTB     R1,R1
   \       0x16   0x0949             LSRS     R1,R1,#+5
   \       0x18   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
     31          #include "em_cmu.h"
     32          #include "em_gpio.h"
     33          #include "em_usart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntClear(USART_TypeDef *, uint32_t)
   \                     USART_IntClear: (+1)
   \        0x0   0xF242 0x0248      MOVW     R2,#+8264
   \        0x4   0x5081             STR      R1,[R0, R2]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntDisable(USART_TypeDef *, uint32_t)
   \                     USART_IntDisable: (+1)
   \        0x0   0x6CC2             LDR      R2,[R0, #+76]
   \        0x2   0x438A             BICS     R2,R2,R1
   \        0x4   0x64C2             STR      R2,[R0, #+76]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntEnable(USART_TypeDef *, uint32_t)
   \                     USART_IntEnable: (+1)
   \        0x0   0x6CC2             LDR      R2,[R0, #+76]
   \        0x2   0x430A             ORRS     R2,R1,R2
   \        0x4   0x64C2             STR      R2,[R0, #+76]
   \        0x6   0x4770             BX       LR
     34          #include "em_eusart.h"
     35          #include "uart_hal.h"
     36          
     37          
     38          /*
     39          ** ============================================================================
     40          ** Private Macro definitions
     41          ** ============================================================================
     42          */
     43          #ifndef UART_TX_BUF_LEN
     44          #define UART_TX_BUF_LEN	2300
     45          #endif
     46          
     47          #ifndef NUMBER_OF_UART_TX_BUFFERS
     48          #define NUMBER_OF_UART_TX_BUFFERS	0
     49          #endif
     50          
     51          
     52          //#define APP_USART0_BAUDRATE 9600
     53          
     54          #define APP_USART0_BAUDRATE 9600
     55          
     56          #define APP_USART0_TX_PORT gpioPortA
     57          #define APP_USART0_TX_PIN 8
     58          
     59          #define APP_USART0_RX_PORT gpioPortA
     60          #define APP_USART0_RX_PIN 7
     61          /*
     62          ** ============================================================================
     63          ** Private Structures, Unions & enums Type Definitions
     64          ** ============================================================================
     65          */
     66          
     67          typedef struct P3_BUFFER_tag
     68          {
     69            uint8_t* p_data;
     70            uint16_t element_count;
     71            void* p_cb_param;
     72          }P3_BUFFER_t;
     73          

   \                                 In section .bss, align 4
     74          P3_BUFFER_t uart0_rx_buffer;
   \                     uart0_rx_buffer:
   \        0x0                      DS8 12
     75          

   \                                 In section .bss, align 4
     76          P3_BUFFER_t uart1_rx_buffer;
   \                     uart1_rx_buffer:
   \        0x0                      DS8 12
     77          
     78          /*
     79          When Using Only Usart as commucation to meater Usae USART0 default
     80          If SPI flash is requred the make communication USART0 to EUSART0 because USART0 is used by SPI
     81          Only 1 USART phereperal is avaliable 
     82          */
     83          /* Setup UART1 in async mode for RS232*/

   \                                 In section .data, align 4
     84          static USART_TypeDef           *uart0   = USART0;
   \                     uart0:
   \        0x0   0x5005'C000        DC32 0x5005'c000
     85          
     86          
     87          /*
     88          ** ============================================================================
     89          ** Private Variable Definitions
     90          ** ============================================================================
     91          */
     92          

   \                                 In section .bss, align 4
     93          volatile uint8_t * gp_uart0_tx_address;        /* uart1 transmit buffer address */
   \                     gp_uart0_tx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
     94          volatile uint16_t  g_uart0_tx_count;           /* uart1 transmit data number */
   \                     g_uart0_tx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
     95          volatile uint8_t * gp_uart0_rx_address;        /* uart1 receive buffer address */
   \                     gp_uart0_rx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
     96          volatile uint16_t  g_uart0_rx_count;           /* uart1 receive data number */
   \                     g_uart0_rx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
     97          volatile uint16_t  g_uart0_rx_length;          /* uart1 receive data length */
   \                     g_uart0_rx_length:
   \        0x0                      DS8 2
     98          

   \                                 In section .bss, align 4
     99          uart0_callback g_uart_cb; //UART0 cb variable
   \                     g_uart_cb:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    100          volatile uint8_t * gp_uart1_tx_address;        /* uart1 transmit buffer address */
   \                     gp_uart1_tx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
    101          volatile uint16_t  g_uart1_tx_count;           /* uart1 transmit data number */
   \                     g_uart1_tx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
    102          volatile uint8_t * gp_uart1_rx_address;        /* uart1 receive buffer address */
   \                     gp_uart1_rx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
    103          volatile uint16_t  g_uart1_rx_count;           /* uart1 receive data number */
   \                     g_uart1_rx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
    104          volatile uint16_t  g_uart1_rx_length;          /* uart1 receive data length */
   \                     g_uart1_rx_length:
   \        0x0                      DS8 2
    105          
    106          /*
    107          ** ============================================================================
    108          ** Private Macro definitions
    109          ** ============================================================================
    110          */
    111          
    112          
    113          
    114          
    115          
    116          /*
    117          ** ============================================================================
    118          ** Private Structures, Unions & enums Type Definitions
    119          ** ============================================================================
    120          */
    121          
    122          
    123          
    124          /*
    125          ** ============================================================================
    126          ** Public Variable Definitions
    127          ** ============================================================================
    128          */
    129          

   \                                 In section .bss, align 4
    130          uart_hal_data_t uart_hal_info;
   \                     uart_hal_info:
   \        0x0                      DS8 8

   \                                 In section .data, align 1
    131          volatile uint8_t uart0_trigger_tx = 1;
   \                     uart0_trigger_tx:
   \        0x0   0x01               DC8 1
    132          

   \                                 In section .data, align 1
    133          volatile uint8_t uart1_trigger_tx = 1;
   \                     uart1_trigger_tx:
   \        0x0   0x01               DC8 1
    134          static uint8_t uart1_rx_byte;
                                ^
Warning[Pe177]: variable "uart1_rx_byte" was declared but never referenced
    135          
    136          /*
    137          ** ============================================================================
    138          ** External Variable Declarations
    139          ** ============================================================================
    140          */
    141          
    142          /* None */
    143          
    144          /*
    145          ** ============================================================================
    146          ** Private Function Prototypes
    147          ** ============================================================================
    148          */
    149          
    150          /* None */
    151          
    152          /*
    153          ** ============================================================================
    154          ** Public Function Definitions
    155          ** ============================================================================
    156          */
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void UART_init(void)
    159          {  
   \                     UART_init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    160            
    161            /*
    162            
    163            Raka :: Needs to do clean up once UART is tested Properly  [ 13- Sep - 2022 ]
    164            */
    165            CMU_ClockEnable(cmuClock_USART0, true);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2029             MOVS     R0,#+41
   \        0x8   0x.... 0x....      BL       CMU_ClockEnable
    166            CMU_ClockEnable(cmuClock_GPIO, true);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x203A             MOVS     R0,#+58
   \       0x10   0x.... 0x....      BL       CMU_ClockEnable
    167            
    168            // Default asynchronous initializer (115.2 Kbps, 8N1, no flow control)
    169            
    170            USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;  // this is for FG13
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x....             LDR.N    R1,??DataTable10_2
   \       0x18   0x221C             MOVS     R2,#+28
   \       0x1A   0x.... 0x....      BL       __aeabi_memcpy4
    171            
    172            
    173            /* Configure GPIO pins  for communication UART  :: LOC 22*/
    174            GPIO_PinModeSet(APP_USART0_TX_PORT, APP_USART0_TX_PIN, gpioModePushPull, 1); // tx
   \       0x1E   0x2301             MOVS     R3,#+1
   \       0x20   0x2204             MOVS     R2,#+4
   \       0x22   0x2108             MOVS     R1,#+8
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x.... 0x....      BL       GPIO_PinModeSet
    175            GPIO_PinModeSet(APP_USART0_RX_PORT, APP_USART0_RX_PIN, gpioModeInput, 0);     // rx
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x2107             MOVS     R1,#+7
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x.... 0x....      BL       GPIO_PinModeSet
    176            
    177            
    178            // Route USART0 TX and RX to the board controller TX and RX pins
    179            GPIO->USARTROUTE[0].TXROUTE = (APP_USART0_TX_PORT << _GPIO_USART_TXROUTE_PORT_SHIFT)
    180              | (APP_USART0_TX_PIN << _GPIO_USART_TXROUTE_PIN_SHIFT);
   \       0x36   0xF45F 0x2100      MOVS     R1,#+524288
   \       0x3A   0x....             LDR.N    R0,??DataTable10_3
   \       0x3C   0x6001             STR      R1,[R0, #+0]
    181            GPIO->USARTROUTE[0].RXROUTE = (APP_USART0_RX_PORT << _GPIO_USART_RXROUTE_PORT_SHIFT)
    182              | (APP_USART0_RX_PIN << _GPIO_USART_RXROUTE_PIN_SHIFT);
   \       0x3E   0xF45F 0x21E0      MOVS     R1,#+458752
   \       0x42   0x....             LDR.N    R0,??DataTable10_4
   \       0x44   0x6001             STR      R1,[R0, #+0]
    183            // Clock configuration ....
    184            
    185            // Enable RX and TX signals now that they have been routed
    186            GPIO->USARTROUTE[0].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN | GPIO_USART_ROUTEEN_TXPEN;
   \       0x46   0x2114             MOVS     R1,#+20
   \       0x48   0x....             LDR.N    R0,??DataTable10_5
   \       0x4A   0x6001             STR      R1,[R0, #+0]
    187            
    188            // The Baud rate for the Communication.
    189            init.baudrate = APP_USART0_BAUDRATE ;
   \       0x4C   0xF44F 0x5016      MOV      R0,#+9600
   \       0x50   0x9002             STR      R0,[SP, #+8]
    190            
    191            // Configure and enable USART0
    192            USART_InitAsync(USART0, &init);          // this is for FG13 / FG23
   \       0x52   0x....             LDR.N    R4,??DataTable10_6
   \       0x54   0x4669             MOV      R1,SP
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       USART_InitAsync
    193            
    194            //// this is for FG13
    195            NVIC_ClearPendingIRQ(USART0_RX_IRQn);
   \       0x5C   0x2009             MOVS     R0,#+9
   \       0x5E   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    196            USART_IntEnable(USART0, USART_IEN_RXDATAV);
   \       0x62   0x2104             MOVS     R1,#+4
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       USART_IntEnable
    197            NVIC_EnableIRQ(USART0_RX_IRQn);
   \       0x6A   0x2009             MOVS     R0,#+9
   \       0x6C   0x.... 0x....      BL       __NVIC_EnableIRQ
    198            NVIC_ClearPendingIRQ(USART0_TX_IRQn);
   \       0x70   0x200A             MOVS     R0,#+10
   \       0x72   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    199            NVIC_EnableIRQ(USART0_TX_IRQn);
   \       0x76   0x200A             MOVS     R0,#+10
   \       0x78   0x.... 0x....      BL       __NVIC_EnableIRQ
    200            
    201            
    202          }
   \       0x7C   0xB008             ADD      SP,SP,#+32
   \       0x7E   0xBD10             POP      {R4,PC}
    203          
    204          /******************************************************************************/
    205          

   \                                 In section .text, align 2, keep-with-next
    206          void UART_close(void)
    207          {
   \                     UART_close: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    208            USART_Reset(uart0);         //This is for FG13 / FG23
   \        0x2   0x....             LDR.N    R0,??DataTable10_7
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x.... 0x....      BL       USART_Reset
    209            
    210          }
   \        0xA   0xBD01             POP      {R0,PC}
    211          
    212          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    213          int8_t uart_hal_read( uint8_t* p_data, uint16_t len )
    214          {
   \                     uart_hal_read: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    215            uart0_rx_buffer.p_data = p_data;
   \        0x2   0x....             LDR.N    R0,??DataTable10_8
   \        0x4   0x6002             STR      R2,[R0, #+0]
    216            uart0_rx_buffer.element_count = ( uint16_t )len;
   \        0x6   0x8081             STRH     R1,[R0, #+4]
    217            
    218            g_uart0_rx_count = 0U;
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x....             LDR.N    R0,??DataTable10_9
   \        0xC   0x8003             STRH     R3,[R0, #+0]
    219            g_uart0_rx_length = ( uint16_t )len;
   \        0xE   0x....             LDR.N    R0,??DataTable10_10
   \       0x10   0x8001             STRH     R1,[R0, #+0]
    220            gp_uart0_rx_address = p_data;
   \       0x12   0x....             LDR.N    R0,??DataTable10_11
   \       0x14   0x6002             STR      R2,[R0, #+0]
    221            
    222            return 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR
    223          }
    224          
    225          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          int8_t uart_hal_write( uint8_t* buffer, uint16_t len )
    227          {
   \                     uart_hal_write: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
    228            
    229            uint32_t sent = 0;
   \        0x8   0xF05F 0x0800      MOVS     R8,#+0
    230            uint8_t * _buffer = (uint8_t *) buffer;
   \        0xC   0x0025             MOVS     R5,R4
    231            
    232            while (len--)
   \                     ??uart_hal_write_0: (+1)
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0x1E46             SUBS     R6,R0,#+1
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00C             BEQ.N    ??uart_hal_write_1
    233            {
    234              USART_Tx(uart0, _buffer[sent++]);
   \       0x18   0x....             LDR.N    R7,??DataTable10_7
   \       0x1A   0xF815 0x1008      LDRB     R1,[R5, R8]
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x.... 0x....      BL       USART_Tx
   \       0x24   0xF118 0x0801      ADDS     R8,R8,#+1
    235              while (!(uart0->STATUS & USART_STATUS_TXC));
   \                     ??uart_hal_write_2: (+1)
   \       0x28   0x6838             LDR      R0,[R7, #+0]
   \       0x2A   0x6980             LDR      R0,[R0, #+24]
   \       0x2C   0x0680             LSLS     R0,R0,#+26
   \       0x2E   0xD4EE             BMI.N    ??uart_hal_write_0
   \       0x30   0xE7FA             B.N      ??uart_hal_write_2
    236            }
    237            return sent;
   \                     ??uart_hal_write_1: (+1)
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0xB240             SXTB     R0,R0
   \       0x36   0xE8BD 0x81F0      POP      {R4-R8,PC}
    238            //	if( len > UART_TX_BUF_LEN )
    239            //	{
    240            //		//let this get freed up as it is of more than the allowed UART packet size
    241            //		return -2;//
    242            //	}
    243            //
    244            //	/* Submit Outbound buffer to UART */
    245            //	if( 1 )
    246            //	{
    247            //          uart0_trigger_tx = 0;
    248            //
    249            //          gp_uart0_tx_address = p_data;
    250            //          g_uart0_tx_count = len;
    251            //
    252            //          /* Enable interrupt on USART TX Buffer*/
    253            //          USART_IntEnable(uart0, USART_IF_TXBL);
    254            //	}
    255            //	else
    256            //	{
    257            //		//uart is busy doing transmission of a packet initiated earlier. 
    258            //		//So let this buffer be put in a queue to be processed ata a 
    259            //		//later stage
    260            //		return -1;
    261            //		//queue_item_put( &uart_tx_buf_q,  (queue_item_t*) p_uart_tx_buff );
    262            //	}
    263            //
    264            //    return 0;
    265          }
    266          
    267          /******************************************************************************/
    268          

   \                                 In section .text, align 2, keep-with-next
    269          int8_t uart_hal_register_back(uart_hal_call_back cb, void* param)
    270          {
   \                     uart_hal_register_back: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    271            uart_hal_info.cb = cb;
   \        0x2   0x....             LDR.N    R0,??DataTable10_12
   \        0x4   0x6002             STR      R2,[R0, #+0]
    272            uart_hal_info.param = param;
   \        0x6   0x6041             STR      R1,[R0, #+4]
    273            return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
    274          }
    275          
    276          /*
    277          ** ============================================================================
    278          ** Private Function Definitions
    279          ** ============================================================================
    280          */
    281          

   \                                 In section .text, align 2, keep-with-next
    282          void UARTCallback( uint8_t eventid )
    283          {
   \                     UARTCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    284            switch (eventid) 
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??UARTCallback_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD012             BEQ.N    ??UARTCallback_1
   \       0x10   0xD30A             BCC.N    ??UARTCallback_2
   \       0x12   0xE011             B.N      ??UARTCallback_3
    285            {
    286            case 0://tx complete
    287              
    288              /*put back the buffer in the free pool*/
    289              uart0_trigger_tx = 1;
   \                     ??UARTCallback_0: (+1)
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x....             LDR.N    R0,??DataTable10_13
   \       0x18   0x7001             STRB     R1,[R0, #+0]
    290              
    291              /*invoke callback informing packet tx completion*/
    292              uart_hal_info.cb( NULL,TX_COMPLETE_EVENT,uart_hal_info.param );
   \       0x1A   0x....             LDR.N    R3,??DataTable10_12
   \       0x1C   0x685A             LDR      R2,[R3, #+4]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x681B             LDR      R3,[R3, #+0]
   \       0x24   0x4798             BLX      R3
    293              break;
   \       0x26   0xE007             B.N      ??UARTCallback_4
    294            case 1://rx complete
    295              /*invoke callback informing packet rx completion*/
    296              uart_hal_info.cb( NULL,RX_COMPLETE_EVENT,uart_hal_info.param );
   \                     ??UARTCallback_2: (+1)
   \       0x28   0x....             LDR.N    R3,??DataTable10_12
   \       0x2A   0x685A             LDR      R2,[R3, #+4]
   \       0x2C   0x2103             MOVS     R1,#+3
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x681B             LDR      R3,[R3, #+0]
   \       0x32   0x4798             BLX      R3
    297              break;
   \       0x34   0xE000             B.N      ??UARTCallback_4
    298            case 2://error
    299              break;
   \                     ??UARTCallback_1: (+1)
   \       0x36   0xE7FF             B.N      ??UARTCallback_4
    300              
    301            default:
    302              break;                    
    303            }
    304          }
   \                     ??UARTCallback_3: (+1)
   \                     ??UARTCallback_4: (+1)
   \       0x38   0xBD10             POP      {R4,PC}
    305          
    306          
    307          /**************************************************************************//**
    308          * @brief UART0 Callback register
    309          *
    310          *
    311          *****************************************************************************/
    312          

   \                                 In section .text, align 2, keep-with-next
    313          void register_uart0_cb( uart0_callback cb)
    314          {
    315            if(!g_uart_cb)
   \                     register_uart0_cb: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable10_14
   \        0x2   0x6811             LDR      R1,[R2, #+0]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD100             BNE.N    ??register_uart0_cb_0
    316            {
    317              g_uart_cb = cb;
   \        0x8   0x6010             STR      R0,[R2, #+0]
    318            }
    319          }
   \                     ??register_uart0_cb_0: (+1)
   \        0xA   0x4770             BX       LR
    320          
    321          /**************************************************************************//**
    322          * @brief UART1 RX IRQ Handler
    323          *
    324          * Set up the interrupt prior to use
    325          *
    326          * Note that this function handles overflows in a very simple way.
    327          *
    328          *****************************************************************************/

   \                                 In section .bss, align 4
    329          uint8_t uart_debug_buff [100] = {0};
   \                     uart_debug_buff:
   \        0x0                      DS8 100

   \                                 In section .bss, align 2
    330          uint16_t uart_debug_buff_Cnt = 0;
   \                     uart_debug_buff_Cnt:
   \        0x0                      DS8 2
    331          

   \                                 In section .text, align 2, keep-with-next
    332          void USART0_RX_IRQHandler(void)
    333          {
   \                     USART0_RX_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    334            uint8_t rxData;
    335            /* Check for RX data valid interrupt */
    336            if (uart0->STATUS & USART_STATUS_RXDATAV)
   \        0x2   0x....             LDR.N    R0,??DataTable10_7
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x6989             LDR      R1,[R1, #+24]
   \        0x8   0x0609             LSLS     R1,R1,#+24
   \        0xA   0xD510             BPL.N    ??USART0_RX_IRQHandler_0
    337            {
    338              /* Copy data into RX Buffer */
    339              rxData = USART_Rx(uart0);
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x.... 0x....      BL       USART_Rx
   \       0x12   0x0004             MOVS     R4,R0
    340              
    341              /* Clear RXDATAV interrupt */
    342              USART_IntClear(USART0, USART_IF_RXDATAV);
   \       0x14   0x2104             MOVS     R1,#+4
   \       0x16   0x....             LDR.N    R0,??DataTable10_6
   \       0x18   0x.... 0x....      BL       USART_IntClear
    343              
    344              if(g_uart_cb)
   \       0x1C   0x....             LDR.N    R1,??DataTable10_14
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??USART0_RX_IRQHandler_1
    345              {
    346                g_uart_cb(rxData); //indicate if any func register
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x6809             LDR      R1,[R1, #+0]
   \       0x2A   0x4788             BLX      R1
   \       0x2C   0xE004             B.N      ??USART0_RX_IRQHandler_1
    347              }
    348            }
    349            else
    350            {
    351              USART_IntClear(USART0, USART_STATUS_RXFULL);
   \                     ??USART0_RX_IRQHandler_0: (+1)
   \       0x2E   0xF44F 0x7180      MOV      R1,#+256
   \       0x32   0x....             LDR.N    R0,??DataTable10_6
   \       0x34   0x.... 0x....      BL       USART_IntClear
    352            }
    353          }
   \                     ??USART0_RX_IRQHandler_1: (+1)
   \       0x38   0xBD10             POP      {R4,PC}
    354          
    355          /**************************************************************************//**
    356          * @brief UART1 TX IRQ Handler
    357          *
    358          * Set up the interrupt prior to use
    359          *
    360          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    361          void USART0_TX_IRQHandler(void)
    362          {
   \                     USART0_TX_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    363            /* Check TX buffer level status */
    364            if (uart0->STATUS & USART_STATUS_TXBL)
   \        0x2   0x....             LDR.N    R4,??DataTable10_7
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6980             LDR      R0,[R0, #+24]
   \        0x8   0x0640             LSLS     R0,R0,#+25
   \        0xA   0xD517             BPL.N    ??USART0_TX_IRQHandler_0
    365            {
    366              if (g_uart0_tx_count > 0)
   \        0xC   0x....             LDR.N    R5,??DataTable10_15
   \        0xE   0x8828             LDRH     R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00C             BEQ.N    ??USART0_TX_IRQHandler_1
    367              {
    368                /* Transmit pending character */
    369                USART_Tx(uart0, *gp_uart0_tx_address++);      
   \       0x14   0x....             LDR.N    R0,??DataTable10_16
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x7809             LDRB     R1,[R1, #+0]
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x1C52             ADDS     R2,R2,#+1
   \       0x1E   0x6002             STR      R2,[R0, #+0]
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       USART_Tx
    370                g_uart0_tx_count--;
   \       0x28   0x8828             LDRH     R0,[R5, #+0]
   \       0x2A   0x1E40             SUBS     R0,R0,#+1
   \       0x2C   0x8028             STRH     R0,[R5, #+0]
    371              }
    372              
    373              /* Disable Tx interrupt if no more bytes to be sent */
    374              if (g_uart0_tx_count == 0)
   \                     ??USART0_TX_IRQHandler_1: (+1)
   \       0x2E   0x8828             LDRH     R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD103             BNE.N    ??USART0_TX_IRQHandler_0
    375              {
    376                USART_IntDisable(uart0, USART_IF_TXBL);
   \       0x34   0x2102             MOVS     R1,#+2
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       USART_IntDisable
    377                //send end
    378                // UARTCallback(0);
    379              }
    380            }
    381          }
   \                     ??USART0_TX_IRQHandler_0: (+1)
   \       0x3C   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x5003'C7B0        DC32     0x5003c7b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x5003'C7A8        DC32     0x5003c7a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x5003'C798        DC32     0x5003c798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x5005'C000        DC32     0x5005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x....'....        DC32     uart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x....'....        DC32     uart0_rx_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0x....'....        DC32     g_uart0_rx_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0x....'....        DC32     g_uart0_rx_length

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0x....'....        DC32     gp_uart0_rx_address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0x....'....        DC32     uart_hal_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \        0x0   0x....'....        DC32     uart0_trigger_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \        0x0   0x....'....        DC32     g_uart_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \        0x0   0x....'....        DC32     g_uart0_tx_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \        0x0   0x....'....        DC32     gp_uart0_tx_address

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x05               DC8 5
   \        0x1                      DS8 3
   \        0x4   0x0000'0000        DC32 0, 115'200
   \              0x0001'C200
   \        0xC   0x00 0x05          DC8 0, 5
   \        0xE   0x0000 0x1000      DC16 0, 4'096
   \       0x12   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00
   \       0x1A                      DS8 2
    382          
    383          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UARTCallback
         8   -- Indirect call
       8   UART_close
         8   -> USART_Reset
      40   UART_init
        40   -> CMU_ClockEnable
        40   -> GPIO_PinModeSet
        40   -> USART_InitAsync
        40   -> USART_IntEnable
        40   -> __NVIC_ClearPendingIRQ
        40   -> __NVIC_EnableIRQ
        40   -> __aeabi_memcpy4
       8   USART0_RX_IRQHandler
         8   -- Indirect call
         8   -> USART_IntClear
         8   -> USART_Rx
      16   USART0_TX_IRQHandler
        16   -> USART_IntDisable
        16   -> USART_Tx
       0   USART_IntClear
       0   USART_IntDisable
       0   USART_IntEnable
       0   __NVIC_ClearPendingIRQ
       0   __NVIC_EnableIRQ
       0   register_uart0_cb
       0   uart_hal_read
       0   uart_hal_register_back
      24   uart_hal_write
        24   -> USART_Tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      28  ?_0
      58  UARTCallback
      12  UART_close
     128  UART_init
      58  USART0_RX_IRQHandler
      62  USART0_TX_IRQHandler
       8  USART_IntClear
       8  USART_IntDisable
       8  USART_IntEnable
      30  __NVIC_ClearPendingIRQ
      30  __NVIC_EnableIRQ
       2  g_uart0_rx_count
       2  g_uart0_rx_length
       2  g_uart0_tx_count
       2  g_uart1_rx_count
       2  g_uart1_rx_length
       2  g_uart1_tx_count
       4  g_uart_cb
       4  gp_uart0_rx_address
       4  gp_uart0_tx_address
       4  gp_uart1_rx_address
       4  gp_uart1_tx_address
      12  register_uart0_cb
       4  uart0
      12  uart0_rx_buffer
       1  uart0_trigger_tx
      12  uart1_rx_buffer
       1  uart1_trigger_tx
     100  uart_debug_buff
       2  uart_debug_buff_Cnt
       8  uart_hal_info
      26  uart_hal_read
      12  uart_hal_register_back
      58  uart_hal_write

 
 166 bytes in section .bss
   6 bytes in section .data
  28 bytes in section .rodata
 578 bytes in section .text
 
 578 bytes of CODE  memory
  28 bytes of CONST memory
 172 bytes of DATA  memory

Errors: none
Warnings: 1
