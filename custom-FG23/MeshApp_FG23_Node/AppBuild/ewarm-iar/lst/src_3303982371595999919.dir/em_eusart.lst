###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         26/Nov/2024  12:16:02
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\SiliconLabs\platform\emlib\src\em_eusart.c
#    Command line      =
#        -f
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_3303982371595999919.dir\em_eusart.o.rsp
#        (C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\SiliconLabs\platform\emlib\src\em_eusart.c
#        -D EFR32FG23A020F512GM40=1 -D SL_COMPONENT_CATALOG_PRESENT=1 -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -lC
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\src_3303982371595999919.dir
#        --diag_suppress Pa050 -o
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_3303982371595999919.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse -e --fpu=VFPv5_sp --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\.\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\AppConfigs\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\autogen\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\HAL\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\NVM\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\buffer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\event_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\list_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\queue_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\timer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\hif\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\raw_uart_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\debug_console\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\Device\SiliconLabs\EFR32FG23\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\device_init\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\mpu\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\toolchain\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\system\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\network-manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\RAIL_TRX\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MAC\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\wisun_modified\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\FANApp\AppInc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_callbacks\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ip\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\multicast\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\rpl\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\OS_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\L2_L3_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\cpu\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\contiki_mac_interface_layer\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\mac_sicslowpan_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emlib\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\platform\p3_lp_dk\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\common\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\efr32xg1x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_protocol\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_rssi\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MeterApp\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\FLASH\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\APP_LOG\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\NVM\nvm3\inc\
#        -On --use_c++_inline) --dependencies=n
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_3303982371595999919.dir\em_eusart.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\src_3303982371595999919.dir\em_eusart.lst
#    Object file       =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\src_3303982371595999919.dir\em_eusart.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\SiliconLabs\platform\emlib\src\em_eusart.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Universal asynchronous receiver/transmitter (EUSART) peripheral API
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2019 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "em_eusart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t EUSART_StatusGet(EUSART_TypeDef *)
   \                     EUSART_StatusGet: (+1)
   \        0x0   0x6C80             LDR      R0,[R0, #+72]
   \        0x2   0x4770             BX       LR
     32          #if defined(EUART_PRESENT) || defined(EUSART_PRESENT)
     33          #include "em_cmu.h"
     34          #include <stddef.h>
     35          
     36          /*******************************************************************************
     37           *********************************   DEFINES   *********************************
     38           ******************************************************************************/
     39          
     40          #if defined(EUART_PRESENT)
     41            #define EUSART_REF_VALID(ref)    ((ref) == EUART0)
     42            #define EUSART_EM2_CAPABLE(ref)  (true)
     43            #define EUSART_RX_FIFO_SIZE  4u
     44          #elif defined(EUSART_PRESENT)
     45            #define EUSART_REF_VALID(ref)    (EUSART_NUM(ref) != -1)
     46            #define EUSART_RX_FIFO_SIZE  16u
     47          #endif
     48          
     49          /*******************************************************************************
     50           **************************   LOCAL VARIABLES   ********************************
     51           ******************************************************************************/
     52          #if defined(EUSART_DALICFG_DALIEN)
     53          static uint8_t dali_tx_nb_packets[EUSART_COUNT];
     54          static uint8_t dali_rx_nb_packets[EUSART_COUNT];
     55          #endif /* EUSART_DALICFG_DALIEN */
     56          
     57          /*******************************************************************************
     58           **************************   LOCAL FUNCTIONS   ********************************
     59           ******************************************************************************/
     60          
     61          static CMU_Clock_TypeDef EUSART_ClockGet(EUSART_TypeDef *eusart);
     62          
     63          static void EUSART_AsyncInitCommon(EUSART_TypeDef *eusart,
     64                                             const EUSART_UartInit_TypeDef *init,
     65                                             const EUSART_IrDAInit_TypeDef *irdaInit,
     66                                             const EUSART_DaliInit_TypeDef *daliInit);
     67          
     68          #if defined(EUSART_PRESENT)
     69          static void EUSART_SyncInitCommon(EUSART_TypeDef *eusart,
     70                                            const EUSART_SpiInit_TypeDef  *init);
     71          #endif
     72          
     73          /***************************************************************************//**
     74           * Wait for ongoing sync of register(s) to the low-frequency domain to complete.
     75           *
     76           * @param eusart Pointer to the EUSART peripheral register block.
     77           * @param mask A bitmask corresponding to SYNCBUSY register defined bits,
     78           *             indicating registers that must complete any ongoing
     79           *             synchronization.
     80           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          __STATIC_INLINE void eusart_sync(EUSART_TypeDef *eusart, uint32_t mask)
     82          {
     83            // Wait for any pending previous write operation to have been completed
     84            // in the low-frequency domain.
     85            while ((eusart->SYNCBUSY & mask) != 0U) {
   \                     eusart_sync: (+1)
   \                     ??eusart_sync_0: (+1)
   \        0x0   0x6D42             LDR      R2,[R0, #+84]
   \        0x2   0x420A             TST      R2,R1
   \        0x4   0xD1FC             BNE.N    ??eusart_sync_0
     86            }
     87          }
   \        0x6   0x4770             BX       LR
     88          
     89          /***************************************************************************//**
     90           *   Calculate baudrate for a given reference frequency, clock division,
     91           *   and oversampling rate.
     92           ******************************************************************************/
     93          __STATIC_INLINE uint32_t EUSART_AsyncBaudrateCalc(uint32_t refFreq,
     94                                                            uint32_t clkdiv,
     95                                                            EUSART_OVS_TypeDef ovs);
     96          
     97          /***************************************************************************//**
     98           *   Execute the EUSART peripheral disabling sequence.
     99           ******************************************************************************/
    100          __STATIC_INLINE void EUSART_Disable(EUSART_TypeDef *eusart);
    101          
    102          /*******************************************************************************
    103           **************************   GLOBAL FUNCTIONS   *******************************
    104           ******************************************************************************/
    105          
    106          /***************************************************************************//**
    107           * Initializes the EUSART when used with the high frequency clock.
    108           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    109          void EUSART_UartInitHf(EUSART_TypeDef *eusart, const EUSART_UartInit_TypeDef *init)
    110          {
   \                     EUSART_UartInitHf: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    111            // Make sure the module exists on the selected chip.
    112            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable13
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD101             BNE.N    ??EUSART_UartInitHf_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE00D             B.N      ??EUSART_UartInitHf_1
   \                     ??EUSART_UartInitHf_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD101             BNE.N    ??EUSART_UartInitHf_2
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE007             B.N      ??EUSART_UartInitHf_1
   \                     ??EUSART_UartInitHf_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD101             BNE.N    ??EUSART_UartInitHf_3
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE001             B.N      ??EUSART_UartInitHf_1
   \                     ??EUSART_UartInitHf_3: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_UartInitHf_1: (+1)
   \       0x2E   0xF110 0x0F01      CMN      R0,#+1
   \       0x32   0xD001             BEQ.N    ??EUSART_UartInitHf_4
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??EUSART_UartInitHf_5
   \                     ??EUSART_UartInitHf_4: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitHf_5: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0
    113            // Init structure must be provided.
    114            EFM_ASSERT(init);
    115          
    116            // Assert features specific to HF.
    117            // The oversampling must not be disabled when using a high frequency clock.
    118            EFM_ASSERT(init->oversampling != eusartOVS0);
   \       0x3C   0x7B28             LDRB     R0,[R5, #+12]
   \       0x3E   0x2880             CMP      R0,#+128
   \       0x40   0xD001             BEQ.N    ??EUSART_UartInitHf_6
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE000             B.N      ??EUSART_UartInitHf_7
   \                     ??EUSART_UartInitHf_6: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitHf_7: (+1)
   \       0x48   0xB2C0             UXTB     R0,R0
    119          
    120            // Uart mode only supports up to 9 databits frame.
    121            EFM_ASSERT(init->databits <= eusartDataBits9);
   \       0x4A   0x7B68             LDRB     R0,[R5, #+13]
   \       0x4C   0x2804             CMP      R0,#+4
   \       0x4E   0xDA01             BGE.N    ??EUSART_UartInitHf_8
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??EUSART_UartInitHf_9
   \                     ??EUSART_UartInitHf_8: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitHf_9: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
    122          
    123            // Initialize EUSART with common features to HF and LF.
    124            EUSART_AsyncInitCommon(eusart, init, NULL, NULL);
   \       0x58   0x2300             MOVS     R3,#+0
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0x0029             MOVS     R1,R5
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x.... 0x....      BL       EUSART_AsyncInitCommon
    125          }
   \       0x64   0xBD31             POP      {R0,R4,R5,PC}
    126          
    127          /***************************************************************************//**
    128           * Initializes the EUSART when used with the low frequency clock.
    129           *
    130           * @note (1) When EUSART oversampling is set to eusartOVS0 (Disable), the peripheral
    131           *           clock frequency must be at least three times higher than the
    132           *           chosen baud rate. In LF, max input clock is 32768 (LFXO or LFRCO),
    133           *           thus 32768 / 3 ~ 9600 baudrate.
    134           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          void EUSART_UartInitLf(EUSART_TypeDef *eusart, const EUSART_UartInit_TypeDef *init)
    136          {
   \                     EUSART_UartInitLf: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    137            // Make sure the module exists and is Low frequency capable.
    138            EFM_ASSERT(EUSART_REF_VALID(eusart) && EUSART_EM2_CAPABLE(EUSART_NUM(eusart)));
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable13
   \        0xA   0x428C             CMP      R4,R1
   \        0xC   0xD101             BNE.N    ??EUSART_UartInitLf_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE00D             B.N      ??EUSART_UartInitLf_1
   \                     ??EUSART_UartInitLf_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD101             BNE.N    ??EUSART_UartInitLf_2
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE007             B.N      ??EUSART_UartInitLf_1
   \                     ??EUSART_UartInitLf_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD101             BNE.N    ??EUSART_UartInitLf_3
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE001             B.N      ??EUSART_UartInitLf_1
   \                     ??EUSART_UartInitLf_3: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_UartInitLf_1: (+1)
   \       0x2E   0xF110 0x0F01      CMN      R0,#+1
   \       0x32   0xD046             BEQ.N    ??EUSART_UartInitLf_4
   \       0x34   0x428C             CMP      R4,R1
   \       0x36   0xD101             BNE.N    ??EUSART_UartInitLf_5
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE00D             B.N      ??EUSART_UartInitLf_6
   \                     ??EUSART_UartInitLf_5: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x40   0x4284             CMP      R4,R0
   \       0x42   0xD101             BNE.N    ??EUSART_UartInitLf_7
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE007             B.N      ??EUSART_UartInitLf_6
   \                     ??EUSART_UartInitLf_7: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x4C   0x4284             CMP      R4,R0
   \       0x4E   0xD101             BNE.N    ??EUSART_UartInitLf_8
   \       0x50   0x2002             MOVS     R0,#+2
   \       0x52   0xE001             B.N      ??EUSART_UartInitLf_6
   \                     ??EUSART_UartInitLf_8: (+1)
   \       0x54   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_UartInitLf_6: (+1)
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD101             BNE.N    ??EUSART_UartInitLf_9
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xE02C             B.N      ??EUSART_UartInitLf_10
   \                     ??EUSART_UartInitLf_9: (+1)
   \       0x60   0x428C             CMP      R4,R1
   \       0x62   0xD101             BNE.N    ??EUSART_UartInitLf_11
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE00D             B.N      ??EUSART_UartInitLf_12
   \                     ??EUSART_UartInitLf_11: (+1)
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x6C   0x4284             CMP      R4,R0
   \       0x6E   0xD101             BNE.N    ??EUSART_UartInitLf_13
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE007             B.N      ??EUSART_UartInitLf_12
   \                     ??EUSART_UartInitLf_13: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x78   0x4284             CMP      R4,R0
   \       0x7A   0xD101             BNE.N    ??EUSART_UartInitLf_14
   \       0x7C   0x2002             MOVS     R0,#+2
   \       0x7E   0xE001             B.N      ??EUSART_UartInitLf_12
   \                     ??EUSART_UartInitLf_14: (+1)
   \       0x80   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_UartInitLf_12: (+1)
   \       0x84   0x2801             CMP      R0,#+1
   \       0x86   0xD101             BNE.N    ??EUSART_UartInitLf_15
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xE016             B.N      ??EUSART_UartInitLf_10
   \                     ??EUSART_UartInitLf_15: (+1)
   \       0x8C   0x428C             CMP      R4,R1
   \       0x8E   0xD101             BNE.N    ??EUSART_UartInitLf_16
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xE00D             B.N      ??EUSART_UartInitLf_17
   \                     ??EUSART_UartInitLf_16: (+1)
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x98   0x4284             CMP      R4,R0
   \       0x9A   0xD101             BNE.N    ??EUSART_UartInitLf_18
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xE007             B.N      ??EUSART_UartInitLf_17
   \                     ??EUSART_UartInitLf_18: (+1)
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0xA4   0x4284             CMP      R4,R0
   \       0xA6   0xD101             BNE.N    ??EUSART_UartInitLf_19
   \       0xA8   0x2002             MOVS     R0,#+2
   \       0xAA   0xE001             B.N      ??EUSART_UartInitLf_17
   \                     ??EUSART_UartInitLf_19: (+1)
   \       0xAC   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_UartInitLf_17: (+1)
   \       0xB0   0x2802             CMP      R0,#+2
   \       0xB2   0xD101             BNE.N    ??EUSART_UartInitLf_20
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0xE000             B.N      ??EUSART_UartInitLf_10
   \                     ??EUSART_UartInitLf_20: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_10: (+1)
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD001             BEQ.N    ??EUSART_UartInitLf_4
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0xE000             B.N      ??EUSART_UartInitLf_21
   \                     ??EUSART_UartInitLf_4: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_21: (+1)
   \       0xC4   0xB2C0             UXTB     R0,R0
    139            // Init structure must be provided.
    140            EFM_ASSERT(init);
    141          
    142            // Assert features specific to LF.
    143            // LFXO, LFRCO, ULFRCO can be a clock source in LF.
    144          #if defined(DEBUG_EFM) || defined(DEBUG_EFM_USER)
    145            {
    146              CMU_Select_TypeDef clock_source = (CMU_Select_TypeDef) NULL;
    147          #if defined(EUART_PRESENT)
    148              if (eusart == EUART0) {
    149                clock_source = CMU_ClockSelectGet(cmuClock_EUART0);
    150              }
    151          #endif
    152          #if defined(EUSART_PRESENT) && defined(EUSART0)
    153              if (eusart == EUSART0) {
    154                clock_source = CMU_ClockSelectGet(cmuClock_EUSART0);
    155              }
    156          #endif
    157          
    158              EFM_ASSERT(
    159                (clock_source == cmuSelect_ULFRCO)
    160                || (clock_source == cmuSelect_LFXO)
    161                || (clock_source == cmuSelect_LFRCO)
    162                || (clock_source == cmuSelect_EM23GRPACLK)
    163          #if defined(_CMU_EUSART0CLKCTRL_CLKSEL_EM01GRPCCLK)
    164                || (clock_source == cmuSelect_EM01GRPCCLK) /* ULFRCO, LFXO, LFRCO, EM23GRPACLK or EM01GRPCCLK */
    165          #endif
    166                );
    167            }
    168          #endif
    169            // Uart mode only supports up to 9 databits frame.
    170            EFM_ASSERT(init->databits <= eusartDataBits9);
   \       0xC6   0x7B68             LDRB     R0,[R5, #+13]
   \       0xC8   0x2804             CMP      R0,#+4
   \       0xCA   0xDA01             BGE.N    ??EUSART_UartInitLf_22
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xE000             B.N      ??EUSART_UartInitLf_23
   \                     ??EUSART_UartInitLf_22: (+1)
   \       0xD0   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_23: (+1)
   \       0xD2   0xB2C0             UXTB     R0,R0
    171            // The oversampling must be disabled when using a low frequency clock.
    172            EFM_ASSERT(init->oversampling == eusartOVS0);
   \       0xD4   0x7B28             LDRB     R0,[R5, #+12]
   \       0xD6   0x2880             CMP      R0,#+128
   \       0xD8   0xD101             BNE.N    ??EUSART_UartInitLf_24
   \       0xDA   0x2001             MOVS     R0,#+1
   \       0xDC   0xE000             B.N      ??EUSART_UartInitLf_25
   \                     ??EUSART_UartInitLf_24: (+1)
   \       0xDE   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_25: (+1)
   \       0xE0   0xB2C0             UXTB     R0,R0
    173            // The Majority Vote must be disabled when using a low frequency clock.
    174            EFM_ASSERT(init->majorityVote == eusartMajorityVoteDisable);
   \       0xE2   0x6968             LDR      R0,[R5, #+20]
   \       0xE4   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0xE8   0xD101             BNE.N    ??EUSART_UartInitLf_26
   \       0xEA   0x2001             MOVS     R0,#+1
   \       0xEC   0xE000             B.N      ??EUSART_UartInitLf_27
   \                     ??EUSART_UartInitLf_26: (+1)
   \       0xEE   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_27: (+1)
   \       0xF0   0xB2C0             UXTB     R0,R0
    175            // Number of stop bits can only be 1 or 2 in LF.
    176            EFM_ASSERT((init->stopbits == eusartStopbits1) || (init->stopbits == eusartStopbits2));
   \       0xF2   0xF9B5 0x0010      LDRSH    R0,[R5, #+16]
   \       0xF6   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0xFA   0xD004             BEQ.N    ??EUSART_UartInitLf_28
   \       0xFC   0xF9B5 0x0010      LDRSH    R0,[R5, #+16]
   \      0x100   0xF5B0 0x5F40      CMP      R0,#+12288
   \      0x104   0xD101             BNE.N    ??EUSART_UartInitLf_29
   \                     ??EUSART_UartInitLf_28: (+1)
   \      0x106   0x2001             MOVS     R0,#+1
   \      0x108   0xE000             B.N      ??EUSART_UartInitLf_30
   \                     ??EUSART_UartInitLf_29: (+1)
   \      0x10A   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_30: (+1)
   \      0x10C   0xB2C0             UXTB     R0,R0
    177            // In LF, max baudrate is 9600. See Note #1.
    178            EFM_ASSERT(init->baudrate <= 9600 && init->baudrate != 0);
   \      0x10E   0x68A9             LDR      R1,[R5, #+8]
   \      0x110   0xF242 0x5081      MOVW     R0,#+9601
   \      0x114   0x4281             CMP      R1,R0
   \      0x116   0xD204             BCS.N    ??EUSART_UartInitLf_31
   \      0x118   0x68A8             LDR      R0,[R5, #+8]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD001             BEQ.N    ??EUSART_UartInitLf_31
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0xE000             B.N      ??EUSART_UartInitLf_32
   \                     ??EUSART_UartInitLf_31: (+1)
   \      0x122   0x2000             MOVS     R0,#+0
   \                     ??EUSART_UartInitLf_32: (+1)
   \      0x124   0xB2C0             UXTB     R0,R0
    179          
    180            // Initialize EUSART with common features to HF and LF.
    181            EUSART_AsyncInitCommon(eusart, init, NULL, NULL);
   \      0x126   0x2300             MOVS     R3,#+0
   \      0x128   0x2200             MOVS     R2,#+0
   \      0x12A   0x0029             MOVS     R1,R5
   \      0x12C   0x0020             MOVS     R0,R4
   \      0x12E   0x.... 0x....      BL       EUSART_AsyncInitCommon
    182          }
   \      0x132   0xBD31             POP      {R0,R4,R5,PC}
    183          
    184          /***************************************************************************//**
    185           * Initializes the EUSART when used in IrDA mode with the high or low
    186           * frequency clock.
    187           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    188          void EUSART_IrDAInit(EUSART_TypeDef *eusart,
    189                               const EUSART_IrDAInit_TypeDef *irdaInit)
    190          {
   \                     EUSART_IrDAInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    191            // Make sure the module exists on the selected chip.
    192            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable13
   \        0xA   0x428C             CMP      R4,R1
   \        0xC   0xD101             BNE.N    ??EUSART_IrDAInit_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE00D             B.N      ??EUSART_IrDAInit_1
   \                     ??EUSART_IrDAInit_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD101             BNE.N    ??EUSART_IrDAInit_2
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE007             B.N      ??EUSART_IrDAInit_1
   \                     ??EUSART_IrDAInit_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD101             BNE.N    ??EUSART_IrDAInit_3
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE001             B.N      ??EUSART_IrDAInit_1
   \                     ??EUSART_IrDAInit_3: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_IrDAInit_1: (+1)
   \       0x2E   0xF110 0x0F01      CMN      R0,#+1
   \       0x32   0xD001             BEQ.N    ??EUSART_IrDAInit_4
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??EUSART_IrDAInit_5
   \                     ??EUSART_IrDAInit_4: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_5: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0
    193            // Init structure must be provided.
    194            EFM_ASSERT(irdaInit);
    195          
    196            if (irdaInit->irDALowFrequencyEnable) {
   \       0x3C   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD06B             BEQ.N    ??EUSART_IrDAInit_6
    197              // Validate the low frequency capability of the EUSART instance.
    198              EFM_ASSERT(EUSART_EM2_CAPABLE(EUSART_NUM(eusart)));
   \       0x44   0x428C             CMP      R4,R1
   \       0x46   0xD101             BNE.N    ??EUSART_IrDAInit_7
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE00D             B.N      ??EUSART_IrDAInit_8
   \                     ??EUSART_IrDAInit_7: (+1)
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x50   0x4284             CMP      R4,R0
   \       0x52   0xD101             BNE.N    ??EUSART_IrDAInit_9
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE007             B.N      ??EUSART_IrDAInit_8
   \                     ??EUSART_IrDAInit_9: (+1)
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x5C   0x4284             CMP      R4,R0
   \       0x5E   0xD101             BNE.N    ??EUSART_IrDAInit_10
   \       0x60   0x2002             MOVS     R0,#+2
   \       0x62   0xE001             B.N      ??EUSART_IrDAInit_8
   \                     ??EUSART_IrDAInit_10: (+1)
   \       0x64   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_IrDAInit_8: (+1)
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD101             BNE.N    ??EUSART_IrDAInit_11
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE02C             B.N      ??EUSART_IrDAInit_12
   \                     ??EUSART_IrDAInit_11: (+1)
   \       0x70   0x428C             CMP      R4,R1
   \       0x72   0xD101             BNE.N    ??EUSART_IrDAInit_13
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xE00D             B.N      ??EUSART_IrDAInit_14
   \                     ??EUSART_IrDAInit_13: (+1)
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x7C   0x4284             CMP      R4,R0
   \       0x7E   0xD101             BNE.N    ??EUSART_IrDAInit_15
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE007             B.N      ??EUSART_IrDAInit_14
   \                     ??EUSART_IrDAInit_15: (+1)
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x88   0x4284             CMP      R4,R0
   \       0x8A   0xD101             BNE.N    ??EUSART_IrDAInit_16
   \       0x8C   0x2002             MOVS     R0,#+2
   \       0x8E   0xE001             B.N      ??EUSART_IrDAInit_14
   \                     ??EUSART_IrDAInit_16: (+1)
   \       0x90   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_IrDAInit_14: (+1)
   \       0x94   0x2801             CMP      R0,#+1
   \       0x96   0xD101             BNE.N    ??EUSART_IrDAInit_17
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xE016             B.N      ??EUSART_IrDAInit_12
   \                     ??EUSART_IrDAInit_17: (+1)
   \       0x9C   0x428C             CMP      R4,R1
   \       0x9E   0xD101             BNE.N    ??EUSART_IrDAInit_18
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xE00D             B.N      ??EUSART_IrDAInit_19
   \                     ??EUSART_IrDAInit_18: (+1)
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0xA8   0x4284             CMP      R4,R0
   \       0xAA   0xD101             BNE.N    ??EUSART_IrDAInit_20
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE007             B.N      ??EUSART_IrDAInit_19
   \                     ??EUSART_IrDAInit_20: (+1)
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0xB4   0x4284             CMP      R4,R0
   \       0xB6   0xD101             BNE.N    ??EUSART_IrDAInit_21
   \       0xB8   0x2002             MOVS     R0,#+2
   \       0xBA   0xE001             B.N      ??EUSART_IrDAInit_19
   \                     ??EUSART_IrDAInit_21: (+1)
   \       0xBC   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_IrDAInit_19: (+1)
   \       0xC0   0x2802             CMP      R0,#+2
   \       0xC2   0xD101             BNE.N    ??EUSART_IrDAInit_22
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xE000             B.N      ??EUSART_IrDAInit_12
   \                     ??EUSART_IrDAInit_22: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
    199              // The oversampling must be disabled when using a low frequency clock.
    200              EFM_ASSERT(irdaInit->init.oversampling == eusartOVS0);
   \                     ??EUSART_IrDAInit_12: (+1)
   \       0xCA   0x7B28             LDRB     R0,[R5, #+12]
   \       0xCC   0x2880             CMP      R0,#+128
   \       0xCE   0xD101             BNE.N    ??EUSART_IrDAInit_23
   \       0xD0   0x2001             MOVS     R0,#+1
   \       0xD2   0xE000             B.N      ??EUSART_IrDAInit_24
   \                     ??EUSART_IrDAInit_23: (+1)
   \       0xD4   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_24: (+1)
   \       0xD6   0xB2C0             UXTB     R0,R0
    201              // Number of stop bits can only be 1 or 2 in LF.
    202              EFM_ASSERT((irdaInit->init.stopbits == eusartStopbits1) || (irdaInit->init.stopbits == eusartStopbits2));
   \       0xD8   0xF9B5 0x0010      LDRSH    R0,[R5, #+16]
   \       0xDC   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0xE0   0xD004             BEQ.N    ??EUSART_IrDAInit_25
   \       0xE2   0xF9B5 0x0010      LDRSH    R0,[R5, #+16]
   \       0xE6   0xF5B0 0x5F40      CMP      R0,#+12288
   \       0xEA   0xD101             BNE.N    ??EUSART_IrDAInit_26
   \                     ??EUSART_IrDAInit_25: (+1)
   \       0xEC   0x2001             MOVS     R0,#+1
   \       0xEE   0xE000             B.N      ??EUSART_IrDAInit_27
   \                     ??EUSART_IrDAInit_26: (+1)
   \       0xF0   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_27: (+1)
   \       0xF2   0xB2C0             UXTB     R0,R0
    203              // In LF, max baudrate is 9600. See Note #1.
    204              EFM_ASSERT(irdaInit->init.baudrate <= 9600);
   \       0xF4   0x68A9             LDR      R1,[R5, #+8]
   \       0xF6   0xF242 0x5081      MOVW     R0,#+9601
   \       0xFA   0x4281             CMP      R1,R0
   \       0xFC   0xD201             BCS.N    ??EUSART_IrDAInit_28
   \       0xFE   0x2001             MOVS     R0,#+1
   \      0x100   0xE000             B.N      ??EUSART_IrDAInit_29
   \                     ??EUSART_IrDAInit_28: (+1)
   \      0x102   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_29: (+1)
   \      0x104   0xB2C0             UXTB     R0,R0
    205              EFM_ASSERT(irdaInit->init.enable == eusartEnableRx || irdaInit->init.enable == eusartDisable);
   \      0x106   0x7828             LDRB     R0,[R5, #+0]
   \      0x108   0x2809             CMP      R0,#+9
   \      0x10A   0xD002             BEQ.N    ??EUSART_IrDAInit_30
   \      0x10C   0x7828             LDRB     R0,[R5, #+0]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD101             BNE.N    ??EUSART_IrDAInit_31
   \                     ??EUSART_IrDAInit_30: (+1)
   \      0x112   0x2001             MOVS     R0,#+1
   \      0x114   0xE000             B.N      ??EUSART_IrDAInit_32
   \                     ??EUSART_IrDAInit_31: (+1)
   \      0x116   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_32: (+1)
   \      0x118   0xB2C0             UXTB     R0,R0
   \      0x11A   0xE013             B.N      ??EUSART_IrDAInit_33
    206            } else {
    207              EFM_ASSERT(irdaInit->init.oversampling != eusartOVS0);
   \                     ??EUSART_IrDAInit_6: (+1)
   \      0x11C   0x7B28             LDRB     R0,[R5, #+12]
   \      0x11E   0x2880             CMP      R0,#+128
   \      0x120   0xD001             BEQ.N    ??EUSART_IrDAInit_34
   \      0x122   0x2001             MOVS     R0,#+1
   \      0x124   0xE000             B.N      ??EUSART_IrDAInit_35
   \                     ??EUSART_IrDAInit_34: (+1)
   \      0x126   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_35: (+1)
   \      0x128   0xB2C0             UXTB     R0,R0
    208              // In HF, 2.4 kbps <= baudrate <= 1.152 Mbps.
    209              EFM_ASSERT(irdaInit->init.baudrate >= 2400 && irdaInit->init.baudrate <= 1152000);
   \      0x12A   0x68A8             LDR      R0,[R5, #+8]
   \      0x12C   0xF5B0 0x6F16      CMP      R0,#+2400
   \      0x130   0xD306             BCC.N    ??EUSART_IrDAInit_36
   \      0x132   0x68A9             LDR      R1,[R5, #+8]
   \      0x134   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x138   0x4281             CMP      R1,R0
   \      0x13A   0xD201             BCS.N    ??EUSART_IrDAInit_36
   \      0x13C   0x2001             MOVS     R0,#+1
   \      0x13E   0xE000             B.N      ??EUSART_IrDAInit_37
   \                     ??EUSART_IrDAInit_36: (+1)
   \      0x140   0x2000             MOVS     R0,#+0
   \                     ??EUSART_IrDAInit_37: (+1)
   \      0x142   0xB2C0             UXTB     R0,R0
    210            }
    211          
    212            // Initialize EUSART with common features to HF and LF.
    213            EUSART_AsyncInitCommon(eusart, &irdaInit->init, irdaInit, NULL);
   \                     ??EUSART_IrDAInit_33: (+1)
   \      0x144   0x2300             MOVS     R3,#+0
   \      0x146   0x002A             MOVS     R2,R5
   \      0x148   0x0029             MOVS     R1,R5
   \      0x14A   0x0020             MOVS     R0,R4
   \      0x14C   0x.... 0x....      BL       EUSART_AsyncInitCommon
    214          }
   \      0x150   0xBD31             POP      {R0,R4,R5,PC}
    215          
    216          #if defined(EUSART_PRESENT)
    217          /***************************************************************************//**
    218           * Initializes the EUSART when used in SPI mode.
    219           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void EUSART_SpiInit(EUSART_TypeDef *eusart, EUSART_SpiInit_TypeDef const *init)
    221          {
   \                     EUSART_SpiInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    222            // Make sure the module exists on the selected chip.
    223            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable13
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD101             BNE.N    ??EUSART_SpiInit_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE00D             B.N      ??EUSART_SpiInit_1
   \                     ??EUSART_SpiInit_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD101             BNE.N    ??EUSART_SpiInit_2
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE007             B.N      ??EUSART_SpiInit_1
   \                     ??EUSART_SpiInit_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD101             BNE.N    ??EUSART_SpiInit_3
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE001             B.N      ??EUSART_SpiInit_1
   \                     ??EUSART_SpiInit_3: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_SpiInit_1: (+1)
   \       0x2E   0xF110 0x0F01      CMN      R0,#+1
   \       0x32   0xD001             BEQ.N    ??EUSART_SpiInit_4
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??EUSART_SpiInit_5
   \                     ??EUSART_SpiInit_4: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??EUSART_SpiInit_5: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0
    224            // Init structure must be provided.
    225            EFM_ASSERT(init);
    226            if (init->master) {
   \       0x3C   0x7B68             LDRB     R0,[R5, #+13]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD011             BEQ.N    ??EUSART_SpiInit_6
    227              EFM_ASSERT(init->bitRate <= 20000000);
   \       0x42   0x68A9             LDR      R1,[R5, #+8]
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x48   0x4281             CMP      R1,R0
   \       0x4A   0xD201             BCS.N    ??EUSART_SpiInit_7
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xE000             B.N      ??EUSART_SpiInit_8
   \                     ??EUSART_SpiInit_7: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??EUSART_SpiInit_8: (+1)
   \       0x52   0xB2C0             UXTB     R0,R0
    228          
    229              if (init->advancedSettings) {
   \       0x54   0x6928             LDR      R0,[R5, #+16]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD029             BEQ.N    ??EUSART_SpiInit_9
    230                EFM_ASSERT(!(init->advancedSettings->prsClockEnable));
   \       0x5A   0x6928             LDR      R0,[R5, #+16]
   \       0x5C   0x7BC0             LDRB     R0,[R0, #+15]
   \       0x5E   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0x62   0xB2C0             UXTB     R0,R0
   \       0x64   0xE023             B.N      ??EUSART_SpiInit_9
    231              }
    232            } else {
    233              EFM_ASSERT(init->bitRate <= 10000000);
   \                     ??EUSART_SpiInit_6: (+1)
   \       0x66   0x68A9             LDR      R1,[R5, #+8]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \       0x6C   0x4281             CMP      R1,R0
   \       0x6E   0xD201             BCS.N    ??EUSART_SpiInit_10
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE000             B.N      ??EUSART_SpiInit_11
   \                     ??EUSART_SpiInit_10: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??EUSART_SpiInit_11: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
    234              if (init->advancedSettings && init->advancedSettings->forceLoad) {
   \       0x78   0x6928             LDR      R0,[R5, #+16]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD017             BEQ.N    ??EUSART_SpiInit_9
   \       0x7E   0x6928             LDR      R0,[R5, #+16]
   \       0x80   0x7F00             LDRB     R0,[R0, #+28]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD013             BEQ.N    ??EUSART_SpiInit_9
    235                // If baud-rate is more than 5MHz, a value of 4 is recommended, any values
    236                // smaller than that can be tried out but avoid using 0. If baud-rate is less than 5MHz,
    237                // value of 5 is recommended, values higher than 5 can be used but it may make the load
    238                // error easy to occur. The recommended values for frequency bands should be sufficient
    239                // to work all the time.
    240                EFM_ASSERT((init->bitRate >= 5000000 && init->advancedSettings->setupWindow <= 4)
    241                           || (init->bitRate < 5000000 && init->advancedSettings->setupWindow >= 5));
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \       0x8A   0x68A9             LDR      R1,[R5, #+8]
   \       0x8C   0x4281             CMP      R1,R0
   \       0x8E   0xD303             BCC.N    ??EUSART_SpiInit_12
   \       0x90   0x6929             LDR      R1,[R5, #+16]
   \       0x92   0x7F49             LDRB     R1,[R1, #+29]
   \       0x94   0x2905             CMP      R1,#+5
   \       0x96   0xDB06             BLT.N    ??EUSART_SpiInit_13
   \                     ??EUSART_SpiInit_12: (+1)
   \       0x98   0x68A9             LDR      R1,[R5, #+8]
   \       0x9A   0x4281             CMP      R1,R0
   \       0x9C   0xD205             BCS.N    ??EUSART_SpiInit_14
   \       0x9E   0x6928             LDR      R0,[R5, #+16]
   \       0xA0   0x7F40             LDRB     R0,[R0, #+29]
   \       0xA2   0x2805             CMP      R0,#+5
   \       0xA4   0xDB01             BLT.N    ??EUSART_SpiInit_14
   \                     ??EUSART_SpiInit_13: (+1)
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE000             B.N      ??EUSART_SpiInit_15
   \                     ??EUSART_SpiInit_14: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \                     ??EUSART_SpiInit_15: (+1)
   \       0xAC   0xB2C0             UXTB     R0,R0
    242              }
    243            }
    244          
    245            EUSART_SyncInitCommon(eusart, init);
   \                     ??EUSART_SpiInit_9: (+1)
   \       0xAE   0x0029             MOVS     R1,R5
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0x.... 0x....      BL       EUSART_SyncInitCommon
    246          }
   \       0xB6   0xBD31             POP      {R0,R4,R5,PC}
    247          
    248          #if defined(EUSART_DALICFG_DALIEN)
    249          /***************************************************************************//**
    250           * Initializes the EUSART when used in DALI mode with the high or low
    251           * frequency clock.
    252           *
    253           * @note (1) When EUSART oversampling is set to eusartOVS0 (Disable), the peripheral
    254           *           clock frequency must be at least three times higher than the
    255           *           chosen baud rate. In LF, max input clock is 32768 (LFXO or LFRCO),
    256           *           thus 32768 / 3 ~ 9600 baudrate.
    257           ******************************************************************************/
    258          void EUSART_DaliInit(EUSART_TypeDef *eusart,
    259                               const EUSART_DaliInit_TypeDef *daliInit)
    260          {
    261            // Make sure the module exists on the selected chip.
    262            EFM_ASSERT(EUSART_REF_VALID(eusart));
    263            // Init structure must be provided.
    264            EFM_ASSERT(daliInit);
    265          
    266            if (daliInit->init.loopbackEnable) {
    267              // If LOOPBK in CFG0 is set to 1 in order to do loopback testing for DALI,
    268              // then in this case DALIRXENDT should be set to 1 and DALIRXDATABITS should
    269              // be set the same as DALITXDATABITS.
    270              EFM_ASSERT( (daliInit->TXdatabits >> _EUSART_DALICFG_DALITXDATABITS_SHIFT)
    271                          == (daliInit->RXdatabits >> _EUSART_DALICFG_DALIRXDATABITS_SHIFT));
    272            }
    273          
    274            if (daliInit->daliLowFrequencyEnable) {
    275              // Validate the low frequency capability of the EUSART instance.
    276              EFM_ASSERT(EUSART_EM2_CAPABLE(EUSART_NUM(eusart)));
    277              // The oversampling must be disabled when using a low frequency clock.
    278              EFM_ASSERT(daliInit->init.oversampling == eusartOVS0);
    279              // In LF, max baudrate is 9600. See Note #1.
    280              // but manchester is running at 2x clock 9600 => 4800
    281              EFM_ASSERT(daliInit->init.baudrate <= 4800);
    282            } else {
    283              EFM_ASSERT(daliInit->init.oversampling != eusartOVS0);
    284              // In HF, 2.4 kbps <= baudrate <= 1.152 Mbps.
    285              // but manchester is running at 2x clock so 2.4 kbps => 1.2 kbps
    286              EFM_ASSERT(daliInit->init.baudrate >= 1200 && daliInit->init.baudrate <= 57600);
    287            }
    288          
    289            // Initialize EUSART with common features to HF and LF.
    290            EUSART_AsyncInitCommon(eusart, &daliInit->init, NULL, daliInit);
    291          }
    292          #endif /* EUSART_DALICFG_DALIEN */
    293          #endif /* EUSART_PRESENT */
    294          
    295          /***************************************************************************//**
    296           * Configure the EUSART to its reset state.
    297           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    298          void EUSART_Reset(EUSART_TypeDef *eusart)
    299          {
   \                     EUSART_Reset: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    300            // 1. Properly disable the module
    301            EUSART_Disable(eusart);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x.... 0x....      BL       EUSART_Disable
    302          
    303          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_3)  \
    304            || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_4) \
    305            || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_5) \
    306            || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_6)
    307            // Manual toggling tx_sclk_mst to synchronize handshake
    308            // when switching from SPI master to other modes
    309            // so module is disabling correctly.
    310            uint32_t forcedClkCycle = 4u;
   \        0xA   0x2104             MOVS     R1,#+4
    311          
    312            while (forcedClkCycle--) {
   \                     ??EUSART_Reset_0: (+1)
   \        0xC   0x0008             MOVS     R0,R1
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD008             BEQ.N    ??EUSART_Reset_1
    313              eusart->CFG2_SET = _EUSART_CFG2_CLKPHA_MASK;
   \       0x14   0x2204             MOVS     R2,#+4
   \       0x16   0xF241 0x0010      MOVW     R0,#+4112
   \       0x1A   0x5022             STR      R2,[R4, R0]
    314              eusart->CFG2_CLR = _EUSART_CFG2_CLKPHA_MASK;
   \       0x1C   0x2204             MOVS     R2,#+4
   \       0x1E   0xF242 0x0010      MOVW     R0,#+8208
   \       0x22   0x5022             STR      R2,[R4, R0]
   \       0x24   0xE7F2             B.N      ??EUSART_Reset_0
    315            }
    316          #endif
    317            // All registers that end with CFG should be programmed before EUSART gets enabled (EUSARTn_EN is set).
    318            // Set all configurable register to its reset value.
    319            // Note: Program desired settings to all registers that have names ending with CFG in the following sequence:
    320            //  a. CFG2
    321          #if defined(EUSART_PRESENT)
    322            eusart->CFG2 = _EUSART_CFG2_RESETVALUE;
   \                     ??EUSART_Reset_1: (+1)
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0x6120             STR      R0,[R4, #+16]
    323          #endif
    324            //  b. CFG1
    325            eusart->CFG1 = _EUSART_CFG1_RESETVALUE;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x60E0             STR      R0,[R4, #+12]
    326            //  c. CFG0
    327            eusart->CFG0 = _EUSART_CFG0_RESETVALUE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x60A0             STR      R0,[R4, #+8]
    328            //  d. FRAMECFG, DTXDATCFG, TIMINGCFG (Any sequence)
    329            eusart->FRAMECFG = _EUSART_FRAMECFG_RESETVALUE;
   \       0x32   0xF241 0x0002      MOVW     R0,#+4098
   \       0x36   0x6160             STR      R0,[R4, #+20]
    330          #if defined(EUSART_PRESENT)
    331            eusart->DTXDATCFG = _EUSART_DTXDATCFG_RESETVALUE;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x61A0             STR      R0,[R4, #+24]
    332          #if defined(EUSART_DALICFG_DALIEN)
    333            eusart->DALICFG = _EUSART_DALICFG_RESETVALUE;
    334          #endif /* EUSART_DALICFG_DALIEN */
    335          #endif /* EUSART_PRESENT */
    336            eusart->TIMINGCFG = _EUSART_TIMINGCFG_RESETVALUE;
   \       0x3C   0xF45F 0x20A0      MOVS     R0,#+327680
   \       0x40   0x6260             STR      R0,[R4, #+36]
    337            eusart->IRHFCFG = _EUSART_IRHFCFG_RESETVALUE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x61E0             STR      R0,[R4, #+28]
    338            eusart->IRLFCFG = _EUSART_IRLFCFG_RESETVALUE;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6220             STR      R0,[R4, #+32]
    339            eusart->STARTFRAMECFG = _EUSART_STARTFRAMECFG_RESETVALUE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x62A0             STR      R0,[R4, #+40]
    340            eusart->SIGFRAMECFG = _EUSART_SIGFRAMECFG_RESETVALUE;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x62E0             STR      R0,[R4, #+44]
    341            eusart->TRIGCTRL = _EUSART_TRIGCTRL_RESETVALUE;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x6360             STR      R0,[R4, #+52]
    342            eusart->IEN = _EUSART_IEN_RESETVALUE;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x6520             STR      R0,[R4, #+80]
    343            eusart->IF_CLR = _EUSART_IF_MASK;
   \       0x5A   0x.... 0x....      LDR.W    R2,??DataTable15_4
   \       0x5E   0xF242 0x004C      MOVW     R0,#+8268
   \       0x62   0x5022             STR      R2,[R4, R0]
    344          
    345            // no need to sync while EN=0, multiple writes can be queued up,
    346            // and the last one will synchronize once EN=1
    347            eusart->CLKDIV = _EUSART_CLKDIV_RESETVALUE;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x6320             STR      R0,[R4, #+48]
    348          }
   \       0x68   0xBD10             POP      {R4,PC}
    349          
    350          /***************************************************************************//**
    351           * Enables/disables the EUSART receiver and/or transmitter.
    352           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          void EUSART_Enable(EUSART_TypeDef *eusart, EUSART_Enable_TypeDef enable)
    354          {
   \                     EUSART_Enable: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    355            uint32_t tmp = 0;
   \        0x6   0x2600             MOVS     R6,#+0
    356          
    357            // Make sure that the module exists on the selected chip.
    358            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable13
   \        0xC   0x4284             CMP      R4,R0
   \        0xE   0xD101             BNE.N    ??EUSART_Enable_0
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE00D             B.N      ??EUSART_Enable_1
   \                     ??EUSART_Enable_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD101             BNE.N    ??EUSART_Enable_2
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE007             B.N      ??EUSART_Enable_1
   \                     ??EUSART_Enable_2: (+1)
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD101             BNE.N    ??EUSART_Enable_3
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE001             B.N      ??EUSART_Enable_1
   \                     ??EUSART_Enable_3: (+1)
   \       0x2C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_Enable_1: (+1)
   \       0x30   0xF110 0x0F01      CMN      R0,#+1
   \       0x34   0xD001             BEQ.N    ??EUSART_Enable_4
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE000             B.N      ??EUSART_Enable_5
   \                     ??EUSART_Enable_4: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??EUSART_Enable_5: (+1)
   \       0x3C   0xB2C0             UXTB     R0,R0
    359          
    360            if (enable == eusartDisable) {
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD103             BNE.N    ??EUSART_Enable_6
    361              EUSART_Disable(eusart);
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       EUSART_Disable
   \       0x4C   0xE020             B.N      ??EUSART_Enable_7
    362            } else {
    363              // Enable peripheral to configure Rx and Tx.
    364              eusart->EN_SET = EUSART_EN_EN;
   \                     ??EUSART_Enable_6: (+1)
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0xF241 0x0004      MOVW     R0,#+4100
   \       0x54   0x5021             STR      R1,[R4, R0]
    365          
    366              // Enable or disable Rx and/or Tx
    367              tmp = (enable)
    368                    & (_EUSART_CMD_RXEN_MASK | _EUSART_CMD_TXEN_MASK
    369                       | _EUSART_CMD_RXDIS_MASK | _EUSART_CMD_TXDIS_MASK);
   \       0x56   0x002F             MOVS     R7,R5
   \       0x58   0xB2FF             UXTB     R7,R7
   \       0x5A   0xF017 0x070F      ANDS     R7,R7,#0xF
    370          
    371              eusart_sync(eusart, _EUSART_SYNCBUSY_MASK);
   \       0x5E   0xF640 0x71FF      MOVW     R1,#+4095
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       eusart_sync
    372              eusart->CMD = tmp;
   \       0x68   0x63A7             STR      R7,[R4, #+56]
    373              eusart_sync(eusart,
    374                          EUSART_SYNCBUSY_RXEN | EUSART_SYNCBUSY_TXEN
    375                          | EUSART_SYNCBUSY_RXDIS | EUSART_SYNCBUSY_TXDIS);
   \       0x6A   0x2178             MOVS     R1,#+120
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       eusart_sync
    376          
    377              // Wait for the status register to be updated.
    378              tmp = 0;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x0006             MOVS     R6,R0
    379              if (_EUSART_CMD_RXEN_MASK & enable) {
   \       0x76   0x07E8             LSLS     R0,R5,#+31
   \       0x78   0xD501             BPL.N    ??EUSART_Enable_8
    380                tmp |= EUSART_STATUS_RXENS;
   \       0x7A   0xF056 0x0601      ORRS     R6,R6,#0x1
    381              }
    382              if (_EUSART_CMD_TXEN_MASK & enable) {
   \                     ??EUSART_Enable_8: (+1)
   \       0x7E   0x0768             LSLS     R0,R5,#+29
   \       0x80   0xD501             BPL.N    ??EUSART_Enable_9
    383                tmp |= EUSART_STATUS_TXENS;
   \       0x82   0xF056 0x0602      ORRS     R6,R6,#0x2
    384              }
    385              while ((eusart->STATUS & (_EUSART_STATUS_TXENS_MASK | _EUSART_STATUS_RXENS_MASK)) != tmp) {
   \                     ??EUSART_Enable_9: (+1)
   \       0x86   0x6CA0             LDR      R0,[R4, #+72]
   \       0x88   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x8C   0x42B0             CMP      R0,R6
   \       0x8E   0xD1FA             BNE.N    ??EUSART_Enable_9
    386              }
    387            }
    388          }
   \                     ??EUSART_Enable_7: (+1)
   \       0x90   0xBDF1             POP      {R0,R4-R7,PC}
    389          
    390          /***************************************************************************//**
    391           * Receives one 8 bit frame, (or part of 9 bit frame).
    392           *
    393           * @note (1) Handles the case where the RX Fifo Watermark has been set to N frames,
    394           *       and when N is greater than one. Attempt to read a frame from the RX Fifo.
    395           *       If the read is unsuccessful (i.e. no frames in the RX fifo), the RXFU
    396           *       interrupt flag is set. If the flag is set, wait to read again until the RXFL
    397           *       status flag is set, indicating there are N frames in the RX Fifo, where N
    398           *       is equal to the RX watermark level. Once there are N frames in the Fifo,
    399           *       read and return one frame. For consecutive N-1 reads there will be data available
    400           *       in the Fifo. Therefore, the RXUF interrupt will not be triggered eliminating
    401           *       delays between reads and sending N data frames in "bursts".
    402           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    403          uint8_t EUSART_Rx(EUSART_TypeDef *eusart)
    404          {
   \                     EUSART_Rx: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    405            // If RX watermark has not been configured.
    406            if ((eusart->CFG1 & _EUSART_CFG1_RXFIW_MASK) == EUSART_CFG1_RXFIW_DEFAULT) {
   \        0x2   0x68C8             LDR      R0,[R1, #+12]
   \        0x4   0xF010 0x4FF0      TST      R0,#0x78000000
   \        0x8   0xD105             BNE.N    ??EUSART_Rx_0
    407              while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     ??EUSART_Rx_1: (+1)
   \        0xA   0x6C88             LDR      R0,[R1, #+72]
   \        0xC   0x0600             LSLS     R0,R0,#+24
   \        0xE   0xD5FC             BPL.N    ??EUSART_Rx_1
    408              } // Wait for incoming data.
    409              return (uint8_t)eusart->RXDATA;
   \       0x10   0x6BC8             LDR      R0,[R1, #+60]
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0xE009             B.N      ??EUSART_Rx_2
    410            }
    411          
    412            // See Note #1.
    413            uint8_t rx_data = eusart->RXDATA;
   \                     ??EUSART_Rx_0: (+1)
   \       0x16   0x6BC8             LDR      R0,[R1, #+60]
    414            // If there is underflow i.e Rx data read was unsuccessful
    415            if (eusart->IF & EUSART_IF_RXUF) {
   \       0x18   0x6CCA             LDR      R2,[R1, #+76]
   \       0x1A   0x0692             LSLS     R2,R2,#+26
   \       0x1C   0xD504             BPL.N    ??EUSART_Rx_3
    416              // Wait until data becomes available in Rx fifo
    417              while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     ??EUSART_Rx_4: (+1)
   \       0x1E   0x6C8A             LDR      R2,[R1, #+72]
   \       0x20   0x0612             LSLS     R2,R2,#+24
   \       0x22   0xD5FC             BPL.N    ??EUSART_Rx_4
    418              }
    419              // Read Rx data again once data is available in the fifo
    420              rx_data = eusart->RXDATA;
   \       0x24   0x6BCA             LDR      R2,[R1, #+60]
   \       0x26   0x0010             MOVS     R0,R2
    421            }
    422          
    423            return rx_data;
   \                     ??EUSART_Rx_3: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \                     ??EUSART_Rx_2: (+1)
   \       0x2A   0x4770             BX       LR
    424          }
    425          
    426          /***************************************************************************//**
    427           * Receives one 8-9 bit frame with extended information.
    428           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    429          uint16_t EUSART_RxExt(EUSART_TypeDef *eusart)
    430          {
    431            while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     EUSART_RxExt: (+1)
   \                     ??EUSART_RxExt_0: (+1)
   \        0x0   0x6C81             LDR      R1,[R0, #+72]
   \        0x2   0x0609             LSLS     R1,R1,#+24
   \        0x4   0xD5FC             BPL.N    ??EUSART_RxExt_0
    432            } // Wait for incoming data.
    433          
    434            return (uint16_t)eusart->RXDATA;
   \        0x6   0x6BC0             LDR      R0,[R0, #+60]
   \        0x8   0xB280             UXTH     R0,R0
   \        0xA   0x4770             BX       LR
    435          }
    436          
    437          /***************************************************************************//**
    438           * Transmits one frame.
    439           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          void EUSART_Tx(EUSART_TypeDef *eusart, uint8_t data)
    441          {
    442            // Check that transmit FIFO is not full.
    443            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
   \                     EUSART_Tx: (+1)
   \                     ??EUSART_Tx_0: (+1)
   \        0x0   0x6C82             LDR      R2,[R0, #+72]
   \        0x2   0x0652             LSLS     R2,R2,#+25
   \        0x4   0xD5FC             BPL.N    ??EUSART_Tx_0
    444            }
    445          
    446            eusart->TXDATA = (uint32_t)data;
   \        0x6   0x000A             MOVS     R2,R1
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0x6442             STR      R2,[R0, #+68]
    447          }
   \        0xC   0x4770             BX       LR
    448          
    449          /***************************************************************************//**
    450           * Transmits one 8-9 bit frame with extended control.
    451           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    452          void EUSART_TxExt(EUSART_TypeDef *eusart, uint16_t data)
    453          {
    454            // Check that transmit FIFO is not full.
    455            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
   \                     EUSART_TxExt: (+1)
   \                     ??EUSART_TxExt_0: (+1)
   \        0x0   0x6C82             LDR      R2,[R0, #+72]
   \        0x2   0x0652             LSLS     R2,R2,#+25
   \        0x4   0xD5FC             BPL.N    ??EUSART_TxExt_0
    456            }
    457          
    458            eusart->TXDATA = (uint32_t)data;
   \        0x6   0x000A             MOVS     R2,R1
   \        0x8   0xB292             UXTH     R2,R2
   \        0xA   0x6442             STR      R2,[R0, #+68]
    459          }
   \        0xC   0x4770             BX       LR
    460          
    461          #if defined(EUSART_PRESENT)
    462          /***************************************************************************//**
    463           * Transmits one 8-16 bit frame and return received data.
    464           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    465          uint16_t EUSART_Spi_TxRx(EUSART_TypeDef *eusart, uint16_t data)
    466          {
    467            // Check that transmit FIFO is not full.
    468            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
   \                     EUSART_Spi_TxRx: (+1)
   \                     ??EUSART_Spi_TxRx_0: (+1)
   \        0x0   0x6C82             LDR      R2,[R0, #+72]
   \        0x2   0x0652             LSLS     R2,R2,#+25
   \        0x4   0xD5FC             BPL.N    ??EUSART_Spi_TxRx_0
    469            }
    470            eusart->TXDATA = (uint32_t)data;
   \        0x6   0x000A             MOVS     R2,R1
   \        0x8   0xB292             UXTH     R2,R2
   \        0xA   0x6442             STR      R2,[R0, #+68]
    471          
    472            // Wait for Rx data to be available.
    473            while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     ??EUSART_Spi_TxRx_1: (+1)
   \        0xC   0x6C82             LDR      R2,[R0, #+72]
   \        0xE   0x0612             LSLS     R2,R2,#+24
   \       0x10   0xD5FC             BPL.N    ??EUSART_Spi_TxRx_1
    474            }
    475            return (uint16_t)eusart->RXDATA;
   \       0x12   0x6BC0             LDR      R0,[R0, #+60]
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x4770             BX       LR
    476          }
    477          
    478          #if defined(EUSART_DALICFG_DALIEN)
    479          /***************************************************************************//**
    480           * Transmits one frame.
    481           ******************************************************************************/
    482          void EUSART_Dali_Tx(EUSART_TypeDef *eusart, uint32_t data)
    483          {
    484            uint32_t packet;
    485          
    486            // Make sure the module exists on the selected chip.
    487            EFM_ASSERT(EUSART_REF_VALID(eusart));
    488          
    489            // Check that transmit FIFO is not full.
    490            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
    491            }
    492          
    493            for (uint8_t index = 0; index < dali_tx_nb_packets[EUSART_NUM(eusart)]; index++) {
    494              // when DALICFG.DALIEN is set to 1, then all 16 bits [15:0] represent data
    495              // First write to TXDATA register should contain 16 LSBs of the TX frame.
    496              // Transmission will not start after this first write.
    497              // Second write to TXDATA register should contain the remaining TX frame bits.
    498              // This second write will result in start of transmission.
    499              packet = (data >> (index * 16));
    500              // To ensure compatibility with future devices, always write bits [31:16] to 0.
    501              packet &= 0x0000FFFF;
    502              eusart->TXDATA = packet;
    503            }
    504          }
    505          
    506          /***************************************************************************//**
    507           * Receive one frame.
    508           ******************************************************************************/
    509          uint32_t EUSART_Dali_Rx(EUSART_TypeDef *eusart)
    510          {
    511            uint32_t data = 0;
    512          
    513            // Make sure the module exists on the selected chip.
    514            EFM_ASSERT(EUSART_REF_VALID(eusart));
    515          
    516            while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
    517            }   // Wait for incoming data.
    518          
    519            for (uint8_t index = 0; index < dali_rx_nb_packets[EUSART_NUM(eusart)]; index++) {
    520              // when DALICFG.DALIEN is set to 1, then all 16 bits [15:0] represent data
    521              // When receiving a frame that has more than 16 databits,
    522              // RXDATA register needs to be read twice:
    523              //    First read will provide 16 LSBs of the received frame.
    524              //    Second read will provide the remaining RX frame bits.
    525              data |= ((eusart->RXDATA & _EUSART_RXDATA_RXDATA_MASK) << (index * 16));
    526            }
    527            return data;
    528          }
    529          
    530          #endif /* EUSART_DALICFG_DALIEN */
    531          #endif /* EUSART_PRESENT */
    532          
    533          /***************************************************************************//**
    534           * Configures the baudrate (or as close as possible to a specified baudrate)
    535           * depending on the current mode of the EU(S)ART peripheral.
    536           *
    537           * @note (1) When the oversampling is disabled, the peripheral clock frequency
    538           *           must be at least three times higher than the chosen baud rate.
    539           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    540          void EUSART_BaudrateSet(EUSART_TypeDef *eusart,
    541                                  uint32_t refFreq,
    542                                  uint32_t baudrate)
    543          {
   \                     EUSART_BaudrateSet: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
    544            uint32_t          clkdiv;
    545            uint8_t           oversample = 0;
   \        0xA   0x2700             MOVS     R7,#+0
    546          
    547            // Prevent dividing by 0.
    548            EFM_ASSERT(baudrate);
    549          
    550            // Make sure the module exists on the selected chip.
    551            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x10   0x4582             CMP      R10,R0
   \       0x12   0xD101             BNE.N    ??EUSART_BaudrateSet_0
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE00D             B.N      ??EUSART_BaudrateSet_1
   \                     ??EUSART_BaudrateSet_0: (+1)
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x1C   0x4582             CMP      R10,R0
   \       0x1E   0xD101             BNE.N    ??EUSART_BaudrateSet_2
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE007             B.N      ??EUSART_BaudrateSet_1
   \                     ??EUSART_BaudrateSet_2: (+1)
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x28   0x4582             CMP      R10,R0
   \       0x2A   0xD101             BNE.N    ??EUSART_BaudrateSet_3
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xE001             B.N      ??EUSART_BaudrateSet_1
   \                     ??EUSART_BaudrateSet_3: (+1)
   \       0x30   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_BaudrateSet_1: (+1)
   \       0x34   0xF110 0x0F01      CMN      R0,#+1
   \       0x38   0xD001             BEQ.N    ??EUSART_BaudrateSet_4
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE000             B.N      ??EUSART_BaudrateSet_5
   \                     ??EUSART_BaudrateSet_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_5: (+1)
   \       0x40   0xB2C0             UXTB     R0,R0
    552          
    553            // Get the current frequency.
    554            if (!refFreq) {
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD105             BNE.N    ??EUSART_BaudrateSet_6
    555              refFreq = CMU_ClockFreqGet(EUSART_ClockGet(eusart));
   \       0x46   0x4650             MOV      R0,R10
   \       0x48   0x.... 0x....      BL       EUSART_ClockGet
   \       0x4C   0x.... 0x....      BL       CMU_ClockFreqGet
   \       0x50   0x0004             MOVS     R4,R0
    556            }
    557          
    558          #if defined(EUSART_PRESENT)
    559            // In synchronous mode (ex: SPI)
    560            if (eusart->CFG0 & _EUSART_CFG0_SYNC_MASK ) {
   \                     ??EUSART_BaudrateSet_6: (+1)
   \       0x52   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \       0x56   0x07C0             LSLS     R0,R0,#+31
   \       0x58   0xD547             BPL.N    ??EUSART_BaudrateSet_7
    561              EFM_ASSERT(baudrate <= refFreq);
   \       0x5A   0x42AC             CMP      R4,R5
   \       0x5C   0xD301             BCC.N    ??EUSART_BaudrateSet_8
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xE000             B.N      ??EUSART_BaudrateSet_9
   \                     ??EUSART_BaudrateSet_8: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_9: (+1)
   \       0x64   0xB2C0             UXTB     R0,R0
    562          
    563              EUSART_Enable_TypeDef txrxEnStatus = eusartDisable;
   \       0x66   0xF05F 0x0800      MOVS     R8,#+0
    564              bool wasEnabled = (eusart->EN & _EUSART_EN_EN_MASK) == true;
   \       0x6A   0xF8DA 0x9004      LDR      R9,[R10, #+4]
   \       0x6E   0xF019 0x0901      ANDS     R9,R9,#0x1
    565              clkdiv = refFreq / baudrate - 1UL;
   \       0x72   0xFBB4 0xF0F5      UDIV     R0,R4,R5
   \       0x76   0x1E40             SUBS     R0,R0,#+1
   \       0x78   0x0006             MOVS     R6,R0
    566          
    567              // If the desired bit rate requires a divider larger than the Synchronous divider bitfield (CFG2_SDIV),
    568              // the resulting spi master bus clock will be undefined because the result will be truncated.
    569              EFM_ASSERT(clkdiv <= (_EUSART_CFG2_SDIV_MASK >> _EUSART_CFG2_SDIV_SHIFT));
   \       0x7A   0xF5B6 0x7F80      CMP      R6,#+256
   \       0x7E   0xD201             BCS.N    ??EUSART_BaudrateSet_10
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE000             B.N      ??EUSART_BaudrateSet_11
   \                     ??EUSART_BaudrateSet_10: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_11: (+1)
   \       0x86   0xB2C0             UXTB     R0,R0
    570          
    571              if (wasEnabled) {
   \       0x88   0x4648             MOV      R0,R9
   \       0x8A   0xB2C0             UXTB     R0,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD01C             BEQ.N    ??EUSART_BaudrateSet_12
    572                eusart_sync(eusart, _EUSART_SYNCBUSY_RXEN_MASK | _EUSART_SYNCBUSY_TXEN_MASK);
   \       0x90   0x2128             MOVS     R1,#+40
   \       0x92   0x4650             MOV      R0,R10
   \       0x94   0x.... 0x....      BL       eusart_sync
    573          
    574                // Save the state of the reveiver and transmitter before disabling the peripheral.
    575                if (eusart->STATUS & (_EUSART_STATUS_RXENS_MASK | _EUSART_STATUS_TXENS_MASK)) {
   \       0x98   0xF8DA 0x0048      LDR      R0,[R10, #+72]
   \       0x9C   0xF010 0x0F03      TST      R0,#0x3
   \       0xA0   0xD002             BEQ.N    ??EUSART_BaudrateSet_13
    576                  txrxEnStatus = eusartEnable;
   \       0xA2   0x2005             MOVS     R0,#+5
   \       0xA4   0x4680             MOV      R8,R0
   \       0xA6   0xE00D             B.N      ??EUSART_BaudrateSet_14
    577                } else if (eusart->STATUS & (_EUSART_STATUS_RXENS_MASK)) {
   \                     ??EUSART_BaudrateSet_13: (+1)
   \       0xA8   0xF8DA 0x0048      LDR      R0,[R10, #+72]
   \       0xAC   0x07C0             LSLS     R0,R0,#+31
   \       0xAE   0xD502             BPL.N    ??EUSART_BaudrateSet_15
    578                  txrxEnStatus = eusartEnableRx;
   \       0xB0   0x2009             MOVS     R0,#+9
   \       0xB2   0x4680             MOV      R8,R0
   \       0xB4   0xE006             B.N      ??EUSART_BaudrateSet_14
    579                } else if (eusart->STATUS & (_EUSART_STATUS_TXENS_MASK)) {
   \                     ??EUSART_BaudrateSet_15: (+1)
   \       0xB6   0xF8DA 0x0048      LDR      R0,[R10, #+72]
   \       0xBA   0x0780             LSLS     R0,R0,#+30
   \       0xBC   0xD502             BPL.N    ??EUSART_BaudrateSet_16
    580                  txrxEnStatus = eusartEnableTx;
   \       0xBE   0x2006             MOVS     R0,#+6
   \       0xC0   0x4680             MOV      R8,R0
   \       0xC2   0xE7FF             B.N      ??EUSART_BaudrateSet_14
    581                } else {
    582                  EFM_ASSERT(false);
    583                }
    584          
    585                // Disable the eusart to be able to modify the CFG2 register.
    586                EUSART_Disable(eusart);
   \                     ??EUSART_BaudrateSet_16: (+1)
   \                     ??EUSART_BaudrateSet_14: (+1)
   \       0xC4   0x4650             MOV      R0,R10
   \       0xC6   0x.... 0x....      BL       EUSART_Disable
    587              }
    588          
    589              // In Synchronous mode the clock divider that is managing the bitRate
    590              // is located inside the sdiv bitfield of the CFG2 register instead of
    591              // the CLKDIV register combined with the oversample setting for asynchronous mode.
    592              eusart->CFG2 = (eusart->CFG2 & ~(_EUSART_CFG2_SDIV_MASK)) | ((clkdiv << _EUSART_CFG2_SDIV_SHIFT) & _EUSART_CFG2_SDIV_MASK);
   \                     ??EUSART_BaudrateSet_12: (+1)
   \       0xCA   0xF8DA 0x0010      LDR      R0,[R10, #+16]
   \       0xCE   0xF366 0x601F      BFI      R0,R6,#+24,#+8
   \       0xD2   0xF8CA 0x0010      STR      R0,[R10, #+16]
    593          
    594              if (wasEnabled) {
   \       0xD6   0x4648             MOV      R0,R9
   \       0xD8   0xB2C0             UXTB     R0,R0
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD077             BEQ.N    ??EUSART_BaudrateSet_17
    595                EUSART_Enable(eusart, txrxEnStatus);
   \       0xDE   0x4641             MOV      R1,R8
   \       0xE0   0xB2C9             UXTB     R1,R1
   \       0xE2   0x4650             MOV      R0,R10
   \       0xE4   0x.... 0x....      BL       EUSART_Enable
   \       0xE8   0xE071             B.N      ??EUSART_BaudrateSet_17
    596              }
    597            } else // In asynchronous mode (ex: UART)
    598          #endif
    599            {
    600              // The peripheral must be enabled to configure the baud rate.
    601              EFM_ASSERT(eusart->EN == EUSART_EN_EN);
   \                     ??EUSART_BaudrateSet_7: (+1)
   \       0xEA   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0xEE   0x2801             CMP      R0,#+1
   \       0xF0   0xD101             BNE.N    ??EUSART_BaudrateSet_18
   \       0xF2   0x2001             MOVS     R0,#+1
   \       0xF4   0xE000             B.N      ??EUSART_BaudrateSet_19
   \                     ??EUSART_BaudrateSet_18: (+1)
   \       0xF6   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_19: (+1)
   \       0xF8   0xB2C0             UXTB     R0,R0
    602          
    603          #if defined(EUSART_DALICFG_DALIEN)
    604              if (eusart->DALICFG & EUSART_DALICFG_DALIEN) {
    605                // adjust for manchester double-clocking scheme
    606                baudrate *= 2;
    607              }
    608          #endif
    609          
    610              /*
    611               * Use integer division to avoid forcing in float division
    612               * utils, and yet keep rounding effect errors to a minimum.
    613               *
    614               * CLKDIV is given by:
    615               *
    616               * CLKDIV = 256 * (fUARTn/(oversample * br) - 1)
    617               * or
    618               * CLKDIV = (256 * fUARTn)/(oversample * br) - 256
    619               *
    620               * Since fUARTn may be derived from HFCORECLK, consider the overflow when
    621               * using integer arithmetic.
    622               *
    623               * The basic problem with integer division in the above formula is that
    624               * the dividend (256 * fUARTn) may become higher than the maximum 32 bit
    625               * integer. Yet, the dividend should be evaluated first before dividing
    626               * to get as small rounding effects as possible.
    627               * Also, harsh restrictions on the maximum fUARTn value should not be made.
    628               *
    629               * Since the last 3 bits of CLKDIV are don't care, base the
    630               * integer arithmetic on the below formula:
    631               *
    632               * CLKDIV/8 = ((32*fUARTn)/(br * Oversample)) - 32
    633               *
    634               * and calculate 1/8 of CLKDIV first. This allows for fUARTn
    635               * up to 128 MHz without overflowing a 32 bit value.
    636               */
    637          
    638              // Map oversampling.
    639              switch (eusart->CFG0 & _EUSART_CFG0_OVS_MASK) {
   \       0xFA   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \       0xFE   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD008             BEQ.N    ??EUSART_BaudrateSet_20
   \      0x106   0x2820             CMP      R0,#+32
   \      0x108   0xD011             BEQ.N    ??EUSART_BaudrateSet_21
   \      0x10A   0x2840             CMP      R0,#+64
   \      0x10C   0xD01A             BEQ.N    ??EUSART_BaudrateSet_22
   \      0x10E   0x2860             CMP      R0,#+96
   \      0x110   0xD024             BEQ.N    ??EUSART_BaudrateSet_23
   \      0x112   0x2880             CMP      R0,#+128
   \      0x114   0xD02D             BEQ.N    ??EUSART_BaudrateSet_24
   \      0x116   0xE038             B.N      ??EUSART_BaudrateSet_25
    640                case eusartOVS16:
    641                  EFM_ASSERT(baudrate <= (refFreq / 16));
   \                     ??EUSART_BaudrateSet_20: (+1)
   \      0x118   0x0020             MOVS     R0,R4
   \      0x11A   0x0900             LSRS     R0,R0,#+4
   \      0x11C   0x42A8             CMP      R0,R5
   \      0x11E   0xD301             BCC.N    ??EUSART_BaudrateSet_26
   \      0x120   0x2001             MOVS     R0,#+1
   \      0x122   0xE000             B.N      ??EUSART_BaudrateSet_27
   \                     ??EUSART_BaudrateSet_26: (+1)
   \      0x124   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_27: (+1)
   \      0x126   0xB2C0             UXTB     R0,R0
    642                  oversample = 16;
   \      0x128   0x2010             MOVS     R0,#+16
   \      0x12A   0x0007             MOVS     R7,R0
    643                  break;
   \      0x12C   0xE02D             B.N      ??EUSART_BaudrateSet_28
    644          
    645                case eusartOVS8:
    646                  EFM_ASSERT(baudrate <= (refFreq / 8));
   \                     ??EUSART_BaudrateSet_21: (+1)
   \      0x12E   0x0020             MOVS     R0,R4
   \      0x130   0x08C0             LSRS     R0,R0,#+3
   \      0x132   0x42A8             CMP      R0,R5
   \      0x134   0xD301             BCC.N    ??EUSART_BaudrateSet_29
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xE000             B.N      ??EUSART_BaudrateSet_30
   \                     ??EUSART_BaudrateSet_29: (+1)
   \      0x13A   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_30: (+1)
   \      0x13C   0xB2C0             UXTB     R0,R0
    647                  oversample = 8;
   \      0x13E   0x2008             MOVS     R0,#+8
   \      0x140   0x0007             MOVS     R7,R0
    648                  break;
   \      0x142   0xE022             B.N      ??EUSART_BaudrateSet_28
    649          
    650                case eusartOVS6:
    651                  EFM_ASSERT(baudrate <= (refFreq / 6));
   \                     ??EUSART_BaudrateSet_22: (+1)
   \      0x144   0x2006             MOVS     R0,#+6
   \      0x146   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \      0x14A   0x42A8             CMP      R0,R5
   \      0x14C   0xD301             BCC.N    ??EUSART_BaudrateSet_31
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0xE000             B.N      ??EUSART_BaudrateSet_32
   \                     ??EUSART_BaudrateSet_31: (+1)
   \      0x152   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_32: (+1)
   \      0x154   0xB2C0             UXTB     R0,R0
    652                  oversample = 6;
   \      0x156   0x2006             MOVS     R0,#+6
   \      0x158   0x0007             MOVS     R7,R0
    653                  break;
   \      0x15A   0xE016             B.N      ??EUSART_BaudrateSet_28
    654          
    655                case eusartOVS4:
    656                  EFM_ASSERT(baudrate <= (refFreq / 4));
   \                     ??EUSART_BaudrateSet_23: (+1)
   \      0x15C   0x0020             MOVS     R0,R4
   \      0x15E   0x0880             LSRS     R0,R0,#+2
   \      0x160   0x42A8             CMP      R0,R5
   \      0x162   0xD301             BCC.N    ??EUSART_BaudrateSet_33
   \      0x164   0x2001             MOVS     R0,#+1
   \      0x166   0xE000             B.N      ??EUSART_BaudrateSet_34
   \                     ??EUSART_BaudrateSet_33: (+1)
   \      0x168   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_34: (+1)
   \      0x16A   0xB2C0             UXTB     R0,R0
    657                  oversample = 4;
   \      0x16C   0x2004             MOVS     R0,#+4
   \      0x16E   0x0007             MOVS     R7,R0
    658                  break;
   \      0x170   0xE00B             B.N      ??EUSART_BaudrateSet_28
    659          
    660                case eusartOVS0:
    661                  EFM_ASSERT(refFreq >= (3 * baudrate)); // See Note #1.
   \                     ??EUSART_BaudrateSet_24: (+1)
   \      0x172   0x2003             MOVS     R0,#+3
   \      0x174   0xFB00 0xF005      MUL      R0,R0,R5
   \      0x178   0x4284             CMP      R4,R0
   \      0x17A   0xD301             BCC.N    ??EUSART_BaudrateSet_35
   \      0x17C   0x2001             MOVS     R0,#+1
   \      0x17E   0xE000             B.N      ??EUSART_BaudrateSet_36
   \                     ??EUSART_BaudrateSet_35: (+1)
   \      0x180   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateSet_36: (+1)
   \      0x182   0xB2C0             UXTB     R0,R0
    662                  oversample = 1;
   \      0x184   0x2001             MOVS     R0,#+1
   \      0x186   0x0007             MOVS     R7,R0
    663                  break;
   \      0x188   0xE7FF             B.N      ??EUSART_BaudrateSet_28
    664          
    665                default:
    666                  // Invalid input
    667                  EFM_ASSERT(0);
    668                  break;
    669              }
    670          
    671              if (oversample > 0U) {
   \                     ??EUSART_BaudrateSet_25: (+1)
   \                     ??EUSART_BaudrateSet_28: (+1)
   \      0x18A   0x0038             MOVS     R0,R7
   \      0x18C   0xB2C0             UXTB     R0,R0
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD01D             BEQ.N    ??EUSART_BaudrateSet_17
    672                // Calculate and set the CLKDIV with fractional bits.
    673                clkdiv  = (32 * refFreq) / (baudrate * oversample);
   \      0x192   0x0161             LSLS     R1,R4,#+5
   \      0x194   0x0038             MOVS     R0,R7
   \      0x196   0xB2C0             UXTB     R0,R0
   \      0x198   0xFB00 0xF005      MUL      R0,R0,R5
   \      0x19C   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    674                clkdiv -= 32;
   \      0x1A0   0x3820             SUBS     R0,R0,#+32
    675                clkdiv *= 8;
   \      0x1A2   0x00C0             LSLS     R0,R0,#+3
    676          
    677                // Verify that the resulting clock divider is within limits.
    678                EFM_ASSERT(clkdiv <= _EUSART_CLKDIV_MASK);
   \      0x1A4   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \      0x1A8   0x4288             CMP      R0,R1
   \      0x1AA   0xD201             BCS.N    ??EUSART_BaudrateSet_37
   \      0x1AC   0x2101             MOVS     R1,#+1
   \      0x1AE   0xE000             B.N      ??EUSART_BaudrateSet_38
   \                     ??EUSART_BaudrateSet_37: (+1)
   \      0x1B0   0x2100             MOVS     R1,#+0
   \                     ??EUSART_BaudrateSet_38: (+1)
   \      0x1B2   0xB2C9             UXTB     R1,R1
    679          
    680                // If the EFM_ASSERT is not enabled, make sure not to write to reserved bits.
    681                clkdiv &= _EUSART_CLKDIV_MASK;
   \      0x1B4   0x.... 0x....      LDR.W    R6,??DataTable15_6
   \      0x1B8   0x4006             ANDS     R6,R6,R0
    682          
    683                eusart_sync(eusart, _EUSART_SYNCBUSY_DIV_MASK);
   \      0x1BA   0x2101             MOVS     R1,#+1
   \      0x1BC   0x4650             MOV      R0,R10
   \      0x1BE   0x.... 0x....      BL       eusart_sync
    684                eusart->CLKDIV = clkdiv;
   \      0x1C2   0xF8CA 0x6030      STR      R6,[R10, #+48]
    685                eusart_sync(eusart, _EUSART_SYNCBUSY_DIV_MASK);
   \      0x1C6   0x2101             MOVS     R1,#+1
   \      0x1C8   0x4650             MOV      R0,R10
   \      0x1CA   0x.... 0x....      BL       eusart_sync
    686              }
    687            }
    688          }
   \                     ??EUSART_BaudrateSet_17: (+1)
   \      0x1CE   0xE8BD 0x87F0      POP      {R4-R10,PC}
    689          
    690          /***************************************************************************//**
    691           * Gets the current baudrate.
    692           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    693          uint32_t EUSART_BaudrateGet(EUSART_TypeDef *eusart)
    694          {
   \                     EUSART_BaudrateGet: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    695            uint32_t freq;
    696            uint32_t div = 1;
   \        0x6   0x2501             MOVS     R5,#+1
    697            uint32_t br = 0;
   \        0x8   0x2600             MOVS     R6,#+0
    698            EUSART_OVS_TypeDef ovs = eusartOVS0;
   \        0xA   0x2780             MOVS     R7,#+128
    699          
    700            // Make sure the module exists on the selected chip.
    701            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD101             BNE.N    ??EUSART_BaudrateGet_0
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE00D             B.N      ??EUSART_BaudrateGet_1
   \                     ??EUSART_BaudrateGet_0: (+1)
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x1C   0x4284             CMP      R4,R0
   \       0x1E   0xD101             BNE.N    ??EUSART_BaudrateGet_2
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE007             B.N      ??EUSART_BaudrateGet_1
   \                     ??EUSART_BaudrateGet_2: (+1)
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x28   0x4284             CMP      R4,R0
   \       0x2A   0xD101             BNE.N    ??EUSART_BaudrateGet_3
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xE001             B.N      ??EUSART_BaudrateGet_1
   \                     ??EUSART_BaudrateGet_3: (+1)
   \       0x30   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_BaudrateGet_1: (+1)
   \       0x34   0xF110 0x0F01      CMN      R0,#+1
   \       0x38   0xD001             BEQ.N    ??EUSART_BaudrateGet_4
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE000             B.N      ??EUSART_BaudrateGet_5
   \                     ??EUSART_BaudrateGet_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??EUSART_BaudrateGet_5: (+1)
   \       0x40   0xB2C0             UXTB     R0,R0
    702          
    703            freq = CMU_ClockFreqGet(EUSART_ClockGet(eusart));
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       EUSART_ClockGet
   \       0x48   0x.... 0x....      BL       CMU_ClockFreqGet
   \       0x4C   0x4680             MOV      R8,R0
    704          
    705          #if defined(EUSART_PRESENT)
    706            // In synchronous mode (ex: SPI)
    707            if (eusart->CFG0 & _EUSART_CFG0_SYNC_MASK) {
   \       0x4E   0x68A0             LDR      R0,[R4, #+8]
   \       0x50   0x07C0             LSLS     R0,R0,#+31
   \       0x52   0xD508             BPL.N    ??EUSART_BaudrateGet_6
    708              div = (eusart->CFG2 & _EUSART_CFG2_SDIV_MASK) >> _EUSART_CFG2_SDIV_SHIFT;
   \       0x54   0xF8D4 0x9010      LDR      R9,[R4, #+16]
   \       0x58   0xEA5F 0x6919      LSRS     R9,R9,#+24
    709              br = freq / (div + 1);
   \       0x5C   0xF119 0x0001      ADDS     R0,R9,#+1
   \       0x60   0xFBB8 0xF0F0      UDIV     R0,R8,R0
   \       0x64   0xE00B             B.N      ??EUSART_BaudrateGet_7
    710            }
    711            // In asynchronous mode (ex: UART)
    712            else
    713          #endif
    714            {
    715              div = eusart->CLKDIV;
   \                     ??EUSART_BaudrateGet_6: (+1)
   \       0x66   0xF8D4 0x9030      LDR      R9,[R4, #+48]
    716              ovs = (EUSART_OVS_TypeDef)(eusart->CFG0 & _EUSART_CFG0_OVS_MASK);
   \       0x6A   0x68A0             LDR      R0,[R4, #+8]
   \       0x6C   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \       0x70   0x0007             MOVS     R7,R0
    717              br = EUSART_AsyncBaudrateCalc(freq, div, ovs);
   \       0x72   0x003A             MOVS     R2,R7
   \       0x74   0xB2D2             UXTB     R2,R2
   \       0x76   0x4649             MOV      R1,R9
   \       0x78   0x4640             MOV      R0,R8
   \       0x7A   0x.... 0x....      BL       EUSART_AsyncBaudrateCalc
    718          
    719          #if defined(EUSART_DALICFG_DALIEN)
    720              if (eusart->DALICFG & EUSART_DALICFG_DALIEN) {
    721                // adjust for manchester double-clocking scheme
    722                br /= 2;
    723              }
    724          #endif
    725            }
    726          
    727            return br;
   \                     ??EUSART_BaudrateGet_7: (+1)
   \       0x7E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    728          }
    729          
    730          /***************************************************************************//**
    731           * Enable/Disable reception operations until the configured start frame is
    732           * received.
    733           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    734          void EUSART_RxBlock(EUSART_TypeDef *eusart, EUSART_BlockRx_TypeDef enable)
    735          {
   \                     EUSART_RxBlock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    736            uint32_t tmp;
    737          
    738            // Make sure that the module exists on the selected chip.
    739            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable13
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD101             BNE.N    ??EUSART_RxBlock_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE00D             B.N      ??EUSART_RxBlock_1
   \                     ??EUSART_RxBlock_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD101             BNE.N    ??EUSART_RxBlock_2
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE007             B.N      ??EUSART_RxBlock_1
   \                     ??EUSART_RxBlock_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD101             BNE.N    ??EUSART_RxBlock_3
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE001             B.N      ??EUSART_RxBlock_1
   \                     ??EUSART_RxBlock_3: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_RxBlock_1: (+1)
   \       0x2E   0xF110 0x0F01      CMN      R0,#+1
   \       0x32   0xD001             BEQ.N    ??EUSART_RxBlock_4
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??EUSART_RxBlock_5
   \                     ??EUSART_RxBlock_4: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??EUSART_RxBlock_5: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0
    740          
    741            tmp   = ((uint32_t)(enable));
   \       0x3C   0x002E             MOVS     R6,R5
   \       0x3E   0xB2F6             UXTB     R6,R6
    742            tmp  &= (_EUSART_CMD_RXBLOCKEN_MASK | _EUSART_CMD_RXBLOCKDIS_MASK);
   \       0x40   0xF016 0x0630      ANDS     R6,R6,#0x30
    743          
    744            eusart_sync(eusart, EUSART_SYNCBUSY_RXBLOCKEN | EUSART_SYNCBUSY_RXBLOCKDIS);
   \       0x44   0xF44F 0x71C0      MOV      R1,#+384
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       eusart_sync
    745            eusart->CMD_SET = tmp;
   \       0x4E   0xF241 0x0038      MOVW     R0,#+4152
   \       0x52   0x5026             STR      R6,[R4, R0]
    746            eusart_sync(eusart, EUSART_SYNCBUSY_RXBLOCKEN | EUSART_SYNCBUSY_RXBLOCKDIS);
   \       0x54   0xF44F 0x71C0      MOV      R1,#+384
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       eusart_sync
    747          
    748            tmp = 0u;
   \       0x5E   0x2000             MOVS     R0,#+0
    749            if ((_EUSART_CMD_RXBLOCKEN_MASK & enable) != 0u) {
   \       0x60   0x06E9             LSLS     R1,R5,#+27
   \       0x62   0xD501             BPL.N    ??EUSART_RxBlock_6
    750              tmp |= EUSART_STATUS_RXBLOCK;
   \       0x64   0xF050 0x0008      ORRS     R0,R0,#0x8
    751            }
    752            while ((eusart->STATUS & _EUSART_STATUS_RXBLOCK_MASK) != tmp) {
   \                     ??EUSART_RxBlock_6: (+1)
   \       0x68   0x6CA1             LDR      R1,[R4, #+72]
   \       0x6A   0xF011 0x0108      ANDS     R1,R1,#0x8
   \       0x6E   0x4281             CMP      R1,R0
   \       0x70   0xD1FA             BNE.N    ??EUSART_RxBlock_6
    753            } // Wait for the status register to be updated.
    754          }
   \       0x72   0xBD70             POP      {R4-R6,PC}
    755          
    756          /***************************************************************************//**
    757           * Enables/Disables the tristating of the transmitter output.
    758           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    759          void  EUSART_TxTristateSet(EUSART_TypeDef *eusart,
    760                                     EUSART_TristateTx_TypeDef enable)
    761          {
   \                     EUSART_TxTristateSet: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    762            uint32_t tmp;
    763          
    764            // Make sure that the module exists on the selected chip.
    765            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable13
   \        0xA   0x4284             CMP      R4,R0
   \        0xC   0xD101             BNE.N    ??EUSART_TxTristateSet_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE00D             B.N      ??EUSART_TxTristateSet_1
   \                     ??EUSART_TxTristateSet_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD101             BNE.N    ??EUSART_TxTristateSet_2
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE007             B.N      ??EUSART_TxTristateSet_1
   \                     ??EUSART_TxTristateSet_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x22   0x4284             CMP      R4,R0
   \       0x24   0xD101             BNE.N    ??EUSART_TxTristateSet_3
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE001             B.N      ??EUSART_TxTristateSet_1
   \                     ??EUSART_TxTristateSet_3: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??EUSART_TxTristateSet_1: (+1)
   \       0x2E   0xF110 0x0F01      CMN      R0,#+1
   \       0x32   0xD001             BEQ.N    ??EUSART_TxTristateSet_4
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??EUSART_TxTristateSet_5
   \                     ??EUSART_TxTristateSet_4: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??EUSART_TxTristateSet_5: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0
    766          
    767            tmp   = ((uint32_t)(enable));
   \       0x3C   0x002E             MOVS     R6,R5
   \       0x3E   0xB2F6             UXTB     R6,R6
    768            tmp  &= (_EUSART_CMD_TXTRIEN_MASK | _EUSART_CMD_TXTRIDIS_MASK);
   \       0x40   0xF016 0x06C0      ANDS     R6,R6,#0xC0
    769          
    770            eusart_sync(eusart, EUSART_SYNCBUSY_TXTRIEN | EUSART_SYNCBUSY_TXTRIDIS);
   \       0x44   0xF44F 0x61C0      MOV      R1,#+1536
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       eusart_sync
    771            eusart->CMD = tmp;
   \       0x4E   0x63A6             STR      R6,[R4, #+56]
    772            eusart_sync(eusart, EUSART_SYNCBUSY_TXTRIEN | EUSART_SYNCBUSY_TXTRIDIS);
   \       0x50   0xF44F 0x61C0      MOV      R1,#+1536
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x.... 0x....      BL       eusart_sync
    773          
    774            tmp = 0u;
   \       0x5A   0x2000             MOVS     R0,#+0
    775            if ((_EUSART_CMD_TXTRIEN_MASK & enable) != 0u) {
   \       0x5C   0x0669             LSLS     R1,R5,#+25
   \       0x5E   0xD501             BPL.N    ??EUSART_TxTristateSet_6
    776              tmp |= EUSART_STATUS_TXTRI;
   \       0x60   0xF050 0x0010      ORRS     R0,R0,#0x10
    777            }
    778            while ((eusart->STATUS & _EUSART_STATUS_TXTRI_MASK) != tmp) {
   \                     ??EUSART_TxTristateSet_6: (+1)
   \       0x64   0x6CA1             LDR      R1,[R4, #+72]
   \       0x66   0xF011 0x0110      ANDS     R1,R1,#0x10
   \       0x6A   0x4281             CMP      R1,R0
   \       0x6C   0xD1FA             BNE.N    ??EUSART_TxTristateSet_6
    779            } // Wait for the status register to be updated.
    780          }
   \       0x6E   0xBD70             POP      {R4-R6,PC}
    781          
    782          /***************************************************************************//**
    783           * Initializes the automatic enabling of transmissions and/or reception using
    784           * the PRS as a trigger.
    785           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    786          void EUSART_PrsTriggerEnable(EUSART_TypeDef *eusart,
    787                                       const EUSART_PrsTriggerInit_TypeDef *init)
    788          {
   \                     EUSART_PrsTriggerEnable: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    789            uint32_t tmp;
    790          
    791            // Make sure that the module exists on the selected chip.
    792            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x....             LDR.N    R0,??DataTable13
   \        0x8   0x4284             CMP      R4,R0
   \        0xA   0xD101             BNE.N    ??EUSART_PrsTriggerEnable_0
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0xE00B             B.N      ??EUSART_PrsTriggerEnable_1
   \                     ??EUSART_PrsTriggerEnable_0: (+1)
   \       0x10   0x....             LDR.N    R1,??DataTable13_1
   \       0x12   0x428C             CMP      R4,R1
   \       0x14   0xD101             BNE.N    ??EUSART_PrsTriggerEnable_2
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0xE006             B.N      ??EUSART_PrsTriggerEnable_1
   \                     ??EUSART_PrsTriggerEnable_2: (+1)
   \       0x1A   0x....             LDR.N    R1,??DataTable13_2
   \       0x1C   0x428C             CMP      R4,R1
   \       0x1E   0xD101             BNE.N    ??EUSART_PrsTriggerEnable_3
   \       0x20   0x2102             MOVS     R1,#+2
   \       0x22   0xE001             B.N      ??EUSART_PrsTriggerEnable_1
   \                     ??EUSART_PrsTriggerEnable_3: (+1)
   \       0x24   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \                     ??EUSART_PrsTriggerEnable_1: (+1)
   \       0x28   0xF111 0x0F01      CMN      R1,#+1
   \       0x2C   0xD001             BEQ.N    ??EUSART_PrsTriggerEnable_4
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0xE000             B.N      ??EUSART_PrsTriggerEnable_5
   \                     ??EUSART_PrsTriggerEnable_4: (+1)
   \       0x32   0x2100             MOVS     R1,#+0
   \                     ??EUSART_PrsTriggerEnable_5: (+1)
   \       0x34   0xB2C9             UXTB     R1,R1
    793          
    794            // The peripheral must be enabled to configure the PRS trigger.
    795            EFM_ASSERT(eusart->EN == EUSART_EN_EN);
   \       0x36   0x6861             LDR      R1,[R4, #+4]
   \       0x38   0x2901             CMP      R1,#+1
   \       0x3A   0xD101             BNE.N    ??EUSART_PrsTriggerEnable_6
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0xE000             B.N      ??EUSART_PrsTriggerEnable_7
   \                     ??EUSART_PrsTriggerEnable_6: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   \                     ??EUSART_PrsTriggerEnable_7: (+1)
   \       0x42   0xB2C9             UXTB     R1,R1
    796          
    797          #if defined(EUART_PRESENT)
    798            PRS->CONSUMER_EUART0_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUART0_TRIGGER_MASK);
    799          #else
    800          
    801          #if defined(EUSART0)
    802            if (eusart == EUSART0) {
   \       0x44   0x4284             CMP      R4,R0
   \       0x46   0xD105             BNE.N    ??EUSART_PrsTriggerEnable_8
    803              PRS->CONSUMER_EUSART0_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART0_TRIGGER_MASK);
   \       0x48   0x7869             LDRB     R1,[R5, #+1]
   \       0x4A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \       0x52   0x6001             STR      R1,[R0, #+0]
    804            }
    805          #endif
    806          #if defined(EUSART1)
    807            if (eusart == EUSART1) {
   \                     ??EUSART_PrsTriggerEnable_8: (+1)
   \       0x54   0x....             LDR.N    R0,??DataTable13_1
   \       0x56   0x4284             CMP      R4,R0
   \       0x58   0xD105             BNE.N    ??EUSART_PrsTriggerEnable_9
    808              PRS->CONSUMER_EUSART1_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART1_TRIGGER_MASK);
   \       0x5A   0x7869             LDRB     R1,[R5, #+1]
   \       0x5C   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0x64   0x6001             STR      R1,[R0, #+0]
    809            }
    810          #endif
    811          #if defined(EUSART2)
    812            if (eusart == EUSART2) {
   \                     ??EUSART_PrsTriggerEnable_9: (+1)
   \       0x66   0x....             LDR.N    R0,??DataTable13_2
   \       0x68   0x4284             CMP      R4,R0
   \       0x6A   0xD105             BNE.N    ??EUSART_PrsTriggerEnable_10
    813              PRS->CONSUMER_EUSART2_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART2_TRIGGER_MASK);
   \       0x6C   0x7869             LDRB     R1,[R5, #+1]
   \       0x6E   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \       0x76   0x6001             STR      R1,[R0, #+0]
    814            }
    815          #endif
    816          #if defined(EUSART3)
    817            if (eusart == EUSART3) {
    818              PRS->CONSUMER_EUSART3_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART3_TRIGGER_MASK);
    819            }
    820          #endif
    821          #if defined(EUSART4)
    822            if (eusart == EUSART4) {
    823              PRS->CONSUMER_EUSART4_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART4_TRIGGER_MASK);
    824            }
    825          #endif
    826          #endif
    827          
    828            tmp   = ((uint32_t)(init->prs_trigger_enable));
   \                     ??EUSART_PrsTriggerEnable_10: (+1)
   \       0x78   0x782E             LDRB     R6,[R5, #+0]
    829            tmp  &= (_EUSART_TRIGCTRL_RXTEN_MASK | _EUSART_TRIGCTRL_TXTEN_MASK);
   \       0x7A   0xF016 0x0603      ANDS     R6,R6,#0x3
    830          
    831            eusart->TRIGCTRL_SET = tmp;
   \       0x7E   0xF241 0x0034      MOVW     R0,#+4148
   \       0x82   0x5026             STR      R6,[R4, R0]
    832            eusart_sync(eusart, EUSART_SYNCBUSY_RXTEN | EUSART_SYNCBUSY_TXTEN);
   \       0x84   0x2106             MOVS     R1,#+6
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       eusart_sync
    833          
    834            tmp   = ~((uint32_t)(init->prs_trigger_enable));
   \       0x8C   0x782F             LDRB     R7,[R5, #+0]
   \       0x8E   0x43FF             MVNS     R7,R7
    835            tmp  &= (_EUSART_TRIGCTRL_RXTEN_MASK | _EUSART_TRIGCTRL_TXTEN_MASK);
   \       0x90   0xF017 0x0703      ANDS     R7,R7,#0x3
    836            eusart->TRIGCTRL_CLR = tmp;
   \       0x94   0xF242 0x0034      MOVW     R0,#+8244
   \       0x98   0x5027             STR      R7,[R4, R0]
    837            eusart_sync(eusart, EUSART_SYNCBUSY_RXTEN | EUSART_SYNCBUSY_TXTEN);
   \       0x9A   0x2106             MOVS     R1,#+6
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       eusart_sync
    838          }
   \       0xA2   0xBDF1             POP      {R0,R4-R7,PC}
    839          
    840          /*******************************************************************************
    841           **************************   LOCAL FUNCTIONS   ********************************
    842           ******************************************************************************/
    843          
    844          /***************************************************************************//**
    845           * Gets the clock associated to the specified EUSART instance.
    846           *
    847           * @param eusart Pointer to the EUSART peripheral register block.
    848           *
    849           * @return Clock corresponding to the eusart.
    850           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    851          static CMU_Clock_TypeDef EUSART_ClockGet(EUSART_TypeDef *eusart)
    852          {
   \                     EUSART_ClockGet: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    853            CMU_Clock_TypeDef clock;
    854          
    855          #if defined(EUART0)
    856            if (eusart == EUART0) {
    857              clock = cmuClock_EUART0;
    858            }
    859          #endif
    860          #if defined(EUSART0)
    861            if (eusart == EUSART0) {
   \        0x2   0x....             LDR.N    R0,??DataTable13
   \        0x4   0x4281             CMP      R1,R0
   \        0x6   0xD101             BNE.N    ??EUSART_ClockGet_0
    862              clock = cmuClock_EUSART0;
   \        0x8   0x2056             MOVS     R0,#+86
   \        0xA   0xE00B             B.N      ??EUSART_ClockGet_1
    863            }
    864          #endif
    865          #if defined(EUSART1)
    866            else if (eusart == EUSART1) {
   \                     ??EUSART_ClockGet_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable13_1
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD101             BNE.N    ??EUSART_ClockGet_2
    867              clock = cmuClock_EUSART1;
   \       0x12   0x2057             MOVS     R0,#+87
   \       0x14   0xE006             B.N      ??EUSART_ClockGet_1
    868            }
    869          #endif
    870          #if defined(EUSART2)
    871            else if (eusart == EUSART2) {
   \                     ??EUSART_ClockGet_2: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable13_2
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD101             BNE.N    ??EUSART_ClockGet_3
    872              clock = cmuClock_EUSART2;
   \       0x1C   0x2058             MOVS     R0,#+88
   \       0x1E   0xE001             B.N      ??EUSART_ClockGet_1
    873            }
    874          #endif
    875          #if defined(EUSART3)
    876            else if (eusart == EUSART3) {
    877              clock = cmuClock_EUSART3;
    878            }
    879          #endif
    880          #if defined(EUSART4)
    881            else if (eusart == EUSART4) {
    882              clock = cmuClock_EUSART4;
    883            }
    884          #endif
    885            else {
    886              EFM_ASSERT(0);
    887              return (CMU_Clock_TypeDef)0u;
   \                     ??EUSART_ClockGet_3: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE7FF             B.N      ??EUSART_ClockGet_4
    888            }
    889            return clock;
   \                     ??EUSART_ClockGet_1: (+1)
   \                     ??EUSART_ClockGet_4: (+1)
   \       0x24   0x4770             BX       LR
    890          }
    891          
    892          /***************************************************************************//**
    893           * Initializes the EUSART with asynchronous common settings to high
    894           * and low frequency clock.
    895           *
    896           * @param eusart Pointer to the EUSART peripheral register block.
    897           * @param init A pointer to the initialization structure.
    898           * @param irdaInit Pointer to IrDA initialization structure.
    899           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    900          static void EUSART_AsyncInitCommon(EUSART_TypeDef *eusart,
    901                                             const EUSART_UartInit_TypeDef  *init,
    902                                             const EUSART_IrDAInit_TypeDef  *irdaInit,
    903                                             const EUSART_DaliInit_TypeDef  *daliInit)
    904          {
   \                     EUSART_AsyncInitCommon: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001E             MOVS     R6,R3
    905            // LF register about to be modified requires sync busy check.
    906            if (eusart->EN) {
   \        0xA   0x6878             LDR      R0,[R7, #+4]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD004             BEQ.N    ??EUSART_AsyncInitCommon_0
    907              eusart_sync(eusart, _EUSART_SYNCBUSY_MASK);
   \       0x10   0xF640 0x71FF      MOVW     R1,#+4095
   \       0x14   0x0038             MOVS     R0,R7
   \       0x16   0x.... 0x....      BL       eusart_sync
    908            }
    909            // Initialize EUSART registers to hardware reset state.
    910            EUSART_Reset(eusart);
   \                     ??EUSART_AsyncInitCommon_0: (+1)
   \       0x1A   0x0038             MOVS     R0,R7
   \       0x1C   0x.... 0x....      BL       EUSART_Reset
    911          
    912            // Configure frame format
    913            eusart->FRAMECFG = (eusart->FRAMECFG & ~(_EUSART_FRAMECFG_DATABITS_MASK
    914                                                     | _EUSART_FRAMECFG_STOPBITS_MASK
    915                                                     | _EUSART_FRAMECFG_PARITY_MASK))
    916                               | (uint32_t)(init->databits)
    917                               | (uint32_t)(init->parity)
    918                               | (uint32_t)(init->stopbits);
   \       0x20   0x6979             LDR      R1,[R7, #+20]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \       0x26   0x4001             ANDS     R1,R0,R1
   \       0x28   0x7B68             LDRB     R0,[R5, #+13]
   \       0x2A   0x4301             ORRS     R1,R0,R1
   \       0x2C   0xF9B5 0x000E      LDRSH    R0,[R5, #+14]
   \       0x30   0x4301             ORRS     R1,R0,R1
   \       0x32   0xF9B5 0x0010      LDRSH    R0,[R5, #+16]
   \       0x36   0x4301             ORRS     R1,R0,R1
   \       0x38   0x6179             STR      R1,[R7, #+20]
    919          
    920            // Configure global configuration register 0.
    921            eusart->CFG0 = (eusart->CFG0 & ~(_EUSART_CFG0_OVS_MASK
    922                                             | _EUSART_CFG0_LOOPBK_MASK
    923                                             | _EUSART_CFG0_MVDIS_MASK))
    924                           | (uint32_t)(init->oversampling)
    925                           | (uint32_t)(init->loopbackEnable)
    926                           | (uint32_t)(init->majorityVote);
   \       0x3A   0x68B9             LDR      R1,[R7, #+8]
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \       0x40   0x4001             ANDS     R1,R0,R1
   \       0x42   0x7B28             LDRB     R0,[R5, #+12]
   \       0x44   0x4301             ORRS     R1,R0,R1
   \       0x46   0x7E28             LDRB     R0,[R5, #+24]
   \       0x48   0x4301             ORRS     R1,R0,R1
   \       0x4A   0x6968             LDR      R0,[R5, #+20]
   \       0x4C   0x4301             ORRS     R1,R0,R1
   \       0x4E   0x60B9             STR      R1,[R7, #+8]
    927          
    928            if (init->baudrate == 0) {
   \       0x50   0x68A8             LDR      R0,[R5, #+8]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD103             BNE.N    ??EUSART_AsyncInitCommon_1
    929              eusart->CFG0 |= EUSART_CFG0_AUTOBAUDEN;
   \       0x56   0x68B8             LDR      R0,[R7, #+8]
   \       0x58   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \       0x5C   0x60B8             STR      R0,[R7, #+8]
    930            }
    931          
    932            if (init->advancedSettings) {
   \                     ??EUSART_AsyncInitCommon_1: (+1)
   \       0x5E   0x69E8             LDR      R0,[R5, #+28]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xF000 0x80B0      BEQ.W    ??EUSART_AsyncInitCommon_2
    933              eusart->CFG0 = (eusart->CFG0 & ~(_EUSART_CFG0_ERRSDMA_MASK | _EUSART_CFG0_AUTOTRI_MASK
    934                                               | _EUSART_CFG0_RXINV_MASK | _EUSART_CFG0_TXINV_MASK
    935                                               | _EUSART_CFG0_CCEN_MASK  | _EUSART_CFG0_MPM_MASK
    936                                               | _EUSART_CFG0_MPAB_MASK  | _EUSART_CFG0_MSBF_MASK))
    937                             | (uint32_t)(init->advancedSettings->dmaHaltOnError << _EUSART_CFG0_ERRSDMA_SHIFT)
    938                             | (uint32_t)(init->advancedSettings->txAutoTristate << _EUSART_CFG0_AUTOTRI_SHIFT)
    939                             | (uint32_t)(init->advancedSettings->invertIO & (_EUSART_CFG0_RXINV_MASK | _EUSART_CFG0_TXINV_MASK))
    940                             | (uint32_t)(init->advancedSettings->collisionDetectEnable << _EUSART_CFG0_CCEN_SHIFT)
    941                             | (uint32_t)(init->advancedSettings->multiProcessorEnable << _EUSART_CFG0_MPM_SHIFT)
    942                             | (uint32_t)(init->advancedSettings->multiProcessorAddressBitHigh << _EUSART_CFG0_MPAB_SHIFT)
    943                             | (uint32_t)(init->advancedSettings->msbFirst << _EUSART_CFG0_MSBF_SHIFT);
   \       0x66   0x68B9             LDR      R1,[R7, #+8]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \       0x6C   0x4001             ANDS     R1,R0,R1
   \       0x6E   0x69E8             LDR      R0,[R5, #+28]
   \       0x70   0x7A00             LDRB     R0,[R0, #+8]
   \       0x72   0xEA51 0x5180      ORRS     R1,R1,R0, LSL #+22
   \       0x76   0x69E8             LDR      R0,[R5, #+28]
   \       0x78   0x7A80             LDRB     R0,[R0, #+10]
   \       0x7A   0xEA51 0x4140      ORRS     R1,R1,R0, LSL #+17
   \       0x7E   0x69E8             LDR      R0,[R5, #+28]
   \       0x80   0x8880             LDRH     R0,[R0, #+4]
   \       0x82   0xF410 0x40C0      ANDS     R0,R0,#0x6000
   \       0x86   0x4301             ORRS     R1,R0,R1
   \       0x88   0x69E8             LDR      R0,[R5, #+28]
   \       0x8A   0x7840             LDRB     R0,[R0, #+1]
   \       0x8C   0xEA51 0x0180      ORRS     R1,R1,R0, LSL #+2
   \       0x90   0x69E8             LDR      R0,[R5, #+28]
   \       0x92   0x7B40             LDRB     R0,[R0, #+13]
   \       0x94   0xEA51 0x01C0      ORRS     R1,R1,R0, LSL #+3
   \       0x98   0x69E8             LDR      R0,[R5, #+28]
   \       0x9A   0x7B80             LDRB     R0,[R0, #+14]
   \       0x9C   0xEA51 0x1100      ORRS     R1,R1,R0, LSL #+4
   \       0xA0   0x69E8             LDR      R0,[R5, #+28]
   \       0xA2   0x7880             LDRB     R0,[R0, #+2]
   \       0xA4   0xEA51 0x2180      ORRS     R1,R1,R0, LSL #+10
   \       0xA8   0x60B9             STR      R1,[R7, #+8]
    944          
    945              // Configure global configuration register 1.
    946              eusart->CFG1 = (eusart->CFG1 & ~(_EUSART_CFG1_RXFIW_MASK | _EUSART_CFG1_TXFIW_MASK
    947                                               | _EUSART_CFG1_RXDMAWU_MASK | _EUSART_CFG1_TXDMAWU_MASK))
    948                             | (uint32_t)(init->advancedSettings->RxFifoWatermark)
    949                             | (uint32_t)(init->advancedSettings->TxFifoWatermark)
    950                             | (uint32_t)(init->advancedSettings->dmaWakeUpOnRx << _EUSART_CFG1_RXDMAWU_SHIFT)
    951                             | (uint32_t)(init->advancedSettings->dmaWakeUpOnTx << _EUSART_CFG1_TXDMAWU_SHIFT);
   \       0xAA   0x68F9             LDR      R1,[R7, #+12]
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \       0xB0   0x4001             ANDS     R1,R0,R1
   \       0xB2   0x69E8             LDR      R0,[R5, #+28]
   \       0xB4   0x6900             LDR      R0,[R0, #+16]
   \       0xB6   0x4301             ORRS     R1,R0,R1
   \       0xB8   0x69E8             LDR      R0,[R5, #+28]
   \       0xBA   0x6940             LDR      R0,[R0, #+20]
   \       0xBC   0x4301             ORRS     R1,R0,R1
   \       0xBE   0x69E8             LDR      R0,[R5, #+28]
   \       0xC0   0x7980             LDRB     R0,[R0, #+6]
   \       0xC2   0xEA51 0x2180      ORRS     R1,R1,R0, LSL #+10
   \       0xC6   0x69E8             LDR      R0,[R5, #+28]
   \       0xC8   0x79C0             LDRB     R0,[R0, #+7]
   \       0xCA   0xEA51 0x2140      ORRS     R1,R1,R0, LSL #+9
   \       0xCE   0x60F9             STR      R1,[R7, #+12]
    952          
    953              if (init->advancedSettings->hwFlowControl == eusartHwFlowControlCts
    954                  || init->advancedSettings->hwFlowControl == eusartHwFlowControlCtsAndRts) {
   \       0xD0   0x69E8             LDR      R0,[R5, #+28]
   \       0xD2   0x7800             LDRB     R0,[R0, #+0]
   \       0xD4   0x2801             CMP      R0,#+1
   \       0xD6   0xD003             BEQ.N    ??EUSART_AsyncInitCommon_3
   \       0xD8   0x69E8             LDR      R0,[R5, #+28]
   \       0xDA   0x7800             LDRB     R0,[R0, #+0]
   \       0xDC   0x2803             CMP      R0,#+3
   \       0xDE   0xD103             BNE.N    ??EUSART_AsyncInitCommon_4
    955                eusart->CFG1 |= EUSART_CFG1_CTSEN;
   \                     ??EUSART_AsyncInitCommon_3: (+1)
   \       0xE0   0x68F8             LDR      R0,[R7, #+12]
   \       0xE2   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xE6   0x60F8             STR      R0,[R7, #+12]
    956              }
    957              // Enable RTS route pin if necessary. CTS is an input so it is enabled by default.
    958              if ((init->advancedSettings->hwFlowControl == eusartHwFlowControlRts)
    959                  || (init->advancedSettings->hwFlowControl == eusartHwFlowControlCtsAndRts)) {
   \                     ??EUSART_AsyncInitCommon_4: (+1)
   \       0xE8   0x69E8             LDR      R0,[R5, #+28]
   \       0xEA   0x7800             LDRB     R0,[R0, #+0]
   \       0xEC   0x2802             CMP      R0,#+2
   \       0xEE   0xD003             BEQ.N    ??EUSART_AsyncInitCommon_5
   \       0xF0   0x69E8             LDR      R0,[R5, #+28]
   \       0xF2   0x7800             LDRB     R0,[R0, #+0]
   \       0xF4   0x2803             CMP      R0,#+3
   \       0xF6   0xD116             BNE.N    ??EUSART_AsyncInitCommon_6
    960          #if defined(EUART0)
    961                GPIO->EUARTROUTE_SET->ROUTEEN = GPIO_EUART_ROUTEEN_RTSPEN;
    962          #elif defined(EUSART0)
    963                GPIO->EUSARTROUTE_SET[EUSART_NUM(eusart)].ROUTEEN = GPIO_EUSART_ROUTEEN_RTSPEN;
   \                     ??EUSART_AsyncInitCommon_5: (+1)
   \       0xF8   0x....             LDR.N    R0,??DataTable13
   \       0xFA   0x4287             CMP      R7,R0
   \       0xFC   0xD101             BNE.N    ??EUSART_AsyncInitCommon_7
   \       0xFE   0x2200             MOVS     R2,#+0
   \      0x100   0xE00B             B.N      ??EUSART_AsyncInitCommon_8
   \                     ??EUSART_AsyncInitCommon_7: (+1)
   \      0x102   0x....             LDR.N    R0,??DataTable13_1
   \      0x104   0x4287             CMP      R7,R0
   \      0x106   0xD101             BNE.N    ??EUSART_AsyncInitCommon_9
   \      0x108   0x2201             MOVS     R2,#+1
   \      0x10A   0xE006             B.N      ??EUSART_AsyncInitCommon_8
   \                     ??EUSART_AsyncInitCommon_9: (+1)
   \      0x10C   0x....             LDR.N    R0,??DataTable13_2
   \      0x10E   0x4287             CMP      R7,R0
   \      0x110   0xD101             BNE.N    ??EUSART_AsyncInitCommon_10
   \      0x112   0x2202             MOVS     R2,#+2
   \      0x114   0xE001             B.N      ??EUSART_AsyncInitCommon_8
   \                     ??EUSART_AsyncInitCommon_10: (+1)
   \      0x116   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \                     ??EUSART_AsyncInitCommon_8: (+1)
   \      0x11A   0x2002             MOVS     R0,#+2
   \      0x11C   0x.... 0x....      LDR.W    R1,??DataTable15_14
   \      0x120   0x0152             LSLS     R2,R2,#+5
   \      0x122   0x5088             STR      R0,[R1, R2]
   \      0x124   0xE015             B.N      ??EUSART_AsyncInitCommon_11
    964          #endif
    965              } else {
    966          #if defined(EUART0)
    967                GPIO->EUARTROUTE_CLR->ROUTEEN = GPIO_EUART_ROUTEEN_RTSPEN;
    968          #elif defined(EUSART0)
    969                GPIO->EUSARTROUTE_CLR[EUSART_NUM(eusart)].ROUTEEN = GPIO_EUSART_ROUTEEN_RTSPEN;
   \                     ??EUSART_AsyncInitCommon_6: (+1)
   \      0x126   0x....             LDR.N    R0,??DataTable13
   \      0x128   0x4287             CMP      R7,R0
   \      0x12A   0xD101             BNE.N    ??EUSART_AsyncInitCommon_12
   \      0x12C   0x2200             MOVS     R2,#+0
   \      0x12E   0xE00B             B.N      ??EUSART_AsyncInitCommon_13
   \                     ??EUSART_AsyncInitCommon_12: (+1)
   \      0x130   0x....             LDR.N    R0,??DataTable13_1
   \      0x132   0x4287             CMP      R7,R0
   \      0x134   0xD101             BNE.N    ??EUSART_AsyncInitCommon_14
   \      0x136   0x2201             MOVS     R2,#+1
   \      0x138   0xE006             B.N      ??EUSART_AsyncInitCommon_13
   \                     ??EUSART_AsyncInitCommon_14: (+1)
   \      0x13A   0x....             LDR.N    R0,??DataTable13_2
   \      0x13C   0x4287             CMP      R7,R0
   \      0x13E   0xD101             BNE.N    ??EUSART_AsyncInitCommon_15
   \      0x140   0x2202             MOVS     R2,#+2
   \      0x142   0xE001             B.N      ??EUSART_AsyncInitCommon_13
   \                     ??EUSART_AsyncInitCommon_15: (+1)
   \      0x144   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \                     ??EUSART_AsyncInitCommon_13: (+1)
   \      0x148   0x2002             MOVS     R0,#+2
   \      0x14A   0x.... 0x....      LDR.W    R1,??DataTable15_15
   \      0x14E   0x0152             LSLS     R2,R2,#+5
   \      0x150   0x5088             STR      R0,[R1, R2]
    970          #endif
    971              }
    972              eusart->STARTFRAMECFG_SET = (uint32_t)init->advancedSettings->startFrame;
   \                     ??EUSART_AsyncInitCommon_11: (+1)
   \      0x152   0x69E8             LDR      R0,[R5, #+28]
   \      0x154   0x7A40             LDRB     R0,[R0, #+9]
   \      0x156   0xF241 0x0128      MOVW     R1,#+4136
   \      0x15A   0x5078             STR      R0,[R7, R1]
    973              if (init->advancedSettings->startFrame) {
   \      0x15C   0x69E8             LDR      R0,[R5, #+28]
   \      0x15E   0x7A40             LDRB     R0,[R0, #+9]
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD003             BEQ.N    ??EUSART_AsyncInitCommon_16
    974                eusart->CFG1 |= EUSART_CFG1_SFUBRX;
   \      0x164   0x68F8             LDR      R0,[R7, #+12]
   \      0x166   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x16A   0x60F8             STR      R0,[R7, #+12]
    975              }
    976              if (init->advancedSettings->prsRxEnable) {
   \                     ??EUSART_AsyncInitCommon_16: (+1)
   \      0x16C   0x69E8             LDR      R0,[R5, #+28]
   \      0x16E   0x7AC0             LDRB     R0,[R0, #+11]
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD021             BEQ.N    ??EUSART_AsyncInitCommon_17
    977                eusart->CFG1 |= EUSART_CFG1_RXPRSEN;
   \      0x174   0x68F8             LDR      R0,[R7, #+12]
   \      0x176   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \      0x17A   0x60F8             STR      R0,[R7, #+12]
    978                // Configure PRS channel as input data line for EUSART.
    979          #if defined(EUART_PRESENT)
    980                PRS->CONSUMER_EUART0_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUART0_RX_MASK);
    981          #elif defined(EUSART_PRESENT)
    982          
    983                if (eusart == EUSART0) {
   \      0x17C   0x.... 0x....      LDR.W    R0,??DataTable15_16
   \      0x180   0x4287             CMP      R7,R0
   \      0x182   0xD106             BNE.N    ??EUSART_AsyncInitCommon_18
    984                  PRS->CONSUMER_EUSART0_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART0_RX_MASK);
   \      0x184   0x69E8             LDR      R0,[R5, #+28]
   \      0x186   0x7B00             LDRB     R0,[R0, #+12]
   \      0x188   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x18C   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \      0x190   0x6008             STR      R0,[R1, #+0]
    985                }
    986          #if defined(EUSART1)
    987                if (eusart == EUSART1) {
   \                     ??EUSART_AsyncInitCommon_18: (+1)
   \      0x192   0x.... 0x....      LDR.W    R0,??DataTable15_18
   \      0x196   0x4287             CMP      R7,R0
   \      0x198   0xD105             BNE.N    ??EUSART_AsyncInitCommon_19
    988                  PRS->CONSUMER_EUSART1_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART1_RX_MASK);
   \      0x19A   0x69E8             LDR      R0,[R5, #+28]
   \      0x19C   0x7B01             LDRB     R1,[R0, #+12]
   \      0x19E   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x1A2   0x....             LDR.N    R0,??DataTable15_19
   \      0x1A4   0x6001             STR      R1,[R0, #+0]
    989                }
    990          #endif
    991          #if defined(EUSART2)
    992                if (eusart == EUSART2) {
   \                     ??EUSART_AsyncInitCommon_19: (+1)
   \      0x1A6   0x....             LDR.N    R0,??DataTable13_2
   \      0x1A8   0x4287             CMP      R7,R0
   \      0x1AA   0xD105             BNE.N    ??EUSART_AsyncInitCommon_17
    993                  PRS->CONSUMER_EUSART2_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART2_RX_MASK);
   \      0x1AC   0x69E8             LDR      R0,[R5, #+28]
   \      0x1AE   0x7B01             LDRB     R1,[R0, #+12]
   \      0x1B0   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x1B4   0x....             LDR.N    R0,??DataTable15_20
   \      0x1B6   0x6001             STR      R1,[R0, #+0]
    994                }
    995          #endif
    996          #if defined(EUSART3)
    997                if (eusart == EUSART3) {
    998                  PRS->CONSUMER_EUSART3_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART3_RX_MASK);
    999                }
   1000          #endif
   1001          #if defined(EUSART4)
   1002                if (eusart == EUSART4) {
   1003                  PRS->CONSUMER_EUSART4_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART4_RX_MASK);
   1004                }
   1005          #endif
   1006          #endif
   1007              }
   1008          
   1009              // Configure global configuration timing register.
   1010              eusart->TIMINGCFG = (eusart->TIMINGCFG & ~_EUSART_TIMINGCFG_TXDELAY_MASK)
   1011                                  | (uint32_t)(init->advancedSettings->autoTxDelay);
   \                     ??EUSART_AsyncInitCommon_17: (+1)
   \      0x1B8   0x6A79             LDR      R1,[R7, #+36]
   \      0x1BA   0x0889             LSRS     R1,R1,#+2
   \      0x1BC   0x0089             LSLS     R1,R1,#+2
   \      0x1BE   0x69E8             LDR      R0,[R5, #+28]
   \      0x1C0   0x7BC0             LDRB     R0,[R0, #+15]
   \      0x1C2   0x4301             ORRS     R1,R0,R1
   \      0x1C4   0x6279             STR      R1,[R7, #+36]
   1012            }
   1013          
   1014            if (irdaInit) {
   \                     ??EUSART_AsyncInitCommon_2: (+1)
   \      0x1C6   0x2C00             CMP      R4,#+0
   \      0x1C8   0xD016             BEQ.N    ??EUSART_AsyncInitCommon_20
   1015              if (irdaInit->irDALowFrequencyEnable) {
   \      0x1CA   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \      0x1CE   0x2800             CMP      R0,#+0
   \      0x1D0   0xD004             BEQ.N    ??EUSART_AsyncInitCommon_21
   1016                eusart->IRLFCFG_SET = (uint32_t)(EUSART_IRLFCFG_IRLFEN);
   \      0x1D2   0x2101             MOVS     R1,#+1
   \      0x1D4   0xF517 0x5081      ADDS     R0,R7,#+4128
   \      0x1D8   0x6001             STR      R1,[R0, #+0]
   \      0x1DA   0xE00D             B.N      ??EUSART_AsyncInitCommon_20
   1017              } else {
   1018                // Configure IrDA HF configuration register.
   1019                eusart->IRHFCFG_SET = (eusart->IRHFCFG & ~(_EUSART_IRHFCFG_IRHFEN_MASK
   1020                                                           | _EUSART_IRHFCFG_IRHFEN_MASK
   1021                                                           | _EUSART_IRHFCFG_IRHFFILT_MASK))
   1022                                      | (uint32_t)(EUSART_IRHFCFG_IRHFEN)
   1023                                      | (uint32_t)(irdaInit->irDAPulseWidth)
   1024                                      | (uint32_t)(irdaInit->irDARxFilterEnable);
   \                     ??EUSART_AsyncInitCommon_21: (+1)
   \      0x1DC   0x69F9             LDR      R1,[R7, #+28]
   \      0x1DE   0xF031 0x0109      BICS     R1,R1,#0x9
   \      0x1E2   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \      0x1E6   0x4301             ORRS     R1,R0,R1
   \      0x1E8   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \      0x1EC   0x4301             ORRS     R1,R0,R1
   \      0x1EE   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x1F2   0xF241 0x001C      MOVW     R0,#+4124
   \      0x1F6   0x5039             STR      R1,[R7, R0]
   1025              }
   1026            }
   1027          
   1028          #if defined(EUSART_DALICFG_DALIEN)
   1029            // DALI-specific configuration section
   1030            if (daliInit) {
   1031              if (init->loopbackEnable) {
   1032                // If LOOPBK in CFG0 is set to 1 in order to do loopback testing for DALI,
   1033                // then in this case DALIRXENDT should be set to 1.
   1034                eusart->DALICFG_SET = EUSART_DALICFG_DALIRXENDT;
   1035              }
   1036          
   1037              if (EUSART_REF_VALID(eusart)) {
   1038                uint8_t index = EUSART_NUM(eusart);
   1039          
   1040                // keep track of the number of 16-bits packet to send
   1041                if (daliInit->TXdatabits <= eusartDaliTxDataBits16) {
   1042                  dali_tx_nb_packets[index] = 1;
   1043                } else {
   1044                  dali_tx_nb_packets[index] = 2;
   1045                }
   1046          
   1047                // keep track of the number of 16-bits packet to receive
   1048                if (daliInit->RXdatabits <= eusartDaliRxDataBits16) {
   1049                  dali_rx_nb_packets[index] = 1;
   1050                } else {
   1051                  dali_rx_nb_packets[index] = 2;
   1052                }
   1053              }
   1054          
   1055              // Configure the numbers of bits per TX and RX frames
   1056              eusart->DALICFG = (eusart->DALICFG & ~(_EUSART_DALICFG_DALITXDATABITS_MASK
   1057                                                     | _EUSART_DALICFG_DALIRXDATABITS_MASK))
   1058                                | daliInit->TXdatabits
   1059                                | daliInit->RXdatabits;
   1060              eusart->DALICFG_SET = EUSART_DALICFG_DALIEN;
   1061            }
   1062          #else
   1063            (void)(daliInit);
   1064          #endif /* EUSART_DALICFG_DALIEN */
   1065          
   1066            // Enable EUSART IP.
   1067            EUSART_Enable(eusart, eusartEnable);
   \                     ??EUSART_AsyncInitCommon_20: (+1)
   \      0x1F8   0x2105             MOVS     R1,#+5
   \      0x1FA   0x0038             MOVS     R0,R7
   \      0x1FC   0x.... 0x....      BL       EUSART_Enable
   1068          
   1069            // Configure the baudrate if auto baud detection is not used.
   1070            if (init->baudrate) {
   \      0x200   0x68A8             LDR      R0,[R5, #+8]
   \      0x202   0x2800             CMP      R0,#+0
   \      0x204   0xD004             BEQ.N    ??EUSART_AsyncInitCommon_22
   1071              EUSART_BaudrateSet(eusart, init->refFreq, init->baudrate);
   \      0x206   0x68AA             LDR      R2,[R5, #+8]
   \      0x208   0x6869             LDR      R1,[R5, #+4]
   \      0x20A   0x0038             MOVS     R0,R7
   \      0x20C   0x.... 0x....      BL       EUSART_BaudrateSet
   1072            }
   1073          
   1074            // Finally enable the Rx and/or Tx channel (as specified).
   1075            EUSART_Enable(eusart, init->enable);
   \                     ??EUSART_AsyncInitCommon_22: (+1)
   \      0x210   0x7829             LDRB     R1,[R5, #+0]
   \      0x212   0x0038             MOVS     R0,R7
   \      0x214   0x.... 0x....      BL       EUSART_Enable
   1076            while (~EUSART_StatusGet(eusart) & (_EUSART_STATUS_RXIDLE_MASK | _EUSART_STATUS_TXIDLE_MASK)) {
   \                     ??EUSART_AsyncInitCommon_23: (+1)
   \      0x218   0x0038             MOVS     R0,R7
   \      0x21A   0x.... 0x....      BL       EUSART_StatusGet
   \      0x21E   0x43C0             MVNS     R0,R0
   \      0x220   0xF410 0x5F40      TST      R0,#0x3000
   \      0x224   0xD1F8             BNE.N    ??EUSART_AsyncInitCommon_23
   1077            }
   1078          }
   \      0x226   0xBDF1             POP      {R0,R4-R7,PC}
   1079          
   1080          #if defined(EUSART_PRESENT)
   1081          /***************************************************************************//**
   1082           * Initializes the EUSART with synchronous common settings to high
   1083           * and low frequency clock.
   1084           *
   1085           * @param eusart Pointer to the EUSART peripheral register block.
   1086           * @param init A pointer to the initialization structure.
   1087           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1088          static void EUSART_SyncInitCommon(EUSART_TypeDef *eusart,
   1089                                            EUSART_SpiInit_TypeDef const *init)
   1090          {
   \                     EUSART_SyncInitCommon: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
   1091            void* advancedSetting_ptr = (void*)init->advancedSettings; // Used to avoid GCC over optimization.
   \        0x6   0x692C             LDR      R4,[R5, #+16]
   1092          
   1093            // LF register about to be modified requires sync busy check.
   1094            if (eusart->EN) {
   \        0x8   0x6870             LDR      R0,[R6, #+4]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??EUSART_SyncInitCommon_0
   1095              eusart_sync(eusart, _EUSART_SYNCBUSY_MASK);
   \        0xE   0xF640 0x71FF      MOVW     R1,#+4095
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0x.... 0x....      BL       eusart_sync
   1096            }
   1097          
   1098            // Initialize EUSART registers to hardware reset state.
   1099            EUSART_Reset(eusart);
   \                     ??EUSART_SyncInitCommon_0: (+1)
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x.... 0x....      BL       EUSART_Reset
   1100          
   1101            // Configure global configuration register 2.
   1102            eusart->CFG2 = (eusart->CFG2 & ~(_EUSART_CFG2_MASTER_MASK
   1103                                             | _EUSART_CFG2_CLKPOL_MASK
   1104                                             | _EUSART_CFG2_CLKPHA_MASK
   1105                                             | _EUSART_CFG2_FORCELOAD_MASK))
   1106                           | (uint32_t)(init->master)
   1107                           | (uint32_t)(init->clockMode)
   1108                           | (uint32_t)(EUSART_CFG2_FORCELOAD); // Force load feature enabled by default.
   \       0x1E   0x6931             LDR      R1,[R6, #+16]
   \       0x20   0xF031 0x0187      BICS     R1,R1,#0x87
   \       0x24   0x7B68             LDRB     R0,[R5, #+13]
   \       0x26   0x4301             ORRS     R1,R0,R1
   \       0x28   0x7BA8             LDRB     R0,[R5, #+14]
   \       0x2A   0x4301             ORRS     R1,R0,R1
   \       0x2C   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x30   0x6131             STR      R1,[R6, #+16]
   1109          
   1110            if (advancedSetting_ptr) {
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD028             BEQ.N    ??EUSART_SyncInitCommon_1
   1111              // Configure global configuration register 2.
   1112              eusart->CFG2 = (eusart->CFG2 & ~(_EUSART_CFG2_FORCELOAD_MASK
   1113                                               | _EUSART_CFG2_AUTOCS_MASK
   1114                                               | _EUSART_CFG2_AUTOTX_MASK
   1115                                               | _EUSART_CFG2_CSINV_MASK
   1116                                               | _EUSART_CFG2_CLKPRSEN_MASK))
   1117                             | (uint32_t)(init->advancedSettings->forceLoad << _EUSART_CFG2_FORCELOAD_SHIFT)
   1118                             | (uint32_t)(init->advancedSettings->autoCsEnable << _EUSART_CFG2_AUTOCS_SHIFT)
   1119                             | (uint32_t)(init->advancedSettings->autoTxEnable << _EUSART_CFG2_AUTOTX_SHIFT)
   1120                             | (uint32_t)(init->advancedSettings->csPolarity)
   1121                             | (uint32_t)(init->advancedSettings->prsClockEnable << _EUSART_CFG2_CLKPRSEN_SHIFT);
   \       0x36   0x6931             LDR      R1,[R6, #+16]
   \       0x38   0xF031 0x01F8      BICS     R1,R1,#0xF8
   \       0x3C   0x6928             LDR      R0,[R5, #+16]
   \       0x3E   0x7F00             LDRB     R0,[R0, #+28]
   \       0x40   0xEA51 0x11C0      ORRS     R1,R1,R0, LSL #+7
   \       0x44   0x6928             LDR      R0,[R5, #+16]
   \       0x46   0x7900             LDRB     R0,[R0, #+4]
   \       0x48   0xEA51 0x1140      ORRS     R1,R1,R0, LSL #+5
   \       0x4C   0x6928             LDR      R0,[R5, #+16]
   \       0x4E   0x7A40             LDRB     R0,[R0, #+9]
   \       0x50   0xEA51 0x1100      ORRS     R1,R1,R0, LSL #+4
   \       0x54   0x6928             LDR      R0,[R5, #+16]
   \       0x56   0x7800             LDRB     R0,[R0, #+0]
   \       0x58   0x4301             ORRS     R1,R0,R1
   \       0x5A   0x6928             LDR      R0,[R5, #+16]
   \       0x5C   0x7BC0             LDRB     R0,[R0, #+15]
   \       0x5E   0xEA51 0x1180      ORRS     R1,R1,R0, LSL #+6
   \       0x62   0x6131             STR      R1,[R6, #+16]
   1122          
   1123              // Only applicable to EM2 (low frequency) capable EUSART instances.
   1124              eusart->CFG1 = (eusart->CFG1 & ~(_EUSART_CFG1_RXFIW_MASK
   1125                                               | _EUSART_CFG1_TXFIW_MASK))
   1126                             | (uint32_t)(init->advancedSettings->RxFifoWatermark)
   1127                             | (uint32_t)(init->advancedSettings->TxFifoWatermark)
   1128                             | (uint32_t)(init->advancedSettings->dmaWakeUpOnRx << _EUSART_CFG1_RXDMAWU_SHIFT)
   1129                             | (uint32_t)(init->advancedSettings->prsRxEnable << _EUSART_CFG1_RXPRSEN_SHIFT);
   \       0x64   0x68F1             LDR      R1,[R6, #+12]
   \       0x66   0x....             LDR.N    R0,??DataTable15_21
   \       0x68   0x4001             ANDS     R1,R0,R1
   \       0x6A   0x6928             LDR      R0,[R5, #+16]
   \       0x6C   0x6940             LDR      R0,[R0, #+20]
   \       0x6E   0x4301             ORRS     R1,R0,R1
   \       0x70   0x6928             LDR      R0,[R5, #+16]
   \       0x72   0x6980             LDR      R0,[R0, #+24]
   \       0x74   0x4301             ORRS     R1,R0,R1
   \       0x76   0x6928             LDR      R0,[R5, #+16]
   \       0x78   0x7B00             LDRB     R0,[R0, #+12]
   \       0x7A   0xEA51 0x2180      ORRS     R1,R1,R0, LSL #+10
   \       0x7E   0x6928             LDR      R0,[R5, #+16]
   \       0x80   0x7B40             LDRB     R0,[R0, #+13]
   \       0x82   0xEA51 0x31C0      ORRS     R1,R1,R0, LSL #+15
   \       0x86   0x60F1             STR      R1,[R6, #+12]
   1130            }
   1131          
   1132            eusart->CFG0 = (eusart->CFG0 & ~(_EUSART_CFG0_SYNC_MASK
   1133                                             | _EUSART_CFG0_LOOPBK_MASK))
   1134                           | (uint32_t)(_EUSART_CFG0_SYNC_SYNC)
   1135                           | (uint32_t)(init->loopbackEnable);
   \                     ??EUSART_SyncInitCommon_1: (+1)
   \       0x88   0x68B1             LDR      R1,[R6, #+8]
   \       0x8A   0x0889             LSRS     R1,R1,#+2
   \       0x8C   0x0089             LSLS     R1,R1,#+2
   \       0x8E   0x7BE8             LDRB     R0,[R5, #+15]
   \       0x90   0x4301             ORRS     R1,R0,R1
   \       0x92   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x96   0x60B1             STR      R1,[R6, #+8]
   1136          
   1137            if (advancedSetting_ptr) {
   \       0x98   0x2C00             CMP      R4,#+0
   \       0x9A   0xD01E             BEQ.N    ??EUSART_SyncInitCommon_2
   1138              eusart->CFG0 |= (uint32_t)init->advancedSettings->invertIO & (_EUSART_CFG0_RXINV_MASK | _EUSART_CFG0_TXINV_MASK);
   \       0x9C   0x68B0             LDR      R0,[R6, #+8]
   \       0x9E   0x6929             LDR      R1,[R5, #+16]
   \       0xA0   0x8849             LDRH     R1,[R1, #+2]
   \       0xA2   0xF411 0x41C0      ANDS     R1,R1,#0x6000
   \       0xA6   0x4308             ORRS     R0,R1,R0
   \       0xA8   0x60B0             STR      R0,[R6, #+8]
   1139              eusart->CFG0 |= (uint32_t)init->advancedSettings->msbFirst << _EUSART_CFG0_MSBF_SHIFT;
   \       0xAA   0x68B0             LDR      R0,[R6, #+8]
   \       0xAC   0x6929             LDR      R1,[R5, #+16]
   \       0xAE   0x7949             LDRB     R1,[R1, #+5]
   \       0xB0   0xEA50 0x2081      ORRS     R0,R0,R1, LSL #+10
   \       0xB4   0x60B0             STR      R0,[R6, #+8]
   1140          
   1141              // Configure global configurationTiming register.
   1142              eusart->TIMINGCFG = (eusart->TIMINGCFG & ~(_EUSART_TIMINGCFG_CSSETUP_MASK
   1143                                                         | _EUSART_TIMINGCFG_CSHOLD_MASK
   1144                                                         | _EUSART_TIMINGCFG_ICS_MASK
   1145                                                         | _EUSART_TIMINGCFG_SETUPWINDOW_MASK))
   1146                                  | ((uint32_t)(init->advancedSettings->autoCsSetupTime << _EUSART_TIMINGCFG_CSSETUP_SHIFT)
   1147                                     & _EUSART_TIMINGCFG_CSSETUP_MASK)
   1148                                  | ((uint32_t)(init->advancedSettings->autoCsHoldTime << _EUSART_TIMINGCFG_CSHOLD_SHIFT)
   1149                                     & _EUSART_TIMINGCFG_CSHOLD_MASK)
   1150                                  | ((uint32_t)(init->advancedSettings->autoInterFrameTime << _EUSART_TIMINGCFG_ICS_SHIFT)
   1151                                     & _EUSART_TIMINGCFG_ICS_MASK)
   1152                                  | ((uint32_t)(init->advancedSettings->setupWindow << _EUSART_TIMINGCFG_SETUPWINDOW_SHIFT)
   1153                                     & _EUSART_TIMINGCFG_SETUPWINDOW_MASK)
   1154              ;
   \       0xB6   0x6A70             LDR      R0,[R6, #+36]
   \       0xB8   0x6929             LDR      R1,[R5, #+16]
   \       0xBA   0x7989             LDRB     R1,[R1, #+6]
   \       0xBC   0xF361 0x1006      BFI      R0,R1,#+4,#+3
   \       0xC0   0x6929             LDR      R1,[R5, #+16]
   \       0xC2   0x79C9             LDRB     R1,[R1, #+7]
   \       0xC4   0xF361 0x200A      BFI      R0,R1,#+8,#+3
   \       0xC8   0x6929             LDR      R1,[R5, #+16]
   \       0xCA   0x7A09             LDRB     R1,[R1, #+8]
   \       0xCC   0xF361 0x300E      BFI      R0,R1,#+12,#+3
   \       0xD0   0x6929             LDR      R1,[R5, #+16]
   \       0xD2   0x7F49             LDRB     R1,[R1, #+29]
   \       0xD4   0xF361 0x4013      BFI      R0,R1,#+16,#+4
   \       0xD8   0x6270             STR      R0,[R6, #+36]
   1155            }
   1156          
   1157            // Configure frame format
   1158            eusart->FRAMECFG = (eusart->FRAMECFG & ~(_EUSART_FRAMECFG_DATABITS_MASK))
   1159                               | (uint32_t)(init->databits);
   \                     ??EUSART_SyncInitCommon_2: (+1)
   \       0xDA   0x6971             LDR      R1,[R6, #+20]
   \       0xDC   0x0909             LSRS     R1,R1,#+4
   \       0xDE   0x0109             LSLS     R1,R1,#+4
   \       0xE0   0x7B28             LDRB     R0,[R5, #+12]
   \       0xE2   0x4301             ORRS     R1,R0,R1
   \       0xE4   0x6171             STR      R1,[R6, #+20]
   1160          
   1161            if (advancedSetting_ptr) {
   \       0xE6   0x2C00             CMP      R4,#+0
   \       0xE8   0xD040             BEQ.N    ??EUSART_SyncInitCommon_3
   1162              eusart->DTXDATCFG = (init->advancedSettings->defaultTxData & _EUSART_DTXDATCFG_MASK);
   \       0xEA   0x6928             LDR      R0,[R5, #+16]
   \       0xEC   0x8940             LDRH     R0,[R0, #+10]
   \       0xEE   0x61B0             STR      R0,[R6, #+24]
   1163          
   1164              if (init->advancedSettings->prsRxEnable) {
   \       0xF0   0x6928             LDR      R0,[R5, #+16]
   \       0xF2   0x7B40             LDRB     R0,[R0, #+13]
   \       0xF4   0x2800             CMP      R0,#+0
   \       0xF6   0xD01A             BEQ.N    ??EUSART_SyncInitCommon_4
   1165                //Configure PRS channel as input data line for EUSART.
   1166                if (eusart == EUSART0) {
   \       0xF8   0x....             LDR.N    R0,??DataTable15_16
   \       0xFA   0x4286             CMP      R6,R0
   \       0xFC   0xD105             BNE.N    ??EUSART_SyncInitCommon_5
   1167                  PRS->CONSUMER_EUSART0_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART0_RX_MASK);
   \       0xFE   0x6928             LDR      R0,[R5, #+16]
   \      0x100   0x7B81             LDRB     R1,[R0, #+14]
   \      0x102   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x106   0x....             LDR.N    R0,??DataTable15_17
   \      0x108   0x6001             STR      R1,[R0, #+0]
   1168                }
   1169          #if defined(EUSART1)
   1170                if (eusart == EUSART1) {
   \                     ??EUSART_SyncInitCommon_5: (+1)
   \      0x10A   0x....             LDR.N    R0,??DataTable15_18
   \      0x10C   0x4286             CMP      R6,R0
   \      0x10E   0xD105             BNE.N    ??EUSART_SyncInitCommon_6
   1171                  PRS->CONSUMER_EUSART1_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART1_RX_MASK);
   \      0x110   0x6928             LDR      R0,[R5, #+16]
   \      0x112   0x7B81             LDRB     R1,[R0, #+14]
   \      0x114   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x118   0x....             LDR.N    R0,??DataTable15_19
   \      0x11A   0x6001             STR      R1,[R0, #+0]
   1172                }
   1173          #endif
   1174          #if defined(EUSART2)
   1175                if (eusart == EUSART2) {
   \                     ??EUSART_SyncInitCommon_6: (+1)
   \      0x11C   0x....             LDR.N    R0,??DataTable15_22
   \      0x11E   0x4286             CMP      R6,R0
   \      0x120   0xD105             BNE.N    ??EUSART_SyncInitCommon_4
   1176                  PRS->CONSUMER_EUSART2_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART2_RX_MASK);
   \      0x122   0x6928             LDR      R0,[R5, #+16]
   \      0x124   0x7B81             LDRB     R1,[R0, #+14]
   \      0x126   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x12A   0x....             LDR.N    R0,??DataTable15_20
   \      0x12C   0x6001             STR      R1,[R0, #+0]
   1177                }
   1178          #endif
   1179          #if defined(EUSART3)
   1180                if (eusart == EUSART3) {
   1181                  PRS->CONSUMER_EUSART3_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART3_RX_MASK);
   1182                }
   1183          #endif
   1184          #if defined(EUSART4)
   1185                if (eusart == EUSART4) {
   1186                  PRS->CONSUMER_EUSART4_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART4_RX_MASK);
   1187                }
   1188          #endif
   1189              }
   1190          
   1191              if (init->advancedSettings->prsClockEnable) {
   \                     ??EUSART_SyncInitCommon_4: (+1)
   \      0x12E   0x6928             LDR      R0,[R5, #+16]
   \      0x130   0x7BC0             LDRB     R0,[R0, #+15]
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD01A             BEQ.N    ??EUSART_SyncInitCommon_3
   1192                //Configure PRS channel as SCLK input for EUSART.
   1193                if (eusart == EUSART0) {
   \      0x136   0x....             LDR.N    R0,??DataTable15_16
   \      0x138   0x4286             CMP      R6,R0
   \      0x13A   0xD105             BNE.N    ??EUSART_SyncInitCommon_7
   1194                  PRS->CONSUMER_EUSART0_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART0_CLK_MASK);
   \      0x13C   0x6928             LDR      R0,[R5, #+16]
   \      0x13E   0x7C01             LDRB     R1,[R0, #+16]
   \      0x140   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x144   0x....             LDR.N    R0,??DataTable15_23
   \      0x146   0x6001             STR      R1,[R0, #+0]
   1195                }
   1196          #if defined(EUSART1)
   1197                if (eusart == EUSART1) {
   \                     ??EUSART_SyncInitCommon_7: (+1)
   \      0x148   0x....             LDR.N    R0,??DataTable15_18
   \      0x14A   0x4286             CMP      R6,R0
   \      0x14C   0xD105             BNE.N    ??EUSART_SyncInitCommon_8
   1198                  PRS->CONSUMER_EUSART1_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART1_CLK_MASK);
   \      0x14E   0x6928             LDR      R0,[R5, #+16]
   \      0x150   0x7C01             LDRB     R1,[R0, #+16]
   \      0x152   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x156   0x....             LDR.N    R0,??DataTable15_24
   \      0x158   0x6001             STR      R1,[R0, #+0]
   1199                }
   1200          #endif
   1201          #if defined(EUSART2)
   1202                if (eusart == EUSART2) {
   \                     ??EUSART_SyncInitCommon_8: (+1)
   \      0x15A   0x....             LDR.N    R0,??DataTable15_22
   \      0x15C   0x4286             CMP      R6,R0
   \      0x15E   0xD105             BNE.N    ??EUSART_SyncInitCommon_3
   1203                  PRS->CONSUMER_EUSART2_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART2_CLK_MASK);
   \      0x160   0x6928             LDR      R0,[R5, #+16]
   \      0x162   0x7C00             LDRB     R0,[R0, #+16]
   \      0x164   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x168   0x....             LDR.N    R1,??DataTable15_25
   \      0x16A   0x6008             STR      R0,[R1, #+0]
   1204                }
   1205          #endif
   1206          #if defined(EUSART3)
   1207                if (eusart == EUSART3) {
   1208                  PRS->CONSUMER_EUSART3_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART3_CLK_MASK);
   1209                }
   1210          #endif
   1211          #if defined(EUSART4)
   1212                if (eusart == EUSART4) {
   1213                  PRS->CONSUMER_EUSART4_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART4_CLK_MASK);
   1214                }
   1215          #endif
   1216              }
   1217            }
   1218          
   1219            // Set baudrate for synchronous operation mode.
   1220            EUSART_BaudrateSet(eusart, init->refFreq, init->bitRate);
   \                     ??EUSART_SyncInitCommon_3: (+1)
   \      0x16C   0x68AA             LDR      R2,[R5, #+8]
   \      0x16E   0x6869             LDR      R1,[R5, #+4]
   \      0x170   0x0030             MOVS     R0,R6
   \      0x172   0x.... 0x....      BL       EUSART_BaudrateSet
   1221          
   1222            // Enable EUSART IP.
   1223            EUSART_Enable(eusart, eusartEnable);
   \      0x176   0x2105             MOVS     R1,#+5
   \      0x178   0x0030             MOVS     R0,R6
   \      0x17A   0x.... 0x....      BL       EUSART_Enable
   1224          
   1225            // Finally enable the Rx and/or Tx channel (as specified).
   1226            eusart_sync(eusart, _EUSART_SYNCBUSY_RXEN_MASK | _EUSART_SYNCBUSY_TXEN_MASK); // Wait for low frequency register synchronization.
   \      0x17E   0x2128             MOVS     R1,#+40
   \      0x180   0x0030             MOVS     R0,R6
   \      0x182   0x.... 0x....      BL       eusart_sync
   1227            eusart->CMD = (uint32_t)init->enable;
   \      0x186   0x7828             LDRB     R0,[R5, #+0]
   \      0x188   0x63B0             STR      R0,[R6, #+56]
   1228            eusart_sync(eusart, _EUSART_SYNCBUSY_RXEN_MASK | _EUSART_SYNCBUSY_TXEN_MASK);
   \      0x18A   0x2128             MOVS     R1,#+40
   \      0x18C   0x0030             MOVS     R0,R6
   \      0x18E   0x.... 0x....      BL       eusart_sync
   1229            while (~EUSART_StatusGet(eusart) & (_EUSART_STATUS_RXIDLE_MASK | _EUSART_STATUS_TXIDLE_MASK)) {
   \                     ??EUSART_SyncInitCommon_9: (+1)
   \      0x192   0x0030             MOVS     R0,R6
   \      0x194   0x.... 0x....      BL       EUSART_StatusGet
   \      0x198   0x43C0             MVNS     R0,R0
   \      0x19A   0xF410 0x5F40      TST      R0,#0x3000
   \      0x19E   0xD1F8             BNE.N    ??EUSART_SyncInitCommon_9
   1230            }
   1231          }
   \      0x1A0   0xBD70             POP      {R4-R6,PC}
   1232          #endif
   1233          
   1234          /***************************************************************************//**
   1235           * Calculate baudrate for a given reference frequency, clock division,
   1236           * and oversampling rate when the module is in UART mode.
   1237           *
   1238           * @param refFreq The EUSART reference clock frequency in Hz that will be used.
   1239           * @param clkdiv Clock division factor to be used.
   1240           * @param ovs Oversampling to be used.
   1241           *
   1242           * @return Computed baudrate from given settings.
   1243           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1244          __STATIC_INLINE uint32_t EUSART_AsyncBaudrateCalc(uint32_t refFreq,
   1245                                                            uint32_t clkdiv,
   1246                                                            EUSART_OVS_TypeDef ovs)
   1247          {
   \                     EUSART_AsyncBaudrateCalc: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4692             MOV      R10,R2
   1248            uint32_t oversample;
   1249            uint64_t divisor;
   1250            uint64_t factor;
   1251            uint64_t remainder;
   1252            uint64_t quotient;
   1253            uint32_t br;
   1254          
   1255            // Out of bound clkdiv.
   1256            EFM_ASSERT(clkdiv <= _EUSART_CLKDIV_MASK);
   \        0xA   0x....             LDR.N    R0,??DataTable15_5
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xD201             BCS.N    ??EUSART_AsyncBaudrateCalc_0
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE000             B.N      ??EUSART_AsyncBaudrateCalc_1
   \                     ??EUSART_AsyncBaudrateCalc_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??EUSART_AsyncBaudrateCalc_1: (+1)
   \       0x16   0xB2C0             UXTB     R0,R0
   1257          
   1258            // Mask out unused bits
   1259            clkdiv &= _EUSART_CLKDIV_MASK;
   \       0x18   0x....             LDR.N    R0,??DataTable15_6
   \       0x1A   0x4001             ANDS     R1,R0,R1
   \       0x1C   0x9102             STR      R1,[SP, #+8]
   1260          
   1261            /* Use integer division to avoid forcing in float division
   1262             * utils and yet keep rounding effect errors to a minimum.
   1263             *
   1264             * Baudrate in is given by:
   1265             *
   1266             * br = fUARTn/(oversample * (1 + (CLKDIV / 256)))
   1267             * or
   1268             * br = (256 * fUARTn)/(oversample * (256 + CLKDIV))
   1269             *
   1270             * 256 factor of the dividend is reduced with a
   1271             * (part of) oversample part of the divisor.
   1272             */
   1273          
   1274            switch (ovs) {
   \       0x1E   0x4650             MOV      R0,R10
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD008             BEQ.N    ??EUSART_AsyncBaudrateCalc_2
   \       0x26   0x2820             CMP      R0,#+32
   \       0x28   0xD00C             BEQ.N    ??EUSART_AsyncBaudrateCalc_3
   \       0x2A   0x2840             CMP      R0,#+64
   \       0x2C   0xD010             BEQ.N    ??EUSART_AsyncBaudrateCalc_4
   \       0x2E   0x2860             CMP      R0,#+96
   \       0x30   0xD014             BEQ.N    ??EUSART_AsyncBaudrateCalc_5
   \       0x32   0x2880             CMP      R0,#+128
   \       0x34   0xD018             BEQ.N    ??EUSART_AsyncBaudrateCalc_6
   \       0x36   0xE01D             B.N      ??EUSART_AsyncBaudrateCalc_7
   1275              case eusartOVS16:
   1276                oversample = 1;
   \                     ??EUSART_AsyncBaudrateCalc_2: (+1)
   \       0x38   0x2501             MOVS     R5,#+1
   1277                factor = 256 / 16;
   \       0x3A   0xF05F 0x0810      MOVS     R8,#+16
   \       0x3E   0xF05F 0x0900      MOVS     R9,#+0
   1278                break;
   \       0x42   0xE019             B.N      ??EUSART_AsyncBaudrateCalc_8
   1279          
   1280              case eusartOVS8:
   1281                oversample = 1;
   \                     ??EUSART_AsyncBaudrateCalc_3: (+1)
   \       0x44   0x2501             MOVS     R5,#+1
   1282                factor = 256 / 8;
   \       0x46   0xF05F 0x0820      MOVS     R8,#+32
   \       0x4A   0xF05F 0x0900      MOVS     R9,#+0
   1283                break;
   \       0x4E   0xE013             B.N      ??EUSART_AsyncBaudrateCalc_8
   1284          
   1285              case eusartOVS6:
   1286                oversample = 3;
   \                     ??EUSART_AsyncBaudrateCalc_4: (+1)
   \       0x50   0x2503             MOVS     R5,#+3
   1287                factor = 256 / 2;
   \       0x52   0xF05F 0x0880      MOVS     R8,#+128
   \       0x56   0xF05F 0x0900      MOVS     R9,#+0
   1288                break;
   \       0x5A   0xE00D             B.N      ??EUSART_AsyncBaudrateCalc_8
   1289          
   1290              case eusartOVS4:
   1291                oversample = 1;
   \                     ??EUSART_AsyncBaudrateCalc_5: (+1)
   \       0x5C   0x2501             MOVS     R5,#+1
   1292                factor = 256 / 4;
   \       0x5E   0xF05F 0x0840      MOVS     R8,#+64
   \       0x62   0xF05F 0x0900      MOVS     R9,#+0
   1293                break;
   \       0x66   0xE007             B.N      ??EUSART_AsyncBaudrateCalc_8
   1294          
   1295              case eusartOVS0:
   1296                oversample = 1;
   \                     ??EUSART_AsyncBaudrateCalc_6: (+1)
   \       0x68   0x2501             MOVS     R5,#+1
   1297                factor = 256;
   \       0x6A   0xF44F 0x7880      MOV      R8,#+256
   \       0x6E   0xF05F 0x0900      MOVS     R9,#+0
   1298                break;
   \       0x72   0xE001             B.N      ??EUSART_AsyncBaudrateCalc_8
   1299          
   1300              default:
   1301                return 0u;
   \                     ??EUSART_AsyncBaudrateCalc_7: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xE028             B.N      ??EUSART_AsyncBaudrateCalc_9
   1302                break;
   1303            }
   1304          
   1305            /*
   1306             * The basic problem with integer division in the above formula is that
   1307             * the dividend (factor * fUARTn) may become larger than a 32 bit
   1308             * integer. Yet we want to evaluate the dividend first before dividing
   1309             * to get as small rounding effects as possible. Too harsh restrictions
   1310             * should not be made on the maximum fUARTn value either.
   1311             *
   1312             * For division a/b,
   1313             *
   1314             * a = qb + r
   1315             *
   1316             * where q is the quotient and r is the remainder, both integers.
   1317             *
   1318             * The original baudrate formula can be rewritten as
   1319             *
   1320             * br = xa / b = x(qb + r)/b = xq + xr/b
   1321             *
   1322             * where x is 'factor', a is 'refFreq' and b is 'divisor', referring to
   1323             * variable names.
   1324             */
   1325          
   1326            /*
   1327             * The divisor will never exceed max 32 bit value since
   1328             * clkdiv <= _EUSART_CLKDIV_MASK (currently 0x7FFFF8)
   1329             * and 'oversample' has been reduced to <= 3.
   1330             */
   1331            divisor = (uint64_t)(oversample * (256 + clkdiv));
   \                     ??EUSART_AsyncBaudrateCalc_8: (+1)
   \       0x78   0x9802             LDR      R0,[SP, #+8]
   \       0x7A   0xF510 0x7080      ADDS     R0,R0,#+256
   \       0x7E   0xFB00 0xF005      MUL      R0,R0,R5
   \       0x82   0x2100             MOVS     R1,#+0
   \       0x84   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   1332          
   1333            quotient = refFreq / divisor;
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x2100             MOVS     R1,#+0
   \       0x8C   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \       0x90   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x94   0x0006             MOVS     R6,R0
   \       0x96   0x000F             MOVS     R7,R1
   1334            remainder = refFreq % divisor;
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \       0xA0   0x.... 0x....      BL       __aeabi_uldivmod
   \       0xA4   0xE9CD 0x2304      STRD     R2,R3,[SP, #+16]
   1335          
   1336            // The factor <= 128 and since divisor >= 256, the below cannot exceed the maximum
   1337            // 32 bit value. However, factor * remainder can become larger than 32-bit
   1338            // because of the size of _EUSART_CLKDIV_DIV_MASK on some families.
   1339            br = (uint32_t) (factor * quotient);
   \       0xA8   0x46B3             MOV      R11,R6
   \       0xAA   0xFB0B 0xFB08      MUL      R11,R11,R8
   1340          
   1341            /*
   1342             * The factor <= 128 and remainder < (oversample*(256 + clkdiv)), which
   1343             * means dividend (factor * remainder) worst case is
   1344             * 128 * (3 * (256 + _EUSART_CLKDIV_MASK)) = 0xC001_7400.
   1345             */
   1346            br += (uint32_t) ((factor * remainder) / divisor);
   \       0xAE   0xE9DD 0x2304      LDRD     R2,R3,[SP, #+16]
   \       0xB2   0xFBA2 0x0108      UMULL    R0,R1,R2,R8
   \       0xB6   0xFB02 0x1109      MLA      R1,R2,R9,R1
   \       0xBA   0xFB03 0x1108      MLA      R1,R3,R8,R1
   \       0xBE   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \       0xC2   0x.... 0x....      BL       __aeabi_uldivmod
   \       0xC6   0xEB10 0x000B      ADDS     R0,R0,R11
   1347          
   1348            return br;
   \                     ??EUSART_AsyncBaudrateCalc_9: (+1)
   \       0xCA   0xB007             ADD      SP,SP,#+28
   \       0xCC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1349          }
   1350          
   1351          /***************************************************************************//**
   1352           * Perform EUSART Module disablement - resetting all internal flops/FSM.
   1353           *
   1354           * @param eusart Pointer to the EUSART peripheral register block.
   1355           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1356          __STATIC_INLINE void EUSART_Disable(EUSART_TypeDef *eusart)
   1357          {
   \                     EUSART_Disable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1358            if (eusart->EN & _EUSART_EN_EN_MASK) {
   \        0x4   0x6860             LDR      R0,[R4, #+4]
   \        0x6   0x07C0             LSLS     R0,R0,#+31
   \        0x8   0xD516             BPL.N    ??EUSART_Disable_0
   1359              // This step should be skipped especially in Synchronous Slave mode when
   1360              // external SCLK is not running and CS is active
   1361          #if defined(EUSART_PRESENT)
   1362              if (!(eusart->CFG0 & _EUSART_CFG0_SYNC_MASK) || (eusart->CFG2 & _EUSART_CFG2_MASTER_MASK))
   \        0xA   0x68A0             LDR      R0,[R4, #+8]
   \        0xC   0x07C0             LSLS     R0,R0,#+31
   \        0xE   0xD502             BPL.N    ??EUSART_Disable_1
   \       0x10   0x6920             LDR      R0,[R4, #+16]
   \       0x12   0x07C0             LSLS     R0,R0,#+31
   \       0x14   0xD509             BPL.N    ??EUSART_Disable_2
   1363          #endif
   1364              {
   1365                // General Programming Guideline to properly disable the module:
   1366                // 1a. Disable TX and RX using TXDIS and RXDIS cmd
   1367                eusart->CMD = EUSART_CMD_TXDIS | EUSART_CMD_RXDIS;
   \                     ??EUSART_Disable_1: (+1)
   \       0x16   0x200A             MOVS     R0,#+10
   \       0x18   0x63A0             STR      R0,[R4, #+56]
   1368                // 1b. Poll for EUSARTn_SYNCBUSY.TXDIS and EUSARTn_SYNCBUSY.RXDIS to go low;
   1369                eusart_sync(eusart, (EUSART_SYNCBUSY_TXDIS | EUSART_SYNCBUSY_RXDIS));
   \       0x1A   0x2150             MOVS     R1,#+80
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       eusart_sync
   1370                // 1c. Wait for EUSARTn_STATUS.TXENS and EUSARTn_STATUS.RXENS to go low
   1371                while (eusart->STATUS & (_EUSART_STATUS_TXENS_MASK | _EUSART_STATUS_RXENS_MASK)) {
   \                     ??EUSART_Disable_3: (+1)
   \       0x22   0x6CA0             LDR      R0,[R4, #+72]
   \       0x24   0xF010 0x0F03      TST      R0,#0x3
   \       0x28   0xD1FB             BNE.N    ??EUSART_Disable_3
   1372                }
   1373              }
   1374          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1375              eusart->CLKDIV = eusart->CLKDIV;
   1376              eusart_sync(eusart, _EUSART_SYNCBUSY_DIV_MASK);
   1377          
   1378              // Read data until FIFO is emptied
   1379              // but taking care not to underflow the receiver
   1380              while (eusart->STATUS & EUSART_STATUS_RXFL) {
   1381                eusart->RXDATA;
   1382              }
   1383          #endif
   1384          
   1385              eusart->EN_CLR = EUSART_EN_EN;
   \                     ??EUSART_Disable_2: (+1)
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0xF242 0x0004      MOVW     R0,#+8196
   \       0x30   0x5021             STR      R1,[R4, R0]
   1386          
   1387          #if defined(_EUSART_EN_DISABLING_MASK)
   1388              // 2. Polling for EUSARTn_EN.DISABLING = 0.
   1389              while (eusart->EN & _EUSART_EN_DISABLING_MASK) {
   \                     ??EUSART_Disable_4: (+1)
   \       0x32   0x6860             LDR      R0,[R4, #+4]
   \       0x34   0x0780             LSLS     R0,R0,#+30
   \       0x36   0xD4FC             BMI.N    ??EUSART_Disable_4
   1390              }
   1391          #endif
   1392            }
   1393          }
   \                     ??EUSART_Disable_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x5B01'0000        DC32     0x5b010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x500A'0000        DC32     0x500a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x500A'4000        DC32     0x500a4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0011'9401        DC32     0x119401

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x0131'2D01        DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x0098'9681        DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x004C'4B40        DC32     0x4c4b40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x030D'3FFF        DC32     0x30d3fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x007F'FFF9        DC32     0x7ffff9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x007F'FFF8        DC32     0x7ffff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0x5003'8068        DC32     0x50038068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0x5003'8074        DC32     0x50038074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0x5003'8080        DC32     0x50038080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0xFFFF'CCF0        DC32     0xffffccf0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0xBFFF'FF1D        DC32     0xbfffff1d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0xFFBD'9BE3        DC32     0xffbd9be3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0x87F0'F9FF        DC32     0x87f0f9ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0x5003'D4C4        DC32     0x5003d4c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0x5003'E4C4        DC32     0x5003e4c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \        0x0   0x5B01'0000        DC32     0x5b010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \        0x0   0x5003'9064        DC32     0x50039064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \        0x0   0x500A'0000        DC32     0x500a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \        0x0   0x5003'9070        DC32     0x50039070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \        0x0   0x5003'907C        DC32     0x5003907c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \        0x0   0x87F0'FFFF        DC32     0x87f0ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \        0x0   0x500A'4000        DC32     0x500a4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \        0x0   0x5003'9060        DC32     0x50039060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \        0x0   0x5003'906C        DC32     0x5003906c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \        0x0   0x5003'9078        DC32     0x50039078
   1394          
   1395          #endif /* defined(EUART_PRESENT) || defined(EUSART_PRESENT) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   EUSART_AsyncBaudrateCalc
        64 __aeabi_uldivmod
      24   EUSART_AsyncInitCommon
        24   -> EUSART_BaudrateSet
        24   -> EUSART_Enable
        24   -> EUSART_Reset
        24   -> EUSART_StatusGet
        24   -> eusart_sync
      32   EUSART_BaudrateGet
        32   -> CMU_ClockFreqGet
        32   -> EUSART_AsyncBaudrateCalc
        32   -> EUSART_ClockGet
      32   EUSART_BaudrateSet
        32   -> CMU_ClockFreqGet
        32   -> EUSART_ClockGet
        32   -> EUSART_Disable
        32   -> EUSART_Enable
        32   -> eusart_sync
       0   EUSART_ClockGet
       8   EUSART_Disable
         8   -> eusart_sync
      24   EUSART_Enable
        24   -> EUSART_Disable
        24   -> eusart_sync
      16   EUSART_IrDAInit
        16   -> EUSART_AsyncInitCommon
      24   EUSART_PrsTriggerEnable
        24   -> eusart_sync
       8   EUSART_Reset
         8   -> EUSART_Disable
       0   EUSART_Rx
      16   EUSART_RxBlock
        16   -> eusart_sync
       0   EUSART_RxExt
      16   EUSART_SpiInit
        16   -> EUSART_SyncInitCommon
       0   EUSART_Spi_TxRx
       0   EUSART_StatusGet
      16   EUSART_SyncInitCommon
        16   -> EUSART_BaudrateSet
        16   -> EUSART_Enable
        16   -> EUSART_Reset
        16   -> EUSART_StatusGet
        16   -> eusart_sync
       0   EUSART_Tx
       0   EUSART_TxExt
      16   EUSART_TxTristateSet
        16   -> eusart_sync
      16   EUSART_UartInitHf
        16   -> EUSART_AsyncInitCommon
      16   EUSART_UartInitLf
        16   -> EUSART_AsyncInitCommon
       0   eusart_sync


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
     208  EUSART_AsyncBaudrateCalc
     552  EUSART_AsyncInitCommon
     130  EUSART_BaudrateGet
     466  EUSART_BaudrateSet
      38  EUSART_ClockGet
      58  EUSART_Disable
     146  EUSART_Enable
     338  EUSART_IrDAInit
     164  EUSART_PrsTriggerEnable
     106  EUSART_Reset
      44  EUSART_Rx
     116  EUSART_RxBlock
      12  EUSART_RxExt
     184  EUSART_SpiInit
      24  EUSART_Spi_TxRx
       4  EUSART_StatusGet
     418  EUSART_SyncInitCommon
      14  EUSART_Tx
      14  EUSART_TxExt
     112  EUSART_TxTristateSet
     102  EUSART_UartInitHf
     308  EUSART_UartInitLf
       8  eusart_sync

 
 3'682 bytes in section .text
 
 3'682 bytes of CODE memory

Errors: none
Warnings: none
