###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         26/Nov/2024  12:15:50
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\ProAppSrc\Util\buffer_manager\buff_mgmt.c
#    Command line                 =
#        -f
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir\buff_mgmt.o.rsp
#        (C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\ProAppSrc\Util\buffer_manager\buff_mgmt.c
#        -D EFR32FG23A020F512GM40=1 -D SL_COMPONENT_CATALOG_PRESENT=1 -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -lC
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\Util_9809783495009140069.dir
#        --diag_suppress Pa050 -o
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse -e --fpu=VFPv5_sp --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\.\ -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\AppConfigs\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\autogen\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\HAL\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\NVM\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\buffer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\event_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\list_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\queue_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\timer_manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\hif\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\raw_uart_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\Util\debug_console\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\Device\SiliconLabs\EFR32FG23\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\device_init\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\mpu\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\common\toolchain\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\system\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\network-manager\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\RAIL_TRX\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MAC\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\wisun_modified\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\ProAppSrc\FANApp\AppInc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_callbacks\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ip\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\multicast\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\ipv6\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\rpl\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\OS_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\L3\L2_L3_interface\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\cpu\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\contiki_mac_interface_layer\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\Interface_Layer\mac_sicslowpan_if\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emlib\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\os\platform\p3_lp_dk\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\common\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\efr32xg1x\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_protocol\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_rssi\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\PHY\radio\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\MeterApp\Inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\SiliconLabs\platform\emdrv\common\inc\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\FLASH\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\APP_LOG\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\config\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\DebugLog\response_print\
#        -I
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\..\NVM\nvm3\inc\
#        -On --use_c++_inline) --dependencies=n
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir\buff_mgmt.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\lst\Util_9809783495009140069.dir\buff_mgmt.lst
#    Object file                  =
#        C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir\buff_mgmt.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\PHYTEC\Desktop\custom-FG23\MeshApp_FG23_Node\ProAppSrc\Util\buffer_manager\buff_mgmt.c
      1          /** \file buff_mgmt.c
      2           **
      3           ** \brief Implements the buffer management module
      4           **
      5           ** \cond STD_FILE_HEADER
      6           **
      7           ** COPYRIGHT(c) 2023-24 Procubed Innovations Pvt Ltd.
      8           ** All rights reserved.
      9           **
     10           ** THIS SOFTWARE IS PROVIDED BY "AS IS" AND ALL WARRANTIES OF ANY KIND,
     11           ** INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR USE,
     12           ** ARE EXPRESSLY DISCLAIMED.  THE DEVELOPER SHALL NOT BE LIABLE FOR ANY
     13           ** DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. THIS SOFTWARE
     14           ** MAY NOT BE USED IN PRODUCTS INTENDED FOR USE IN IMPLANTATION OR OTHER
     15           ** DIRECT LIFE SUPPORT APPLICATIONS WHERE MALFUNCTION MAY RESULT IN THE DIRECT
     16           ** PHYSICAL HARM OR INJURY TO PERSONS. ALL SUCH IS USE IS EXPRESSLY PROHIBITED.
     17           **
     18           *******************************************************************************
     19           **  \endcond
     20           */
     21          
     22          /*
     23          ********************************************************************************
     24          * File inclusion
     25          ********************************************************************************
     26          */
     27          
     28          #include "StackPHYConf.h"
     29          #include "common.h"
     30          #include "queue_latest.h"
     31          #include "buff_mgmt.h"
     32          #include "buffer_service.h"
     33          
     34          //#define BUFFER_CORRUPTION_TEST
     35          
     36          /*
     37          ** =============================================================================
     38          ** Private Macro definitions
     39          ** =============================================================================
     40          */
     41          	
     42          /*
     43           *******************************************************************************
     44           * @brief macro defining the Magic number.
     45           *    Macro indicating that a buffer is free.
     46           *
     47           *******************************************************************************
     48          */
     49          
     50          #define BUF_MEM_MAGIC_NUM_FREE 0x3355
     51          
     52          /*
     53           *******************************************************************************
     54           * @brief macro defining the Magic number.
     55           *   Macro indicating that a buffer is in use.
     56           *
     57           *******************************************************************************
     58          */
     59          
     60          #define BUF_MEM_MAGIC_NUM_USE  0xCCAA
     61          
     62          /*
     63          ** =============================================================================
     64          ** Private Structures, Unions & enums Type Definitions
     65          ** =============================================================================
     66          **/
     67          
     68          /**
     69           *******************************************************************************
     70           * @brief Buffer management link structure.
     71           *    Structure to configure the Memory Pool.
     72           ******************************************************************************/
     73          
     74          typedef struct buf_s
     75          {
     76          #if defined (BM_DEBUG_LEVEL_1) || defined (BM_DEBUG_LEVEL_2)
     77              uint16_t  magic_num; /**<0x33 for free, 0xAA for used */
     78              uint16_t  line_num; /**< It stores the Line number of the last operation 
     79          						      done with the buffer*/
     80          #if defined (BM_DEBUG_LEVEL_2)
     81              uint16_t  pFunc_name; /**< pointer to a string where the function name
     82                                               is stored. */
     83          #endif
     84          #endif
     85              queue_item_t * pNext; /**< pointer to link to next buffer */
     86          }buf_t;
     87          
     88          
     89          typedef struct debug_heap_tag
     90          {
     91            uint32_t typesOfBuffs;
     92            pool_t pools[TYPES_OF_BUFF];  //Debdeep
     93          }debug_heap_t;
     94          
     95          /*
     96          ** =============================================================================
     97          ** Private Variable Definitions
     98          ** =============================================================================
     99          */
    100          

   \                                 In section .bss, align 4
    101          static debug_heap_t* p_debug_heap = NULL; 
   \                     p_debug_heap:
   \        0x0                      DS8 4
    102          
    103          /*
    104          ** =============================================================================
    105          ** Private Function Prototypes
    106          ** =============================================================================
    107          */
    108          
    109          /* None */
    110          
    111          /*
    112          ** =============================================================================
    113          ** External Variable Declarations
    114          ** =============================================================================
    115          */
    116          
    117          /* None */
    118          
    119          /*
    120          ** =============================================================================
    121          ** External Function Prototypes
    122          ** =============================================================================
    123          */
    124          
    125          /* None */
    126          
    127          /*
    128          ** =============================================================================
    129          ** Public Variables Definitions
    130          ** =============================================================================
    131          **/
    132          
    133          /* None */
    134          
    135          /*
    136          ** =============================================================================
    137          ** Public Function Prototypes
    138          ** =============================================================================
    139          */
    140          
    141          /* None */
    142          
    143          /*
    144          ** =============================================================================
    145          ** Public Function Definitions
    146          ** =============================================================================
    147          */
    148          

   \                                 In section .text, align 2, keep-with-next
    149          bool bm_init(
    150              uint32_t heap_size,
    151              uint8_t *pHeap,
    152              uint32_t num_of_types,
    153              buf_mem_pool_t *pbuf_cfg
    154              )
    155          {
   \                     bm_init: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001C             MOVS     R4,R3
    156              uint32_t i = 0, j  = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x2500             MOVS     R5,#+0
    157              p_debug_heap = (debug_heap_t*)pHeap;
   \        0xE   0x....             LDR.N    R1,??DataTable1
   \       0x10   0x9A04             LDR      R2,[SP, #+16]
   \       0x12   0x600A             STR      R2,[R1, #+0]
    158              uint32_t *pBuffTypes = (uint32_t*)(p_debug_heap);//( uint16_t* )pHeap;
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0x9202             STR      R2,[SP, #+8]
    159              
    160              pool_t *pPool = &(p_debug_heap->pools[0]);//( pool_t * )&pBuffTypes[1];
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   \       0x1A   0x1D09             ADDS     R1,R1,#+4
   \       0x1C   0x9100             STR      R1,[SP, #+0]
    161              queue_t *pQueue = NULL;
   \       0x1E   0xF05F 0x0800      MOVS     R8,#+0
    162              queue_item_t *pItem = NULL;
   \       0x22   0x2100             MOVS     R1,#+0
    163              /* Check the heap size is enough or not */
    164              uint32_t req_size, heap_header_size = sizeof(uint32_t) + 
    165                  ( sizeof( pool_t ))* ( num_of_types );
   \       0x24   0x2714             MOVS     R7,#+20
   \       0x26   0xFB07 0xF306      MUL      R3,R7,R6
   \       0x2A   0x1D1B             ADDS     R3,R3,#+4
    166              
    167              //Use i for aligning
    168              i = sizeof( uint32_t ) - 1;
   \       0x2C   0x2203             MOVS     R2,#+3
    169              heap_header_size = ( heap_header_size + i ) & ( ~i );
   \       0x2E   0x18D3             ADDS     R3,R2,R3
   \       0x30   0x4393             BICS     R3,R3,R2
   \       0x32   0x9301             STR      R3,[SP, #+4]
    170          
    171              req_size = heap_header_size;
   \       0x34   0xF8DD 0x9004      LDR      R9,[SP, #+4]
    172          
    173              for( i = 0; i < num_of_types; i++ )
   \       0x38   0x2300             MOVS     R3,#+0
   \                     ??bm_init_0: (+1)
   \       0x3A   0x42B3             CMP      R3,R6
   \       0x3C   0xD209             BCS.N    ??bm_init_1
    174              {
    175                  req_size += ( sizeof(buf_t) + pbuf_cfg[ i ].buf_size ) * 
    176                      pbuf_cfg[ i ].num_of_buf;
   \       0x3E   0xF834 0x2023      LDRH     R2,[R4, R3, LSL #+2]
   \       0x42   0x1D12             ADDS     R2,R2,#+4
   \       0x44   0xEB04 0x0083      ADD      R0,R4,R3, LSL #+2
   \       0x48   0x8840             LDRH     R0,[R0, #+2]
   \       0x4A   0xFB00 0x9902      MLA      R9,R0,R2,R9
    177              }
   \       0x4E   0x1C5B             ADDS     R3,R3,#+1
   \       0x50   0xE7F3             B.N      ??bm_init_0
    178              
    179              if( heap_size < req_size ) 
   \                     ??bm_init_1: (+1)
   \       0x52   0x9803             LDR      R0,[SP, #+12]
   \       0x54   0x4548             CMP      R0,R9
   \       0x56   0xD201             BCS.N    ??bm_init_2
    180                return FALSE;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xE054             B.N      ??bm_init_3
    181          
    182              /* Initialize the heap */
    183              /* Update the number of types */
    184              pBuffTypes[0] = num_of_types;
   \                     ??bm_init_2: (+1)
   \       0x5C   0x9802             LDR      R0,[SP, #+8]
   \       0x5E   0x6006             STR      R6,[R0, #+0]
    185              /* Update the offset of each buffer pool */
    186              pPool[0].offset = heap_header_size;
   \       0x60   0x9A01             LDR      R2,[SP, #+4]
   \       0x62   0x9800             LDR      R0,[SP, #+0]
   \       0x64   0x6002             STR      R2,[R0, #+0]
    187              pPool[0].size = pbuf_cfg[ 0 ].buf_size;
   \       0x66   0x8822             LDRH     R2,[R4, #+0]
   \       0x68   0x9800             LDR      R0,[SP, #+0]
   \       0x6A   0x8082             STRH     R2,[R0, #+4]
    188              for( i = 1; i < num_of_types; i++ )
   \       0x6C   0x2201             MOVS     R2,#+1
   \                     ??bm_init_4: (+1)
   \       0x6E   0x42B2             CMP      R2,R6
   \       0x70   0xD221             BCS.N    ??bm_init_5
    189              {
    190                  pPool[i].offset = pPool[i-1].offset + 
    191                      ( sizeof(buf_t) + pbuf_cfg[ i - 1 ].buf_size ) * 
    192                          pbuf_cfg[ i - 1 ].num_of_buf;
   \       0x72   0x9B00             LDR      R3,[SP, #+0]
   \       0x74   0xFB07 0xF002      MUL      R0,R7,R2
   \       0x78   0x4418             ADD      R0,R3,R0
   \       0x7A   0xF850 0x3C14      LDR      R3,[R0, #-20]
   \       0x7E   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \       0x82   0xF830 0xCC04      LDRH     R12,[R0, #-4]
   \       0x86   0xF11C 0x0C04      ADDS     R12,R12,#+4
   \       0x8A   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \       0x8E   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \       0x92   0xFB00 0x330C      MLA      R3,R0,R12,R3
   \       0x96   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0x9A   0xFB07 0xF002      MUL      R0,R7,R2
   \       0x9E   0xF84C 0x3000      STR      R3,[R12, R0]
    193                  pPool[i].size = pbuf_cfg[ i ].buf_size;
   \       0xA2   0xF834 0x0022      LDRH     R0,[R4, R2, LSL #+2]
   \       0xA6   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0xAA   0xFB07 0xF302      MUL      R3,R7,R2
   \       0xAE   0x4463             ADD      R3,R12,R3
   \       0xB0   0x8098             STRH     R0,[R3, #+4]
    194              }
   \       0xB2   0x1C52             ADDS     R2,R2,#+1
   \       0xB4   0xE7DB             B.N      ??bm_init_4
    195              /* Initialize the queues */
    196              
    197              pItem = ( queue_item_t* )( pHeap + pPool[0].offset );
   \                     ??bm_init_5: (+1)
   \       0xB6   0x9804             LDR      R0,[SP, #+16]
   \       0xB8   0x9B00             LDR      R3,[SP, #+0]
   \       0xBA   0x681B             LDR      R3,[R3, #+0]
   \       0xBC   0xEB00 0x0B03      ADD      R11,R0,R3
    198              for( i = 0; i < num_of_types ; i++ )
   \       0xC0   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??bm_init_6: (+1)
   \       0xC4   0x45B2             CMP      R10,R6
   \       0xC6   0xD21D             BCS.N    ??bm_init_7
    199              {
    200                  pQueue = &pPool[ i ].q;
   \       0xC8   0x9800             LDR      R0,[SP, #+0]
   \       0xCA   0xFB07 0xF10A      MUL      R1,R7,R10
   \       0xCE   0x4408             ADD      R0,R0,R1
   \       0xD0   0x3008             ADDS     R0,R0,#+8
   \       0xD2   0x4680             MOV      R8,R0
    201                  //Initialize the free queue
    202                  queue_initialise( pQueue );
   \       0xD4   0x4640             MOV      R0,R8
   \       0xD6   0x.... 0x....      BL       queue_initialise
    203                  
    204                  for( j =0 ; j < pbuf_cfg[ i ].num_of_buf; j++ )
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x0005             MOVS     R5,R0
   \                     ??bm_init_8: (+1)
   \       0xDE   0xEB04 0x008A      ADD      R0,R4,R10, LSL #+2
   \       0xE2   0x8840             LDRH     R0,[R0, #+2]
   \       0xE4   0x4285             CMP      R5,R0
   \       0xE6   0xD20A             BCS.N    ??bm_init_9
    205                  {
    206                      //Put all the item into free list
    207                      queue_item_put( pQueue, pItem );
   \       0xE8   0x4659             MOV      R1,R11
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0x.... 0x....      BL       queue_item_put
    208          #if defined (BM_DEBUG_LEVEL_1) || defined (BM_DEBUG_LEVEL_2)
    209                      {
    210                          buf_t *pBuf = ( buf_t* )pItem;
    211                          pBuf->magic_num = BUF_MEM_MAGIC_NUM_FREE;
    212                      }
    213          #endif
    214                      pItem = ( queue_item_t* )(( uint8_t* )pItem + sizeof( buf_t ) + 
    215                          pbuf_cfg[ i ].buf_size );
   \       0xF0   0xF834 0x002A      LDRH     R0,[R4, R10, LSL #+2]
   \       0xF4   0x4458             ADD      R0,R11,R0
   \       0xF6   0xF110 0x0B04      ADDS     R11,R0,#+4
    216                  }        
   \       0xFA   0x1C6D             ADDS     R5,R5,#+1
   \       0xFC   0xE7EF             B.N      ??bm_init_8
    217              }
   \                     ??bm_init_9: (+1)
   \       0xFE   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \      0x102   0xE7DF             B.N      ??bm_init_6
    218              
    219             
    220              return TRUE;
   \                     ??bm_init_7: (+1)
   \      0x104   0x2001             MOVS     R0,#+1
   \                     ??bm_init_3: (+1)
   \      0x106   0xB005             ADD      SP,SP,#+20
   \      0x108   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    221          }
    222          
    223          /*----------------------------------------------------------------------------*/
    224          
    225          #ifdef BUFFER_CORRUPTION_TEST
    226          
    227          #define NUMBER_OF_TEST_BUFFER           10
    228          #define BUFFER_SIZE                     1920
    229          #define TEST_BUFF_OFFSET                51812
    230          #define NEXT_TO_TEST_BUFF_OFFSET        99812
    231          
    232          struct Track_64_buff
    233          {
    234            uint32_t alloc[NUMBER_OF_TEST_BUFFER];
    235            uint32_t free[NUMBER_OF_TEST_BUFFER];
    236            uint32_t alloc_index;
    237            uint8_t alloc_loop;
    238            uint32_t free_index;
    239            uint8_t free_loop;
    240          };
    241          struct Track_64_buff track_64_buff;
    242          uint8_t present_in_alloc_buf (uint32_t mem)
    243          {
    244            int ii;
    245            
    246            for (ii = 0; ii < NUMBER_OF_TEST_BUFFER; ii++)
    247            {
    248              if (track_64_buff.alloc[ii] == mem)
    249              {
    250                track_64_buff.alloc[ii] = 0;
    251                return 1;
    252              }
    253            }  
    254            return 0;
    255          }
    256                                           
    257          void sort_alloc_array (void)
    258          {
    259           int ii;
    260           track_64_buff.alloc_index = 0;
    261           for(ii = 0; ii < NUMBER_OF_TEST_BUFFER; ii++)
    262           {
    263             if (track_64_buff.alloc[ii] != 0)
    264             {
    265               if (track_64_buff.alloc_index != ii)
    266               {
    267                 track_64_buff.alloc[track_64_buff.alloc_index] = track_64_buff.alloc[ii];
    268                 track_64_buff.alloc[ii] = 0;
    269               }
    270               track_64_buff.alloc_index++;
    271             }
    272           }
    273          }
    274          #endif  //BUFFER_CORRUPTION_TEST
    275          

   \                                 In section .bss, align 4
    276          uint32_t bigger_buff_alloc_count;
   \                     bigger_buff_alloc_count:
   \        0x0                      DS8 4
    277          
    278          
    279          #if defined BM_DEBUG_LEVEL_1
    280          void bm_alloc(
    281              uint8_t *pHeap,
    282              uint16_t length,
    283              uint16_t line_num
    284              )
    285          
    286          #elif defined BM_DEBUG_LEVEL_2
    287          void bm_alloc(
    288              uint8_t *pHeap,
    289              uint16_t length,
    290              uint16_t line_num,
    291              uint8_t *pFunc_name
    292              )
    293          #else

   \                                 In section .text, align 2, keep-with-next
    294          void * bm_alloc(
    295              uint8_t *pHeap,
    296              uint16_t length//uint16_t length       
    297              )
    298          #endif
    299          {
   \                     bm_alloc: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x000C             MOVS     R4,R1
    300            uint32_t *pBufTypes = ( uint32_t* )pHeap;
   \        0x8   0x4655             MOV      R5,R10
    301            uint32_t i = 0;
   \        0xA   0x2100             MOVS     R1,#+0
    302            pool_t *pPool = ( pool_t * )&pBufTypes[1];    
   \        0xC   0x1D2E             ADDS     R6,R5,#+4
    303            uint8_t *pMem = NULL;
   \        0xE   0x2700             MOVS     R7,#+0
    304            
    305            if ( !length)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??bm_alloc_0
    306            {
    307              return NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE052             B.N      ??bm_alloc_1
    308            }
    309            
    310            for( i = 0; i < *pBufTypes; i++ )
   \                     ??bm_alloc_0: (+1)
   \       0x1C   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??bm_alloc_2: (+1)
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x4580             CMP      R8,R0
   \       0x24   0xD24C             BCS.N    ??bm_alloc_3
    311            {
    312              /*Check if the requested buffer size is well within the limit of the 
    313              buffer type available AND there are buffers available in that pool*/  
    314              if ((length <= pPool[ i ].size ) && queue_count_get( &pPool[ i ].q )
    315                  && (pPool[ i ].q.start != NULL))
   \       0x26   0xF05F 0x0914      MOVS     R9,#+20
   \       0x2A   0xFB09 0xF008      MUL      R0,R9,R8
   \       0x2E   0x4430             ADD      R0,R6,R0
   \       0x30   0x8881             LDRH     R1,[R0, #+4]
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0xB280             UXTH     R0,R0
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD33F             BCC.N    ??bm_alloc_4
   \       0x3A   0xFB09 0xF008      MUL      R0,R9,R8
   \       0x3E   0x4430             ADD      R0,R6,R0
   \       0x40   0x3008             ADDS     R0,R0,#+8
   \       0x42   0x.... 0x....      BL       queue_count_get
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD037             BEQ.N    ??bm_alloc_4
   \       0x4A   0xFB09 0xF008      MUL      R0,R9,R8
   \       0x4E   0x4430             ADD      R0,R6,R0
   \       0x50   0x6880             LDR      R0,[R0, #+8]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD031             BEQ.N    ??bm_alloc_4
    316              {          
    317                if ((length > 384) && (length <= 448) && (pPool[ i ].size > 448))
   \       0x56   0x0021             MOVS     R1,R4
   \       0x58   0xB289             UXTH     R1,R1
   \       0x5A   0xF240 0x1081      MOVW     R0,#+385
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xDB0F             BLT.N    ??bm_alloc_5
   \       0x62   0xF240 0x10C1      MOVW     R0,#+449
   \       0x66   0x0021             MOVS     R1,R4
   \       0x68   0xB289             UXTH     R1,R1
   \       0x6A   0x4281             CMP      R1,R0
   \       0x6C   0xDA09             BGE.N    ??bm_alloc_5
   \       0x6E   0xFB09 0xF108      MUL      R1,R9,R8
   \       0x72   0x4431             ADD      R1,R6,R1
   \       0x74   0x8889             LDRH     R1,[R1, #+4]
   \       0x76   0x4281             CMP      R1,R0
   \       0x78   0xDB03             BLT.N    ??bm_alloc_5
    318                  bigger_buff_alloc_count++;
   \       0x7A   0x....             LDR.N    R1,??DataTable1_1
   \       0x7C   0x6808             LDR      R0,[R1, #+0]
   \       0x7E   0x1C40             ADDS     R0,R0,#+1
   \       0x80   0x6008             STR      R0,[R1, #+0]
    319                
    320                pMem = ( uint8_t* )( queue_item_get( &pPool[ i ].q ));
   \                     ??bm_alloc_5: (+1)
   \       0x82   0xFB09 0xF008      MUL      R0,R9,R8
   \       0x86   0x4430             ADD      R0,R6,R0
   \       0x88   0x3008             ADDS     R0,R0,#+8
   \       0x8A   0x.... 0x....      BL       queue_item_get
   \       0x8E   0x4683             MOV      R11,R0
    321                
    322          #ifdef BUFFER_CORRUPTION_TEST
    323                if (pPool[ i ].size == BUFFER_SIZE)
    324                {
    325                  track_64_buff.alloc[track_64_buff.alloc_index] = (uint32_t)pMem;
    326                  track_64_buff.alloc_index++;
    327                  if (track_64_buff.alloc_index >= NUMBER_OF_TEST_BUFFER)
    328                  {
    329                    track_64_buff.alloc_loop++;
    330                    track_64_buff.alloc_index = 0;
    331                  }
    332                }
    333          #endif  //BUFFER_CORRUPTION_TEST
    334          //#if ((PRINT_DEBUG_LEVEL==ERROR_DEBUG)||(PRINT_DEBUG_LEVEL==CONSOLE_ERROR_DEBUG))      
    335          //      if (queue_count_get( &pPool[ i ].q ) == 0)
    336          //        stack_print_debug ("%d size buffer exhausted\n", pPool[ i ].size);
    337          //#endif
    338                
    339                if( pMem != NULL)
   \       0x90   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x94   0xD00F             BEQ.N    ??bm_alloc_6
    340                {
    341          #if defined (BM_DEBUG_LEVEL_1) || defined (BM_DEBUG_LEVEL_2)
    342                  {
    343                    buf_t *pBuf = NULL;
    344                    pMem = ( pMem - sizeof( buf_t ) + 
    345                            sizeof( queue_item_t *);
    346                             pBuf = ( buf_t* )pMem;
    347                             pBuf->magic_num = BUF_MEM_MAGIC_NUM_USE;
    348                             pBuf->line_num = line_num;
    349          #if defined (BM_DEBUG_LEVEL_2)
    350                             pBuf->pFunc_name = pFunc_name;
    351          #endif
    352                  }
    353          #endif
    354                             pMem += sizeof( buf_t );
   \       0x96   0xF11B 0x0B04      ADDS     R11,R11,#+4
    355                             memset((uint8_t *)pMem, 0xFF, pPool[ i ].size);
   \       0x9A   0xFB09 0xF908      MUL      R9,R9,R8
   \       0x9E   0xEB06 0x0009      ADD      R0,R6,R9
   \       0xA2   0x8880             LDRH     R0,[R0, #+4]
   \       0xA4   0x9000             STR      R0,[SP, #+0]
   \       0xA6   0xF04F 0x09FF      MOV      R9,#+255
   \       0xAA   0x465F             MOV      R7,R11
   \       0xAC   0x464A             MOV      R2,R9
   \       0xAE   0x9900             LDR      R1,[SP, #+0]
   \       0xB0   0x0038             MOVS     R0,R7
   \       0xB2   0x.... 0x....      BL       __aeabi_memset
    356                } 
    357                return ( void* )pMem;
   \                     ??bm_alloc_6: (+1)
   \       0xB6   0x4658             MOV      R0,R11
   \       0xB8   0xE003             B.N      ??bm_alloc_1
    358              }
    359            }
   \                     ??bm_alloc_4: (+1)
   \       0xBA   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0xBE   0xE7AF             B.N      ??bm_alloc_2
    360            return ( void* )pMem;
   \                     ??bm_alloc_3: (+1)
   \       0xC0   0x0038             MOVS     R0,R7
   \                     ??bm_alloc_1: (+1)
   \       0xC2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    361          }
    362          
    363          /*----------------------------------------------------------------------------*/  
    364          #if defined BM_DEBUG_LEVEL_1
    365          void bm_free(
    366              uint8_t *pHeap,
    367              uint8_t *pMem,
    368              uint16_t line_num
    369              )
    370          
    371          #elif defined BM_DEBUG_LEVEL_2
    372          void bm_free(
    373              uint8_t *pHeap,
    374              uint8_t *pMem,
    375              uint16_t line_num,
    376              uint8_t *pFunc_name
    377              )
    378          
    379          #else
    380          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    381          void bm_free(
    382              uint8_t *pHeap,
    383              uint8_t *pMem      
    384              )
    385          #endif
    386               {
   \                     bm_free: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    387                 uint32_t *pBufTypes = ( uint32_t* )pHeap;
   \        0x8   0x9400             STR      R4,[SP, #+0]
    388                 uint16_t i = 0;
   \        0xA   0x2000             MOVS     R0,#+0
    389                 pool_t *pPool = ( pool_t * )&pBufTypes[1];
   \        0xC   0x9900             LDR      R1,[SP, #+0]
   \        0xE   0x1D0E             ADDS     R6,R1,#+4
    390                 int offset = 0;
   \       0x10   0x2100             MOVS     R1,#+0
    391                 queue_item_t* pItem = NULL;
   \       0x12   0x2300             MOVS     R3,#+0
    392                 
    393                 pItem = ( queue_item_t* )( pMem - sizeof( buf_t ));
   \       0x14   0x1F2A             SUBS     R2,R5,#+4
   \       0x16   0x9201             STR      R2,[SP, #+4]
    394                 
    395                 if( pHeap < pMem )
   \       0x18   0x42AC             CMP      R4,R5
   \       0x1A   0xD205             BCS.N    ??bm_free_0
    396                   offset = pMem - pHeap;
   \       0x1C   0x1B2F             SUBS     R7,R5,R4
    397                 else
    398                 {
    399                   return;
    400                 }
    401                 
    402                 if (offset >= BUFFER_POOL_SIZE)
   \       0x1E   0xF245 0x52B0      MOVW     R2,#+21936
   \       0x22   0x4297             CMP      R7,R2
   \       0x24   0xD302             BCC.N    ??bm_free_1
   \       0x26   0xE000             B.N      ??bm_free_2
   \                     ??bm_free_0: (+1)
   \       0x28   0xE02E             B.N      ??bm_free_3
    403                   return;
   \                     ??bm_free_2: (+1)
   \       0x2A   0xE02D             B.N      ??bm_free_3
    404                 
    405                 for( i = 0; i < *pBufTypes - 1; i++ )
   \                     ??bm_free_1: (+1)
   \       0x2C   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??bm_free_4: (+1)
   \       0x30   0x4640             MOV      R0,R8
   \       0x32   0xB280             UXTH     R0,R0
   \       0x34   0x9900             LDR      R1,[SP, #+0]
   \       0x36   0x6809             LDR      R1,[R1, #+0]
   \       0x38   0x1E49             SUBS     R1,R1,#+1
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD21A             BCS.N    ??bm_free_5
    406                 {        
    407                   if( offset < pPool[i + 1].offset )
   \       0x3E   0x2014             MOVS     R0,#+20
   \       0x40   0x4641             MOV      R1,R8
   \       0x42   0xB289             UXTH     R1,R1
   \       0x44   0x4341             MULS     R1,R0,R1
   \       0x46   0x4431             ADD      R1,R6,R1
   \       0x48   0x6949             LDR      R1,[R1, #+20]
   \       0x4A   0x428F             CMP      R7,R1
   \       0x4C   0xD20F             BCS.N    ??bm_free_6
    408                   {
    409                     memset( (uint8_t*)pMem,0,pPool[ i ].size);
   \       0x4E   0x4641             MOV      R1,R8
   \       0x50   0xB289             UXTH     R1,R1
   \       0x52   0xFB00 0xF001      MUL      R0,R0,R1
   \       0x56   0x4430             ADD      R0,R6,R0
   \       0x58   0xF8B0 0xB004      LDRH     R11,[R0, #+4]
   \       0x5C   0xF05F 0x0900      MOVS     R9,#+0
   \       0x60   0x46AA             MOV      R10,R5
   \       0x62   0x464A             MOV      R2,R9
   \       0x64   0x4659             MOV      R1,R11
   \       0x66   0x4650             MOV      R0,R10
   \       0x68   0x.... 0x....      BL       __aeabi_memset
    410                     break;
   \       0x6C   0xE002             B.N      ??bm_free_5
    411                   }
    412                 }
   \                     ??bm_free_6: (+1)
   \       0x6E   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x72   0xE7DD             B.N      ??bm_free_4
    413                 
    414          #ifdef BUFFER_CORRUPTION_TEST    
    415                 if ((offset >= TEST_BUFF_OFFSET) && (offset < NEXT_TO_TEST_BUFF_OFFSET))
    416                 {
    417                   track_64_buff.free[track_64_buff.free_index] = (uint32_t)pItem;
    418                   track_64_buff.free_index++;
    419                   if (track_64_buff.free_index >= NUMBER_OF_TEST_BUFFER)
    420                   {
    421                     track_64_buff.free_loop++;
    422                     track_64_buff.free_index = 0;
    423                   }
    424                   
    425                   if (present_in_alloc_buf((uint32_t)pItem))
    426                   {
    427                     track_64_buff.free_index--;
    428                     if (track_64_buff.free_index <= 0)
    429                       track_64_buff.free_index = 0;
    430                     track_64_buff.free[track_64_buff.free_index] = 0;
    431                   }
    432                   
    433                   sort_alloc_array ();
    434                 }
    435          #endif  //BUFFER_CORRUPTION_TEST
    436                 
    437                 queue_item_put( &pPool[i].q , pItem );
   \                     ??bm_free_5: (+1)
   \       0x74   0x9901             LDR      R1,[SP, #+4]
   \       0x76   0x4642             MOV      R2,R8
   \       0x78   0xB292             UXTH     R2,R2
   \       0x7A   0x2014             MOVS     R0,#+20
   \       0x7C   0x4342             MULS     R2,R0,R2
   \       0x7E   0xEB06 0x0002      ADD      R0,R6,R2
   \       0x82   0x3008             ADDS     R0,R0,#+8
   \       0x84   0x.... 0x....      BL       queue_item_put
    438                 
    439                 
    440          #if defined (BM_DEBUG_LEVEL_1) || defined (BM_DEBUG_LEVEL_2)
    441                 {
    442                   buf_t *pBuf = ( buf_t* )(( uint8_t* )pItem - sizeof( buf_t ) + 
    443                                            sizeof( queue_item_t* ));
    444                   pBuf->magic_num = BUF_MEM_MAGIC_NUM_FREE;
    445                   pBuf->line_num = line_num;
    446          #if defined (BM_DEBUG_LEVEL_2)
    447                   pBuf->pFunc_name = pFunc_name;
    448          #endif
    449                 }
    450          #endif
    451               }
   \                     ??bm_free_3: (+1)
   \       0x88   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     p_debug_heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     bigger_buff_alloc_count
    452          
    453          
    454          #if(0)
    455          /*----------------------------------------------------------------------------*/
    456          uint16_t bm_calc_heap_size(
    457              uint16_t num_of_types,
    458              buf_mem_pool_t *pbuf_cfg
    459              )
    460          {
    461              uint16_t i = 0;
    462              uint16_t req_size = sizeof(uint16_t) + 
    463                  sizeof(pool_t) * ( num_of_types ) + 
    464                  sizeof(queue_t) * num_of_types;
    465              
    466              for( i = 0; i < num_of_types; i++ )
    467              {
    468                  req_size += ( sizeof(buf_t) + pbuf_cfg[ i ].buf_size ) * 
    469                      pbuf_cfg[ i ].num_of_buf;
    470              }
    471              return req_size;
    472          }
    473          
    474          #endif
    475          /*----------------------------------------------------------------------------*/
    476             
    477          /*
    478          ** =============================================================================
    479          ** Private Function Definitions
    480          ** =============================================================================
    481          */                           
    482                             
    483          //static queue_t* get_pool(uint8_t i)
    484          //{
    485          //  return &(p_debug_heap->pools[1].q);
    486          //}
    487                                           
    488          /*----------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   bm_alloc
        40   -> __aeabi_memset
        40   -> queue_count_get
        40   -> queue_item_get
      48   bm_free
        48   -> __aeabi_memset
        48   -> queue_item_put
      56   bm_init
        56   -> queue_initialise
        56   -> queue_item_put


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  bigger_buff_alloc_count
     198  bm_alloc
     140  bm_free
     268  bm_init
       4  p_debug_heap

 
   8 bytes in section .bss
 614 bytes in section .text
 
 614 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
