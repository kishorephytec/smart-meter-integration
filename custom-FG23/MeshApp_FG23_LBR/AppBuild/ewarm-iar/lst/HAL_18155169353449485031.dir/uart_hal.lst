###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         02/Dec/2024  12:57:43
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\ProAppSrc\HAL\uart_hal.c
#    Command line                 =
#        -f
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir\uart_hal.o.rsp
#        (D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\ProAppSrc\HAL\uart_hal.c
#        -D EFR32FG23A020F512GM40=1 -D SL_COMPONENT_CATALOG_PRESENT=1 -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -lC
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\lst\HAL_18155169353449485031.dir
#        --diag_suppress Pa050 -o
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse -e --fpu=VFPv5_sp --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\.\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\AppConfigs\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\config\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\autogen\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\HAL\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\NVM\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Include\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\buffer_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\event_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\list_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\queue_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\timer_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\hif\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\raw_uart_if\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\debug_console\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\Device\SiliconLabs\EFR32FG23\Include\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\CMSIS\Core\Include\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\device_init\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\common\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\mpu\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\common\toolchain\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\system\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\network-manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\RAIL_TRX\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\MAC\Inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\wisun_modified\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\FANApp\AppInc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_callbacks\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\ip\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\ipv6\multicast\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\ipv6\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\rpl\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\OS_interface\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\L2_L3_interface\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\cpu\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\Interface_Layer\contiki_mac_interface_layer\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\Interface_Layer\mac_sicslowpan_if\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\emlib\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\platform\p3_lp_dk\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\common\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\protocol\ble\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\protocol\ieee802154\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\protocol\zwave\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\efr32xg1x\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_protocol\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_rssi\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\MeterApp\Inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\emdrv\dmadrv\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\emdrv\common\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\FLASH\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\DebugLog\APP_LOG\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\DebugLog\response_print\config\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\DebugLog\response_print\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\NVM\nvm3\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\
#        -On --use_c++_inline) --dependencies=n
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir\uart_hal.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\lst\HAL_18155169353449485031.dir\uart_hal.lst
#    Object file                  =
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\HAL_18155169353449485031.dir\uart_hal.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\ProAppSrc\HAL\uart_hal.c
      1          /** \file uart_hal.c
      2           *******************************************************************************
      3           ** \brief  Provides APIs for UART driver
      4           **
      5           ** \cond STD_FILE_HEADER
      6           **
      7           ** COPYRIGHT(c) 2023-24 Procubed Innovations Pvt Ltd.
      8           ** All rights reserved.
      9           **
     10           ** THIS SOFTWARE IS PROVIDED BY "AS IS" AND ALL WARRANTIES OF ANY KIND,
     11           ** INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR USE,
     12           ** ARE EXPRESSLY DISCLAIMED.  THE DEVELOPER SHALL NOT BE LIABLE FOR ANY
     13           ** DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. THIS SOFTWARE
     14           ** MAY NOT BE USED IN PRODUCTS INTENDED FOR USE IN IMPLANTATION OR OTHER
     15           ** DIRECT LIFE SUPPORT APPLICATIONS WHERE MALFUNCTION MAY RESULT IN THE DIRECT
     16           ** PHYSICAL HARM OR INJURY TO PERSONS. ALL SUCH IS USE IS EXPRESSLY PROHIBITED.
     17           **
     18           *******************************************************************************
     19           **  \endcond
     20           */
     21          
     22          
     23          /*******************************************************************************
     24          * File inclusion
     25          *******************************************************************************/
     26          
     27          #include "StackPHYConf.h"
     28          #include "pin_config.h"
     29          #include "common.h"
     30          #include "em_device.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __vfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....             LDR.N    R3,??DataTable9
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB249             SXTB     R1,R1
   \       0x16   0x0949             LSRS     R1,R1,#+5
   \       0x18   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_ClearPendingIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x....             LDR.N    R3,??DataTable9_1
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0xB249             SXTB     R1,R1
   \       0x16   0x0949             LSRS     R1,R1,#+5
   \       0x18   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
     31          #include "em_cmu.h"
     32          #include "em_gpio.h"
     33          #include "em_usart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntClear(USART_TypeDef *, uint32_t)
   \                     USART_IntClear: (+1)
   \        0x0   0xF242 0x0248      MOVW     R2,#+8264
   \        0x4   0x5081             STR      R1,[R0, R2]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntDisable(USART_TypeDef *, uint32_t)
   \                     USART_IntDisable: (+1)
   \        0x0   0x6CC2             LDR      R2,[R0, #+76]
   \        0x2   0x438A             BICS     R2,R2,R1
   \        0x4   0x64C2             STR      R2,[R0, #+76]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void USART_IntEnable(USART_TypeDef *, uint32_t)
   \                     USART_IntEnable: (+1)
   \        0x0   0x6CC2             LDR      R2,[R0, #+76]
   \        0x2   0x430A             ORRS     R2,R1,R2
   \        0x4   0x64C2             STR      R2,[R0, #+76]
   \        0x6   0x4770             BX       LR
     34          #include "em_eusart.h"
     35          #include "uart_hal.h"
     36          
     37          
     38          /*
     39          ** ============================================================================
     40          ** Private Macro definitions
     41          ** ============================================================================
     42          */
     43          #ifndef UART_TX_BUF_LEN
     44          #define UART_TX_BUF_LEN	2300
     45          #endif
     46          
     47          #ifndef NUMBER_OF_UART_TX_BUFFERS
     48          #define NUMBER_OF_UART_TX_BUFFERS	0
     49          #endif
     50          
     51          
     52          #define APP_USART0_BAUDRATE 115200
     53          #define APP_USART0_TX_PORT gpioPortA
     54          #define APP_USART0_TX_PIN 8
     55          
     56          #define APP_USART0_RX_PORT gpioPortA
     57          #define APP_USART0_RX_PIN 7
     58          /*
     59          ** ============================================================================
     60          ** Private Structures, Unions & enums Type Definitions
     61          ** ============================================================================
     62          */
     63          
     64          typedef struct P3_BUFFER_tag
     65          {
     66              uint8_t* p_data;
     67              uint16_t element_count;
     68              void* p_cb_param;
     69          }P3_BUFFER_t;
     70          

   \                                 In section .bss, align 4
     71          P3_BUFFER_t uart0_rx_buffer;
   \                     uart0_rx_buffer:
   \        0x0                      DS8 12
     72          

   \                                 In section .bss, align 4
     73          P3_BUFFER_t uart1_rx_buffer;
   \                     uart1_rx_buffer:
   \        0x0                      DS8 12
     74          
     75          /*
     76          When Using Only Usart as commucation to meater Usae USART0 default
     77          If SPI flash is requred the make communication USART0 to EUSART0 because USART0 is used by SPI
     78          Only 1 USART phereperal is avaliable 
     79          */
     80          /* Setup UART1 in async mode for RS232*/

   \                                 In section .data, align 4
     81          static USART_TypeDef           *uart0   = USART0;
   \                     uart0:
   \        0x0   0x5005'C000        DC32 0x5005'c000
     82          
     83          
     84          /*
     85          ** ============================================================================
     86          ** Private Variable Definitions
     87          ** ============================================================================
     88          */
     89          

   \                                 In section .bss, align 4
     90          volatile uint8_t * gp_uart0_tx_address;        /* uart1 transmit buffer address */
   \                     gp_uart0_tx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
     91          volatile uint16_t  g_uart0_tx_count;           /* uart1 transmit data number */
   \                     g_uart0_tx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
     92          volatile uint8_t * gp_uart0_rx_address;        /* uart1 receive buffer address */
   \                     gp_uart0_rx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
     93          volatile uint16_t  g_uart0_rx_count;           /* uart1 receive data number */
   \                     g_uart0_rx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
     94          volatile uint16_t  g_uart0_rx_length;          /* uart1 receive data length */
   \                     g_uart0_rx_length:
   \        0x0                      DS8 2
     95          
     96          

   \                                 In section .bss, align 4
     97          volatile uint8_t * gp_uart1_tx_address;        /* uart1 transmit buffer address */
   \                     gp_uart1_tx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
     98          volatile uint16_t  g_uart1_tx_count;           /* uart1 transmit data number */
   \                     g_uart1_tx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
     99          volatile uint8_t * gp_uart1_rx_address;        /* uart1 receive buffer address */
   \                     gp_uart1_rx_address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 2
    100          volatile uint16_t  g_uart1_rx_count;           /* uart1 receive data number */
   \                     g_uart1_rx_count:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
    101          volatile uint16_t  g_uart1_rx_length;          /* uart1 receive data length */
   \                     g_uart1_rx_length:
   \        0x0                      DS8 2
    102          
    103          /*
    104          ** ============================================================================
    105          ** Private Macro definitions
    106          ** ============================================================================
    107          */
    108          
    109          
    110          
    111          
    112          
    113          /*
    114          ** ============================================================================
    115          ** Private Structures, Unions & enums Type Definitions
    116          ** ============================================================================
    117          */
    118          
    119          
    120          
    121          /*
    122          ** ============================================================================
    123          ** Public Variable Definitions
    124          ** ============================================================================
    125          */
    126          

   \                                 In section .bss, align 4
    127          uart_hal_data_t uart_hal_info;
   \                     uart_hal_info:
   \        0x0                      DS8 8

   \                                 In section .data, align 1
    128          volatile uint8_t uart0_trigger_tx = 1;
   \                     uart0_trigger_tx:
   \        0x0   0x01               DC8 1
    129          

   \                                 In section .data, align 1
    130          volatile uint8_t uart1_trigger_tx = 1;
   \                     uart1_trigger_tx:
   \        0x0   0x01               DC8 1
    131          static uint8_t uart1_rx_byte;
                                ^
Warning[Pe177]: variable "uart1_rx_byte" was declared but never referenced
    132          
    133          /*
    134          ** ============================================================================
    135          ** External Variable Declarations
    136          ** ============================================================================
    137          */
    138          
    139              /* None */
    140          
    141          /*
    142          ** ============================================================================
    143          ** Private Function Prototypes
    144          ** ============================================================================
    145          */
    146          
    147            /* None */
    148          
    149          /*
    150          ** ============================================================================
    151          ** Public Function Definitions
    152          ** ============================================================================
    153          */
    154          

   \                                 In section .text, align 2, keep-with-next
    155          void UART_init(void)
    156          {  
   \                     UART_init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    157            
    158               /*
    159          
    160              Raka :: Needs to do clean up once UART is tested Properly  [ 13- Sep - 2022 ]
    161              */
    162          CMU_ClockEnable(cmuClock_USART0, true);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2029             MOVS     R0,#+41
   \        0x8   0x.... 0x....      BL       CMU_ClockEnable
    163              CMU_ClockEnable(cmuClock_GPIO, true);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x203A             MOVS     R0,#+58
   \       0x10   0x.... 0x....      BL       CMU_ClockEnable
    164            
    165            // Default asynchronous initializer (115.2 Kbps, 8N1, no flow control)
    166              
    167              USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;  // this is for FG13
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x....             LDR.N    R1,??DataTable9_2
   \       0x18   0x221C             MOVS     R2,#+28
   \       0x1A   0x.... 0x....      BL       __aeabi_memcpy4
    168              
    169              
    170               /* Configure GPIO pins  for communication UART  :: LOC 22*/
    171              GPIO_PinModeSet(APP_USART0_TX_PORT, APP_USART0_TX_PIN, gpioModePushPull, 1); // tx
   \       0x1E   0x2301             MOVS     R3,#+1
   \       0x20   0x2204             MOVS     R2,#+4
   \       0x22   0x2108             MOVS     R1,#+8
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x.... 0x....      BL       GPIO_PinModeSet
    172              GPIO_PinModeSet(APP_USART0_RX_PORT, APP_USART0_RX_PIN, gpioModeInput, 0);     // rx
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x2107             MOVS     R1,#+7
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x.... 0x....      BL       GPIO_PinModeSet
    173          
    174              
    175              // Route USART0 TX and RX to the board controller TX and RX pins
    176              GPIO->USARTROUTE[0].TXROUTE = (APP_USART0_TX_PORT << _GPIO_USART_TXROUTE_PORT_SHIFT)
    177                | (APP_USART0_TX_PIN << _GPIO_USART_TXROUTE_PIN_SHIFT);
   \       0x36   0xF45F 0x2100      MOVS     R1,#+524288
   \       0x3A   0x....             LDR.N    R0,??DataTable9_3
   \       0x3C   0x6001             STR      R1,[R0, #+0]
    178            GPIO->USARTROUTE[0].RXROUTE = (APP_USART0_RX_PORT << _GPIO_USART_RXROUTE_PORT_SHIFT)
    179                | (APP_USART0_RX_PIN << _GPIO_USART_RXROUTE_PIN_SHIFT);
   \       0x3E   0xF45F 0x21E0      MOVS     R1,#+458752
   \       0x42   0x....             LDR.N    R0,??DataTable9_4
   \       0x44   0x6001             STR      R1,[R0, #+0]
    180              // Clock configuration ....
    181          
    182             // Enable RX and TX signals now that they have been routed
    183            GPIO->USARTROUTE[0].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN | GPIO_USART_ROUTEEN_TXPEN;
   \       0x46   0x2114             MOVS     R1,#+20
   \       0x48   0x....             LDR.N    R0,??DataTable9_5
   \       0x4A   0x6001             STR      R1,[R0, #+0]
    184              
    185                // The Baud rate for the Communication.
    186              init.baudrate = APP_USART0_BAUDRATE ;
   \       0x4C   0xF45F 0x30E1      MOVS     R0,#+115200
   \       0x50   0x9002             STR      R0,[SP, #+8]
    187          
    188              // Configure and enable USART0
    189              USART_InitAsync(USART0, &init);          // this is for FG13
   \       0x52   0x....             LDR.N    R4,??DataTable9_6
   \       0x54   0x4669             MOV      R1,SP
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       USART_InitAsync
    190              
    191             
    192          
    193              
    194             //  EUSART_UartInit_TypeDef init = EUSART_UART_INIT_DEFAULT_HF;   // this is for FG23
    195           
    196             // EUSART_UartInitHf(EUSART1, &init);          // this is for FG23
    197          
    198              /* Prepare UART Rx and Tx interrupts */
    199             // USART_IntClear(uart0, _USART_IF_MASK);            // this is for FG13
    200            //   EUSART_IntClear(EUSART1, _EUSART_IEN_MASK);        // this is for FG23
    201             // USART_IntEnable(uart0, USART_IF_RXDATAV);         // this is for FG13
    202           //   EUSART_IntEnable(EUSART1, EUSART_IEN_RXFL);         // this is for FG23
    203              
    204              //// this is for FG13
    205              NVIC_ClearPendingIRQ(USART0_RX_IRQn);
   \       0x5C   0x2009             MOVS     R0,#+9
   \       0x5E   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    206              USART_IntEnable(USART0, USART_IEN_RXDATAV);
   \       0x62   0x2104             MOVS     R1,#+4
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       USART_IntEnable
    207              NVIC_EnableIRQ(USART0_RX_IRQn);
   \       0x6A   0x2009             MOVS     R0,#+9
   \       0x6C   0x.... 0x....      BL       __NVIC_EnableIRQ
    208              NVIC_ClearPendingIRQ(USART0_TX_IRQn);
   \       0x70   0x200A             MOVS     R0,#+10
   \       0x72   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    209              NVIC_EnableIRQ(USART0_TX_IRQn);
   \       0x76   0x200A             MOVS     R0,#+10
   \       0x78   0x.... 0x....      BL       __NVIC_EnableIRQ
    210              
    211              //// this is for FG23
    212          //  NVIC_ClearPendingIRQ(EUSART1_RX_IRQn);
    213          //  NVIC_ClearPendingIRQ(EUSART1_TX_IRQn);
    214          //  NVIC_EnableIRQ(EUSART1_RX_IRQn);
    215          //  NVIC_EnableIRQ(EUSART1_TX_IRQn);
    216              
    217          // this is for FG13 
    218            //for fg23 PIN loc not required
    219              // Enable RX and TX for USART0 VCOM connection
    220           //   USART0->ROUTELOC0 = USART_ROUTELOC0_RXLOC_LOC22 | USART_ROUTELOC0_TXLOC_LOC22;
    221            //  USART0->ROUTEPEN |= USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    222            
    223          
    224          }
   \       0x7C   0xB008             ADD      SP,SP,#+32
   \       0x7E   0xBD10             POP      {R4,PC}
    225          
    226          /******************************************************************************/
    227          

   \                                 In section .text, align 2, keep-with-next
    228          void UART_close(void)
    229          {
   \                     UART_close: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    230            USART_Reset(uart0);         //This is for FG13
   \        0x2   0x....             LDR.N    R0,??DataTable9_7
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x.... 0x....      BL       USART_Reset
    231          //  EUSART_Reset(EUSART1);        //This is for FG23
    232          }
   \        0xA   0xBD01             POP      {R0,PC}
    233          
    234          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          int8_t uart_hal_read( uint8_t* p_data, uint16_t len )
    236          {
   \                     uart_hal_read: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    237          	uart0_rx_buffer.p_data = p_data;
   \        0x2   0x....             LDR.N    R0,??DataTable9_8
   \        0x4   0x6002             STR      R2,[R0, #+0]
    238          	uart0_rx_buffer.element_count = ( uint16_t )len;
   \        0x6   0x8081             STRH     R1,[R0, #+4]
    239                  
    240                  g_uart0_rx_count = 0U;
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x....             LDR.N    R0,??DataTable9_9
   \        0xC   0x8003             STRH     R3,[R0, #+0]
    241                  g_uart0_rx_length = ( uint16_t )len;
   \        0xE   0x....             LDR.N    R0,??DataTable9_10
   \       0x10   0x8001             STRH     R1,[R0, #+0]
    242                  gp_uart0_rx_address = p_data;
   \       0x12   0x....             LDR.N    R0,??DataTable9_11
   \       0x14   0x6002             STR      R2,[R0, #+0]
    243                  
    244          	return 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR
    245          }
    246          
    247          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    248          int8_t uart_hal_write( uint8_t* p_data, uint16_t len )
    249          {
   \                     uart_hal_write: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    250          	if( len > UART_TX_BUF_LEN )
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0xB289             UXTH     R1,R1
   \        0xA   0xF640 0x00FD      MOVW     R0,#+2301
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xDB02             BLT.N    ??uart_hal_write_0
    251          	{
    252          		//let this get freed up as it is of more than the allowed UART packet size
    253          		return -2;//
   \       0x12   0xF07F 0x0001      MVNS     R0,#+1
   \       0x16   0xE012             B.N      ??uart_hal_write_1
    254          	}
    255          
    256          	/* Submit Outbound buffer to UART */
    257          	if( uart0_trigger_tx )
   \                     ??uart_hal_write_0: (+1)
   \       0x18   0x....             LDR.N    R1,??DataTable9_12
   \       0x1A   0x7808             LDRB     R0,[R1, #+0]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD00C             BEQ.N    ??uart_hal_write_2
    258          	{
    259                    uart0_trigger_tx = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x7008             STRB     R0,[R1, #+0]
    260          
    261                    gp_uart0_tx_address = p_data;
   \       0x24   0x....             LDR.N    R0,??DataTable9_13
   \       0x26   0x6004             STR      R4,[R0, #+0]
    262                    g_uart0_tx_count = len;
   \       0x28   0x....             LDR.N    R0,??DataTable9_14
   \       0x2A   0x8005             STRH     R5,[R0, #+0]
    263          
    264                    /* Enable interrupt on USART TX Buffer*/
    265                    USART_IntEnable(uart0, USART_IF_TXBL);            //This is for FG13
   \       0x2C   0x2102             MOVS     R1,#+2
   \       0x2E   0x....             LDR.N    R0,??DataTable9_7
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x.... 0x....      BL       USART_IntEnable
    266                    //EUSART_IntEnable(EUSART1, EUSART_IEN_TXFL);           //This is for FG23
    267          	}
    268          	else
    269          	{
    270          		//uart is busy doing transmission of a packet initiated earlier. 
    271          		//So let this buffer be put in a queue to be processed ata a 
    272          		//later stage
    273          		return -1;
    274          		//queue_item_put( &uart_tx_buf_q,  (queue_item_t*) p_uart_tx_buff );
    275          	}
    276          
    277              return 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE001             B.N      ??uart_hal_write_1
   \                     ??uart_hal_write_2: (+1)
   \       0x3A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \                     ??uart_hal_write_1: (+1)
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}
    278          }
    279          
    280          /******************************************************************************/
    281          

   \                                 In section .text, align 2, keep-with-next
    282          int8_t uart_hal_register_back(uart_hal_call_back cb, void* param)
    283          {
   \                     uart_hal_register_back: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    284          	uart_hal_info.cb = cb;
   \        0x2   0x....             LDR.N    R0,??DataTable9_15
   \        0x4   0x6002             STR      R2,[R0, #+0]
    285          	uart_hal_info.param = param;
   \        0x6   0x6041             STR      R1,[R0, #+4]
    286          	return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
    287          }
    288          
    289          /*
    290          ** ============================================================================
    291          ** Private Function Definitions
    292          ** ============================================================================
    293          */
    294          

   \                                 In section .text, align 2, keep-with-next
    295          void UARTCallback( uint8_t eventid )
    296          {
   \                     UARTCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    297              switch (eventid) 
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??UARTCallback_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD012             BEQ.N    ??UARTCallback_1
   \       0x10   0xD30A             BCC.N    ??UARTCallback_2
   \       0x12   0xE011             B.N      ??UARTCallback_3
    298              {
    299                  case 0://tx complete
    300          			
    301          			/*put back the buffer in the free pool*/
    302          			uart0_trigger_tx = 1;
   \                     ??UARTCallback_0: (+1)
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x....             LDR.N    R0,??DataTable9_12
   \       0x18   0x7001             STRB     R1,[R0, #+0]
    303          
    304          			/*invoke callback informing packet tx completion*/
    305          			uart_hal_info.cb( NULL,TX_COMPLETE_EVENT,uart_hal_info.param );
   \       0x1A   0x....             LDR.N    R3,??DataTable9_15
   \       0x1C   0x685A             LDR      R2,[R3, #+4]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x681B             LDR      R3,[R3, #+0]
   \       0x24   0x4798             BLX      R3
    306          			break;
   \       0x26   0xE007             B.N      ??UARTCallback_4
    307          		case 1://rx complete
    308          			/*invoke callback informing packet rx completion*/
    309          			uart_hal_info.cb( NULL,RX_COMPLETE_EVENT,uart_hal_info.param );
   \                     ??UARTCallback_2: (+1)
   \       0x28   0x....             LDR.N    R3,??DataTable9_15
   \       0x2A   0x685A             LDR      R2,[R3, #+4]
   \       0x2C   0x2103             MOVS     R1,#+3
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x681B             LDR      R3,[R3, #+0]
   \       0x32   0x4798             BLX      R3
    310                      break;
   \       0x34   0xE000             B.N      ??UARTCallback_4
    311          		case 2://error
    312          			break;
   \                     ??UARTCallback_1: (+1)
   \       0x36   0xE7FF             B.N      ??UARTCallback_4
    313          
    314          		default:
    315          			break;                    
    316              }
    317          }
   \                     ??UARTCallback_3: (+1)
   \                     ??UARTCallback_4: (+1)
   \       0x38   0xBD10             POP      {R4,PC}
    318          
    319          
    320          
    321          /**************************************************************************//**
    322           * @brief UART1 RX IRQ Handler
    323           *
    324           * Set up the interrupt prior to use
    325           *
    326           * Note that this function handles overflows in a very simple way.
    327           *
    328           *****************************************************************************/

   \                                 In section .bss, align 4
    329          uint8_t uart_debug_buff [100] = {0};
   \                     uart_debug_buff:
   \        0x0                      DS8 100

   \                                 In section .bss, align 2
    330          uint16_t uart_debug_buff_Cnt = 0;
   \                     uart_debug_buff_Cnt:
   \        0x0                      DS8 2
    331          

   \                                 In section .text, align 2, keep-with-next
    332          void USART0_RX_IRQHandler(void)
    333          {
   \                     USART0_RX_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    334            uint8_t rxData;
    335            /* Check for RX data valid interrupt */
    336            if (uart0->STATUS & USART_STATUS_RXDATAV)
   \        0x2   0x....             LDR.N    R0,??DataTable9_7
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x6989             LDR      R1,[R1, #+24]
   \        0x8   0x0609             LSLS     R1,R1,#+24
   \        0xA   0xD52D             BPL.N    ??USART0_RX_IRQHandler_0
    337            {
    338              /* Copy data into RX Buffer */
    339              rxData = USART_Rx(uart0);
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x.... 0x....      BL       USART_Rx
   \       0x12   0x0004             MOVS     R4,R0
    340              /* Clear RXDATAV interrupt */
    341              
    342              uart_debug_buff [uart_debug_buff_Cnt++] = rxData;
   \       0x14   0x....             LDR.N    R0,??DataTable9_16
   \       0x16   0x....             LDR.N    R2,??DataTable9_17
   \       0x18   0x8801             LDRH     R1,[R0, #+0]
   \       0x1A   0x5454             STRB     R4,[R2, R1]
   \       0x1C   0x8801             LDRH     R1,[R0, #+0]
   \       0x1E   0x1C49             ADDS     R1,R1,#+1
   \       0x20   0x8001             STRH     R1,[R0, #+0]
    343              if ( uart_debug_buff_Cnt == 100 )
   \       0x22   0x8801             LDRH     R1,[R0, #+0]
   \       0x24   0x2964             CMP      R1,#+100
   \       0x26   0xD101             BNE.N    ??USART0_RX_IRQHandler_1
    344              {
    345                uart_debug_buff_Cnt = 0;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x8001             STRH     R1,[R0, #+0]
    346              }
    347              
    348              USART_IntClear(USART0, USART_IF_RXDATAV);
   \                     ??USART0_RX_IRQHandler_1: (+1)
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x....             LDR.N    R0,??DataTable9_6
   \       0x30   0x.... 0x....      BL       USART_IntClear
    349              
    350              if (g_uart0_rx_length > g_uart0_rx_count)
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \       0x34   0x....             LDR.N    R0,??DataTable9_9
   \       0x36   0x8803             LDRH     R3,[R0, #+0]
   \       0x38   0x....             LDR.N    R1,??DataTable9_10
   \       0x3A   0x880A             LDRH     R2,[R1, #+0]
   \       0x3C   0xB29B             UXTH     R3,R3
   \       0x3E   0x4293             CMP      R3,R2
   \       0x40   0xD217             BCS.N    ??USART0_RX_IRQHandler_2
    351              {
    352                  *gp_uart0_rx_address = rxData;
   \       0x42   0x....             LDR.N    R2,??DataTable9_11
   \       0x44   0x6813             LDR      R3,[R2, #+0]
   \       0x46   0x701C             STRB     R4,[R3, #+0]
    353                  
    354                  g_uart0_rx_count++;
   \       0x48   0x8803             LDRH     R3,[R0, #+0]
   \       0x4A   0x1C5B             ADDS     R3,R3,#+1
   \       0x4C   0x8003             STRH     R3,[R0, #+0]
    355          
    356                  if (g_uart0_rx_length == g_uart0_rx_count)
                         ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \       0x4E   0x8809             LDRH     R1,[R1, #+0]
   \       0x50   0x8800             LDRH     R0,[R0, #+0]
   \       0x52   0xB289             UXTH     R1,R1
   \       0x54   0x4281             CMP      R1,R0
   \       0x56   0xD103             BNE.N    ??USART0_RX_IRQHandler_3
    357                  {
    358                      UARTCallback(1);
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0x.... 0x....      BL       UARTCallback
   \       0x5E   0xE008             B.N      ??USART0_RX_IRQHandler_2
    359                  }
    360                  else
    361                  {
    362                    gp_uart0_rx_address++;
   \                     ??USART0_RX_IRQHandler_3: (+1)
   \       0x60   0x6810             LDR      R0,[R2, #+0]
   \       0x62   0x1C40             ADDS     R0,R0,#+1
   \       0x64   0x6010             STR      R0,[R2, #+0]
   \       0x66   0xE004             B.N      ??USART0_RX_IRQHandler_2
    363                  }
    364              }
    365            }
    366            else
    367            {
    368              USART_IntClear(USART0, USART_STATUS_RXFULL);
   \                     ??USART0_RX_IRQHandler_0: (+1)
   \       0x68   0xF44F 0x7180      MOV      R1,#+256
   \       0x6C   0x....             LDR.N    R0,??DataTable9_6
   \       0x6E   0x.... 0x....      BL       USART_IntClear
    369            }
    370          }
   \                     ??USART0_RX_IRQHandler_2: (+1)
   \       0x72   0xBD10             POP      {R4,PC}
    371          
    372          /**************************************************************************//**
    373           * @brief UART1 TX IRQ Handler
    374           *
    375           * Set up the interrupt prior to use
    376           *
    377           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    378          void USART0_TX_IRQHandler(void)
    379          {
   \                     USART0_TX_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    380            /* Check TX buffer level status */
    381            if (uart0->STATUS & USART_STATUS_TXBL)
   \        0x2   0x....             LDR.N    R4,??DataTable9_7
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6980             LDR      R0,[R0, #+24]
   \        0x8   0x0640             LSLS     R0,R0,#+25
   \        0xA   0xD51A             BPL.N    ??USART0_TX_IRQHandler_0
    382            {
    383              if (g_uart0_tx_count > 0)
   \        0xC   0x....             LDR.N    R5,??DataTable9_14
   \        0xE   0x8828             LDRH     R0,[R5, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00C             BEQ.N    ??USART0_TX_IRQHandler_1
    384              {
    385                /* Transmit pending character */
    386                USART_Tx(uart0, *gp_uart0_tx_address++);      
   \       0x14   0x....             LDR.N    R0,??DataTable9_13
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x7809             LDRB     R1,[R1, #+0]
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x1C52             ADDS     R2,R2,#+1
   \       0x1E   0x6002             STR      R2,[R0, #+0]
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       USART_Tx
    387                g_uart0_tx_count--;
   \       0x28   0x8828             LDRH     R0,[R5, #+0]
   \       0x2A   0x1E40             SUBS     R0,R0,#+1
   \       0x2C   0x8028             STRH     R0,[R5, #+0]
    388              }
    389          
    390              /* Disable Tx interrupt if no more bytes to be sent */
    391              if (g_uart0_tx_count == 0)
   \                     ??USART0_TX_IRQHandler_1: (+1)
   \       0x2E   0x8828             LDRH     R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD106             BNE.N    ??USART0_TX_IRQHandler_0
    392              {
    393                USART_IntDisable(uart0, USART_IF_TXBL);
   \       0x34   0x2102             MOVS     R1,#+2
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       USART_IntDisable
    394                //send end
    395                UARTCallback(0);
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x.... 0x....      BL       UARTCallback
    396              }
    397            }
    398          }
   \                     ??USART0_TX_IRQHandler_0: (+1)
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x5003'C7B0        DC32     0x5003c7b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x5003'C7A8        DC32     0x5003c7a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x5003'C798        DC32     0x5003c798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x5005'C000        DC32     0x5005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \        0x0   0x....'....        DC32     uart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \        0x0   0x....'....        DC32     uart0_rx_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \        0x0   0x....'....        DC32     g_uart0_rx_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \        0x0   0x....'....        DC32     g_uart0_rx_length

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \        0x0   0x....'....        DC32     gp_uart0_rx_address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \        0x0   0x....'....        DC32     uart0_trigger_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \        0x0   0x....'....        DC32     gp_uart0_tx_address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \        0x0   0x....'....        DC32     g_uart0_tx_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \        0x0   0x....'....        DC32     uart_hal_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \        0x0   0x....'....        DC32     uart_debug_buff_Cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \        0x0   0x....'....        DC32     uart_debug_buff

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x05               DC8 5
   \        0x1                      DS8 3
   \        0x4   0x0000'0000        DC32 0, 115'200
   \              0x0001'C200
   \        0xC   0x00 0x05          DC8 0, 5
   \        0xE   0x0000 0x1000      DC16 0, 4'096
   \       0x12   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00
   \       0x1A                      DS8 2
    399          
    400          
    401          
    402          #if 0
    403          /**************************************************************************//**
    404          * @brief
    405          *    USART0 initialization (VCOM on xG1/xG12/xG13 boards)
    406          *****************************************************************************/
    407          void init_Usart1(void)
    408          {
    409            
    410            
    411            //CMU_ClockEnable(cmuClock_GPIO, true);
    412            
    413            
    414            /* Configure GPIO pins for Debug UART :: LOC */ 
    415            
    416            GPIO_PinModeSet(APP_USART1_TX_PORT, APP_USART1_TX_PIN, gpioModeInput, 0); //tx
    417            GPIO_PinModeSet(APP_USART1_RX_PORT, APP_USART1_RX_PIN, gpioModePushPull, 1); //rx
    418            
    419            CMU_ClockEnable(cmuClock_USART1, true);
    420            
    421            // Default asynchronous initializer (115.2 Kbps, 8N1, no flow control)
    422            USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
    423               
    424            // The Baud rate for the Communication.
    425            init.baudrate = APP_USART1_BAUDRATE ;
    426            
    427            // Configure and enable USART0
    428            USART_InitAsync(USART1, &init);
    429            
    430            
    431            USART_IntClear(USART1, _USART_IF_MASK);
    432            USART_IntEnable(USART1, USART_IEN_RXDATAV);
    433            
    434            // Enable NVIC USART sources
    435            NVIC_ClearPendingIRQ(USART1_RX_IRQn);
    436            NVIC_EnableIRQ(USART1_RX_IRQn);
    437            NVIC_ClearPendingIRQ(USART1_TX_IRQn);
    438            NVIC_EnableIRQ(USART1_TX_IRQn);
    439            
    440            /* Enable I/O pins at UART0 location #22 */
    441            USART1->ROUTELOC0 = USART_ROUTELOC0_RXLOC_LOC25  | USART_ROUTELOC0_TXLOC_LOC27;
    442            USART1->ROUTEPEN |= USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
    443            
    444          }
    445          /******************************************************************************/
    446          
    447          void UART1_close(void)
    448          {
    449            USART_Reset(USART1);
    450          }
    451          
    452          
    453          
    454          /******************************************************************************/
    455          
    456          int8_t raw_uart_hal_read(uint8_t* p_data, uint16_t len )
    457          {
    458            uart1_rx_buffer.p_data = p_data;
    459            uart1_rx_buffer.element_count = ( uint16_t )len;
    460            
    461            g_uart1_rx_count = 0U;
    462            g_uart1_rx_length = ( uint16_t )len;
    463            gp_uart1_rx_address = p_data;
    464            
    465            return 0;
    466          }
    467          
    468          /******************************************************************************/
    469          
    470          int8_t raw_uart_hal_write(uint8_t* p_data, uint16_t len )
    471          {
    472           
    473            /* Submit Outbound buffer to UART */
    474            if( uart1_trigger_tx )
    475            {
    476              uart1_trigger_tx = 0;
    477              
    478              gp_uart1_tx_address = p_data;
    479              g_uart1_tx_count = len;
    480              
    481              /* Enable interrupt on USART TX Buffer*/
    482              USART_IntEnable(USART1, USART_IF_TXBL);
    483            }
    484            else
    485            {
    486              //uart is busy doing transmission of a packet initiated earlier. 
    487              //So let this buffer be put in a queue to be processed ata a 
    488              //later stage
    489              return -1;
    490              
    491            }
    492            
    493            return 0;
    494          }
    495          
    496          
    497          
    498          /*
    499          ** ============================================================================
    500          ** Private Function Definitions
    501          ** ============================================================================
    502          */
    503          
    504          void UART1_Callback( uint8_t eventid )
    505          {
    506            int8_t ch;
    507            switch (eventid) 
    508            {
    509            case 0://tx complete
    510              
    511              /*put back the buffer in the free pool*/
    512              
    513              uart1_trigger_tx = 1;
    514              
    515              /*invoke callback informing packet tx completion*/
    516              uart_call_back(NULL,0,0,0);
    517              break;
    518            case 1://rx complete
    519              ch = uart1_rx_byte;
    520              
    521              raw_uart_hal_read(&uart1_rx_byte ,1 );
    522              /*invoke callback informing packet rx completion*/
    523              uart_call_back(NULL,0,1,ch);
    524              break;
    525            case 2:
    526              uart_call_back(NULL,0,2,0);
    527              break;
    528              
    529            default:
    530              break;                    
    531            }
    532            
    533          }
    534          
    535          /*
    536          ** ============================================================================
    537          ** Private Function Definitions
    538          ** ============================================================================
    539          */
    540          
    541          
    542          /**************************************************************************//**
    543          * @brief UART1 RX IRQ Handler
    544          *
    545          * Set up the interrupt prior to use
    546          *
    547          * Note that this function handles overflows in a very simple way.
    548          *
    549          *****************************************************************************/
    550          void USART1_RX_IRQHandler(void)
    551          {
    552            uint8_t rxData;
    553            /* Check for RX data valid interrupt */
    554            if (USART1->STATUS & USART_STATUS_RXDATAV)
    555            {
    556              /* Copy data into RX Buffer */
    557              rxData = USART_Rx(USART1);
    558              /* Clear RXDATAV interrupt */
    559              USART_IntClear(USART1, USART_IF_RXDATAV);
    560              if (g_uart1_rx_length > g_uart1_rx_count)
    561              {
    562                *gp_uart1_rx_address = rxData;
    563                
    564                g_uart1_rx_count++;
    565                
    566                if (g_uart1_rx_length == g_uart1_rx_count)
    567                {
    568                  UART1_Callback(1);
    569                }
    570                else
    571                {
    572                  gp_uart1_rx_address++;
    573                }
    574              }
    575            }
    576            else
    577            {
    578              USART_IntClear(USART1, USART_STATUS_RXFULL);
    579            }
    580          }
    581          
    582          /**************************************************************************//**
    583          * @brief UART1 TX IRQ Handler
    584          *
    585          * Set up the interrupt prior to use
    586          *
    587          *****************************************************************************/
    588          void USART1_TX_IRQHandler(void)
    589          {
    590            /* Check TX buffer level status */
    591            if (USART1->STATUS & USART_STATUS_TXBL)
    592            {
    593              if (g_uart1_tx_count > 0)
    594              {
    595                /* Transmit pending character */
    596                USART_Tx(USART1, *gp_uart1_tx_address++);      
    597                g_uart1_tx_count--;
    598              }
    599              
    600              /* Disable Tx interrupt if no more bytes to be sent */
    601              if (g_uart1_tx_count == 0)
    602              {
    603                USART_IntDisable(USART1, USART_IF_TXBL);
    604                //send end
    605                UART1_Callback(0);
    606              }
    607            }
    608          }
    609          
    610          /**************************************************************************//**
    611          * @brief UART1 TX IRQ Handler
    612          *
    613          * Set up the interrupt prior to use
    614          *
    615          *****************************************************************************/
    616          
    617          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UARTCallback
         8   -- Indirect call
       8   UART_close
         8   -> USART_Reset
      40   UART_init
        40   -> CMU_ClockEnable
        40   -> GPIO_PinModeSet
        40   -> USART_InitAsync
        40   -> USART_IntEnable
        40   -> __NVIC_ClearPendingIRQ
        40   -> __NVIC_EnableIRQ
        40   -> __aeabi_memcpy4
       8   USART0_RX_IRQHandler
         8   -> UARTCallback
         8   -> USART_IntClear
         8   -> USART_Rx
      16   USART0_TX_IRQHandler
        16   -> UARTCallback
        16   -> USART_IntDisable
        16   -> USART_Tx
       0   USART_IntClear
       0   USART_IntDisable
       0   USART_IntEnable
       0   __NVIC_ClearPendingIRQ
       0   __NVIC_EnableIRQ
       0   uart_hal_read
       0   uart_hal_register_back
      16   uart_hal_write
        16   -> USART_IntEnable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      28  ?_0
      58  UARTCallback
      12  UART_close
     128  UART_init
     116  USART0_RX_IRQHandler
      68  USART0_TX_IRQHandler
       8  USART_IntClear
       8  USART_IntDisable
       8  USART_IntEnable
      30  __NVIC_ClearPendingIRQ
      30  __NVIC_EnableIRQ
       2  g_uart0_rx_count
       2  g_uart0_rx_length
       2  g_uart0_tx_count
       2  g_uart1_rx_count
       2  g_uart1_rx_length
       2  g_uart1_tx_count
       4  gp_uart0_rx_address
       4  gp_uart0_tx_address
       4  gp_uart1_rx_address
       4  gp_uart1_tx_address
       4  uart0
      12  uart0_rx_buffer
       1  uart0_trigger_tx
      12  uart1_rx_buffer
       1  uart1_trigger_tx
     100  uart_debug_buff
       2  uart_debug_buff_Cnt
       8  uart_hal_info
      26  uart_hal_read
      12  uart_hal_register_back
      64  uart_hal_write

 
 162 bytes in section .bss
   6 bytes in section .data
  28 bytes in section .rodata
 640 bytes in section .text
 
 640 bytes of CODE  memory
  28 bytes of CONST memory
 168 bytes of DATA  memory

Errors: none
Warnings: 3
