###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         02/Dec/2024  12:57:44
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\ProAppSrc\Util\timer_manager\sw_timer.c
#    Command line                 =
#        -f
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir\sw_timer.o.rsp
#        (D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\ProAppSrc\Util\timer_manager\sw_timer.c
#        -D EFR32FG23A020F512GM40=1 -D SL_COMPONENT_CATALOG_PRESENT=1 -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -lC
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\lst\Util_9809783495009140069.dir
#        --diag_suppress Pa050 -o
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M33 --cmse -e --fpu=VFPv5_sp --dlib_config "C:\Program
#        Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\.\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\AppConfigs\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\config\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\autogen\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\HAL\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\NVM\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Include\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\buffer_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\event_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\list_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\queue_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\timer_manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\hif\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\raw_uart_if\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\Util\debug_console\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\Device\SiliconLabs\EFR32FG23\Include\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\CMSIS\Core\Include\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\device_init\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\common\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\mpu\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\common\toolchain\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\system\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\network-manager\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\RAIL_TRX\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\MAC\Inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\wisun_modified\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\ProAppSrc\FANApp\AppInc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_callbacks\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\ip\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\ipv6\multicast\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\ipv6\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\rpl\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\OS_interface\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\L3\L2_L3_interface\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\cpu\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\Interface_Layer\contiki_mac_interface_layer\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\Interface_Layer\mac_sicslowpan_if\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\emlib\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\os\platform\p3_lp_dk\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\common\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\protocol\ble\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\protocol\ieee802154\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\protocol\zwave\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\pa-conversions\efr32xg1x\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_protocol\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\rail_lib\plugin\rail_util_rssi\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\PHY\radio\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\MeterApp\Inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\emdrv\dmadrv\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\emdrv\common\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\FLASH\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\DebugLog\APP_LOG\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\DebugLog\response_print\config\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\DebugLog\response_print\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\NVM\nvm3\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\..\SiliconLabs\platform\service\iostream\inc\
#        -I
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\
#        -On --use_c++_inline) --dependencies=n
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir\sw_timer.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\lst\Util_9809783495009140069.dir\sw_timer.lst
#    Object file                  =
#        D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\AppBuild\ewarm-iar\obj\Util_9809783495009140069.dir\sw_timer.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

D:\FG23\FG23_final_code\MeshApp_FG23_LBR\Kimbal_MeshApp_FG23_LBR\ProAppSrc\Util\timer_manager\sw_timer.c
      1          /** \file sw_timer.c
      2           *******************************************************************************
      3           ** \brief Implements a software timer functionality
      4           **
      5           ** \cond STD_FILE_HEADER
      6           **
      7           ** COPYRIGHT(c) 2023-24 Procubed Innovations Pvt Ltd.
      8           ** All rights reserved.
      9           **
     10           ** THIS SOFTWARE IS PROVIDED BY "AS IS" AND ALL WARRANTIES OF ANY KIND,
     11           ** INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR USE,
     12           ** ARE EXPRESSLY DISCLAIMED.  THE DEVELOPER SHALL NOT BE LIABLE FOR ANY
     13           ** DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. THIS SOFTWARE
     14           ** MAY NOT BE USED IN PRODUCTS INTENDED FOR USE IN IMPLANTATION OR OTHER
     15           ** DIRECT LIFE SUPPORT APPLICATIONS WHERE MALFUNCTION MAY RESULT IN THE DIRECT
     16           ** PHYSICAL HARM OR INJURY TO PERSONS. ALL SUCH IS USE IS EXPRESSLY PROHIBITED.
     17           **
     18           *******************************************************************************
     19           **  \endcond
     20           */
     21          
     22          /*
     23          ********************************************************************************
     24          * File inclusion
     25          ********************************************************************************
     26          */
     27          
     28          #include "StackPHYConf.h"
     29          #include "common.h"
     30          #include "queue_latest.h"
     31          #include "list_latest.h"
     32          #include "hw_tmr.h"
     33          #include "sw_timer.h"
     34          
     35          /*
     36          ** =============================================================================
     37          ** Private Macro definitions
     38          ** =============================================================================
     39          */
     40          	
     41          /* Indicates software timer expiry event */
     42          //#define SW_TMR_EXPIRE_EVENT    SST_HIGHEST_PRIO_EVENT
     43          
     44          /* Indicates software timer ISR request event */
     45          //#define SW_TMR_ISR_REQ_EVENT   0x02
     46          
     47          /* Indicates the minimum difference allowed between expiry time and the current time */
     48          #define MIN_DIFFERENCE 15
     49          
     50          /*
     51          ** =============================================================================
     52          ** Private Structures, Unions & enums Type Definitions
     53          ** =============================================================================
     54          **/
     55          
     56          /* None */
     57          
     58          /*
     59          ** =============================================================================
     60          ** Private Variable Definitions
     61          ** =============================================================================
     62          */
     63          
     64          /* None */
     65          
     66          /*
     67          ** =============================================================================
     68          ** Private Function Prototypes
     69          ** =============================================================================
     70          */
     71          
     72          /* None */
     73          
     74          /*
     75          ** =============================================================================
     76          ** Private Function Definitions
     77          ** =============================================================================
     78          */
     79          
     80          /* None */
     81          
     82          /*
     83          ** =============================================================================
     84          ** External Variable Declarations
     85          ** =============================================================================
     86          */
     87          
     88          #ifndef EFM32_TARGET_IAR
     89          extern volatile uint16_t system_time;
     90          #endif
     91          
     92          /*
     93          ** =============================================================================
     94          ** External Function Prototypes
     95          ** =============================================================================
     96          */
     97          
     98          /* None */
     99          
    100          /*
    101          ** =============================================================================
    102          ** Public Variables Definitions
    103          ** =============================================================================
    104          **/
    105          

   \                                 In section .bss, align 2
    106          uint16_t a_big_problem = 0;
   \                     a_big_problem:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
    107          sw_tmr_module_t* gptmr_mod_ins = {0};
   \                     gptmr_mod_ins:
   \        0x0                      DS8 4
    108          
    109          /*
    110          ** =============================================================================
    111          ** Public Function Prototypes
    112          ** =============================================================================
    113          */
    114          
    115          /* None */
    116          
    117          /*
    118          ** =============================================================================
    119          ** Public Function Definitions
    120          ** =============================================================================
    121          */
    122          

   \                                 In section .text, align 2, keep-with-next
    123          void sw_tmr_init( sw_tmr_module_t *pTmr_mod_ins )
    124          { 
   \                     sw_tmr_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    125                  gptmr_mod_ins = pTmr_mod_ins;
   \        0x4   0x....             LDR.N    R0,??DataTable1
   \        0x6   0x6004             STR      R4,[R0, #+0]
    126          	p3list_init( &pTmr_mod_ins->tmr_active_list );    
   \        0x8   0x1D20             ADDS     R0,R4,#+4
   \        0xA   0x.... 0x....      BL       p3list_init
    127          	p3list_init( &pTmr_mod_ins->tmr_exp_list );
   \        0xE   0xF114 0x000C      ADDS     R0,R4,#+12
   \       0x12   0x.... 0x....      BL       p3list_init
    128          	p3list_init( &pTmr_mod_ins->tmr_pend_list );
   \       0x16   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x1A   0x.... 0x....      BL       p3list_init
    129          	p3list_init( &pTmr_mod_ins->isr_req_q );
   \       0x1E   0xF114 0x0030      ADDS     R0,R4,#+48
   \       0x22   0x.... 0x....      BL       p3list_init
    130                  pTmr_mod_ins->hw_timer_if.hw_tmr_init( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins, pTmr_mod_ins );
   \       0x26   0x0021             MOVS     R1,R4
   \       0x28   0x6920             LDR      R0,[R4, #+16]
   \       0x2A   0x6962             LDR      R2,[R4, #+20]
   \       0x2C   0x4790             BLX      R2
    131          
    132              return;
   \       0x2E   0xBD10             POP      {R4,PC}
    133          }
    134          /*----------------------------------------------------------------------------*/
    135          //Why sw_tmr_module_t *pTmr_mod_ins parameter is recieved when we are not using 
    136          //it in this function. 

   \                                 In section .text, align 2, keep-with-next
    137          bool sw_tmr_create( sw_tmr_t *pTmr_ins, stime_t period, sw_tmr_cb_t cb, void* param )
    138          {
   \                     sw_tmr_create: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0004             MOVS     R4,R0
    139              pTmr_ins->period = period;
   \        0x4   0x60E1             STR      R1,[R4, #+12]
    140              pTmr_ins->cb = cb;
   \        0x6   0x6122             STR      R2,[R4, #+16]
    141              pTmr_ins->cb_param = param;
   \        0x8   0x6163             STR      R3,[R4, #+20]
    142              pTmr_ins->type = SW_TMR_ONESHOT;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x7120             STRB     R0,[R4, #+4]
    143              pTmr_ins->state = SW_TMR_CREATED;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x71A0             STRB     R0,[R4, #+6]
    144              return TRUE;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xBC10             POP      {R4}
   \       0x16   0x4770             BX       LR
    145          }
    146          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    147          void handle_system_time_rollover( sw_tmr_module_t *pTmr_mod_ins )
    148          {
   \                     handle_system_time_rollover: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
    149          	sw_tmr_t *pTmr_cur_ins = NULL;
   \        0x4   0x2600             MOVS     R6,#+0
    150          
    151          	/*All active timers will be expired by now. So copy active Q into Expired Q */
    152          	list_concat(&(pTmr_mod_ins->tmr_exp_list),&(pTmr_mod_ins->tmr_active_list) );
   \        0x6   0x1D29             ADDS     R1,R5,#+4
   \        0x8   0xF115 0x000C      ADDS     R0,R5,#+12
   \        0xC   0x.... 0x....      BL       list_concat
    153          	pTmr_cur_ins = ( sw_tmr_t* )list_entry_get_start( &pTmr_mod_ins->tmr_exp_list );
   \       0x10   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x14   0x.... 0x....      BL       list_entry_get_start
   \       0x18   0x0004             MOVS     R4,R0
    154          	
    155          	while((NULL != pTmr_cur_ins) /*&& (((pTmr_cur_ins->exp_time >> 16) == 0x0000FFFF))*/)
   \                     ??handle_system_time_rollover_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD008             BEQ.N    ??handle_system_time_rollover_1
    156          	{		
    157                      /*if the HIGH part of the expiry time is same as */
    158                      pTmr_cur_ins->state = SW_TMR_EXPIRED;
   \       0x1E   0x2003             MOVS     R0,#+3
   \       0x20   0x71A0             STRB     R0,[R4, #+6]
    159                      pTmr_cur_ins = ( sw_tmr_t* )list_entry_scan_next( &pTmr_mod_ins->tmr_exp_list, ( list_item_t* )pTmr_cur_ins );
   \       0x22   0x0021             MOVS     R1,R4
   \       0x24   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x28   0x.... 0x....      BL       list_entry_scan_next
   \       0x2C   0x0004             MOVS     R4,R0
   \       0x2E   0xE7F4             B.N      ??handle_system_time_rollover_0
    160          	}
    161          	
    162          	list_entry_set_start( &pTmr_mod_ins->tmr_active_list,( list_item_t* )pTmr_cur_ins );	
   \                     ??handle_system_time_rollover_1: (+1)
   \       0x30   0x0021             MOVS     R1,R4
   \       0x32   0x1D28             ADDS     R0,R5,#+4
   \       0x34   0x.... 0x....      BL       list_entry_set_start
    163          	list_entry_set_start( &pTmr_mod_ins->tmr_active_list,( list_item_t* )pTmr_cur_ins );	
   \       0x38   0x0021             MOVS     R1,R4
   \       0x3A   0x1D28             ADDS     R0,R5,#+4
   \       0x3C   0x.... 0x....      BL       list_entry_set_start
    164          	list_concat(&(pTmr_mod_ins->tmr_active_list),&(pTmr_mod_ins->tmr_pend_list) );
   \       0x40   0xF115 0x0108      ADDS     R1,R5,#+8
   \       0x44   0x1D28             ADDS     R0,R5,#+4
   \       0x46   0x.... 0x....      BL       list_concat
    165          	list_entry_set_start( &pTmr_mod_ins->tmr_pend_list, NULL );
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x50   0x.... 0x....      BL       list_entry_set_start
    166          
    167          }
   \       0x54   0xBD70             POP      {R4-R6,PC}
    168          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    169          p3time_t sw_current_time_get( sw_tmr_module_t *pTmr_mod_ins )
    170          {
   \                     sw_current_time_get: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    171              return pTmr_mod_ins->hw_timer_if.hw_tmr_get_time( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins);
   \        0x4   0x6920             LDR      R0,[R4, #+16]
   \        0x6   0x6A21             LDR      R1,[R4, #+32]
   \        0x8   0x4788             BLX      R1
   \        0xA   0xBD10             POP      {R4,PC}
    172          }
    173          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    174          uint8_t sw_tmr_rand_get( sw_tmr_module_t *pTmr_mod_ins )
    175          {
   \                     sw_tmr_rand_get: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    176              return pTmr_mod_ins->hw_timer_if.hw_tmr_rand( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins);
   \        0x4   0x6920             LDR      R0,[R4, #+16]
   \        0x6   0x6A61             LDR      R1,[R4, #+36]
   \        0x8   0x4788             BLX      R1
   \        0xA   0xBD10             POP      {R4,PC}
    177          }
    178          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    179          void sw_tmr_delay( sw_tmr_module_t *pTmr_mod_ins, uint32_t duration_tks )
    180          {
   \                     sw_tmr_delay: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    181               pTmr_mod_ins->hw_timer_if.hw_tmr_delay( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins, duration_tks);
   \        0x6   0x0029             MOVS     R1,R5
   \        0x8   0x6920             LDR      R0,[R4, #+16]
   \        0xA   0x6AA2             LDR      R2,[R4, #+40]
   \        0xC   0x4790             BLX      R2
    182          }
   \        0xE   0xBD31             POP      {R0,R4,R5,PC}
    183          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    184          void sw_tmr_stop( sw_tmr_module_t *pTmr_mod_ins, sw_tmr_t *pTmr_ins )
    185          {
   \                     sw_tmr_stop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    186              list_item_t* next_tmr;       
    187              if( list_entry_is_start( &pTmr_mod_ins->tmr_active_list, ( list_item_t* )pTmr_ins ))
   \        0x6   0x0031             MOVS     R1,R6
   \        0x8   0x1D28             ADDS     R0,R5,#+4
   \        0xA   0x.... 0x....      BL       list_entry_is_start
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD00D             BEQ.N    ??sw_tmr_stop_0
    188              {
    189                  pTmr_mod_ins->hw_timer_if.hw_tmr_stop(  pTmr_mod_ins->hw_timer_if.pHw_tmr_ins );        
   \       0x12   0x6928             LDR      R0,[R5, #+16]
   \       0x14   0x69E9             LDR      R1,[R5, #+28]
   \       0x16   0x4788             BLX      R1
    190                  next_tmr = list_entry_scan_next	( &pTmr_mod_ins->tmr_active_list, ( list_item_t* )pTmr_ins );
   \       0x18   0x0031             MOVS     R1,R6
   \       0x1A   0x1D28             ADDS     R0,R5,#+4
   \       0x1C   0x.... 0x....      BL       list_entry_scan_next
   \       0x20   0x0004             MOVS     R4,R0
    191                      		
    192                  if( NULL != next_tmr )
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD003             BEQ.N    ??sw_tmr_stop_0
    193                  {
    194                      //printf("Place1\n\r");
    195                      pTmr_mod_ins->hw_timer_if.hw_tmr_start ( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins, pTmr_ins->exp_time );
   \       0x26   0x68B1             LDR      R1,[R6, #+8]
   \       0x28   0x6928             LDR      R0,[R5, #+16]
   \       0x2A   0x69AA             LDR      R2,[R5, #+24]
   \       0x2C   0x4790             BLX      R2
    196                  }
    197              }    
    198              list_entry_delete( &pTmr_mod_ins->tmr_active_list, (list_item_t*)pTmr_ins );
   \                     ??sw_tmr_stop_0: (+1)
   \       0x2E   0x0031             MOVS     R1,R6
   \       0x30   0x1D28             ADDS     R0,R5,#+4
   \       0x32   0x.... 0x....      BL       list_entry_delete
    199              list_entry_delete( &pTmr_mod_ins->tmr_pend_list, (list_item_t*)pTmr_ins );
   \       0x36   0x0031             MOVS     R1,R6
   \       0x38   0xF115 0x0008      ADDS     R0,R5,#+8
   \       0x3C   0x.... 0x....      BL       list_entry_delete
    200              return;
   \       0x40   0xBD70             POP      {R4-R6,PC}
    201          }
    202          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    203          void sw_tmr_add_to_active_list( sw_tmr_module_t *pTmr_mod_ins, sw_tmr_t *timer,uint8_t add_to_pend )
    204          {
   \                     sw_tmr_add_to_active_list: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    205              sw_tmr_t* pTmr_cur, *pTmr_prev;
    206              p3_list_t* p_list = (add_to_pend)?&(pTmr_mod_ins->tmr_pend_list ):&(pTmr_mod_ins->tmr_active_list);
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD002             BEQ.N    ??sw_tmr_add_to_active_list_0
   \       0x12   0xF115 0x0808      ADDS     R8,R5,#+8
   \       0x16   0xE001             B.N      ??sw_tmr_add_to_active_list_1
   \                     ??sw_tmr_add_to_active_list_0: (+1)
   \       0x18   0xF115 0x0804      ADDS     R8,R5,#+4
    207          	
    208              /* Stop the timer if it is alredy running */
    209              if( timer->state == SW_TMR_ACTIVE )
   \                     ??sw_tmr_add_to_active_list_1: (+1)
   \       0x1C   0x79B0             LDRB     R0,[R6, #+6]
   \       0x1E   0x2802             CMP      R0,#+2
   \       0x20   0xD104             BNE.N    ??sw_tmr_add_to_active_list_2
    210                  sw_tmr_stop( pTmr_mod_ins, timer );
   \       0x22   0x0031             MOVS     R1,R6
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       sw_tmr_stop
   \       0x2A   0xE007             B.N      ??sw_tmr_add_to_active_list_3
    211              else if( timer->state == SW_TMR_EXPIRED )
   \                     ??sw_tmr_add_to_active_list_2: (+1)
   \       0x2C   0x79B0             LDRB     R0,[R6, #+6]
   \       0x2E   0x2803             CMP      R0,#+3
   \       0x30   0xD104             BNE.N    ??sw_tmr_add_to_active_list_3
    212                  list_entry_delete( &pTmr_mod_ins->tmr_exp_list, (list_item_t*)timer );
   \       0x32   0x0031             MOVS     R1,R6
   \       0x34   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x38   0x.... 0x....      BL       list_entry_delete
    213          
    214              /* Adding the timer into the timer link list at an appropriate location */
    215              pTmr_cur = pTmr_prev = ( sw_tmr_t* )list_entry_get_start( p_list );
   \                     ??sw_tmr_add_to_active_list_3: (+1)
   \       0x3C   0x4640             MOV      R0,R8
   \       0x3E   0x.... 0x....      BL       list_entry_get_start
   \       0x42   0x4681             MOV      R9,R0
   \       0x44   0x464C             MOV      R4,R9
    216          
    217              while( NULL != pTmr_cur )
   \                     ??sw_tmr_add_to_active_list_4: (+1)
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD00A             BEQ.N    ??sw_tmr_add_to_active_list_5
    218              {
    219                  if( pTmr_cur->exp_time > timer->exp_time )
   \       0x4A   0x68B1             LDR      R1,[R6, #+8]
   \       0x4C   0x68A0             LDR      R0,[R4, #+8]
   \       0x4E   0x4281             CMP      R1,R0
   \       0x50   0xD306             BCC.N    ??sw_tmr_add_to_active_list_5
    220                    break;
    221                  pTmr_prev = pTmr_cur;
   \                     ??sw_tmr_add_to_active_list_6: (+1)
   \       0x52   0x46A1             MOV      R9,R4
    222                  pTmr_cur = ( sw_tmr_t* )list_entry_scan_next( p_list, ( list_item_t* )pTmr_cur );	
   \       0x54   0x0021             MOVS     R1,R4
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x.... 0x....      BL       list_entry_scan_next
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0xE7F2             B.N      ??sw_tmr_add_to_active_list_4
    223              }
    224              timer->state = SW_TMR_ACTIVE;
   \                     ??sw_tmr_add_to_active_list_5: (+1)
   \       0x60   0x2002             MOVS     R0,#+2
   \       0x62   0x71B0             STRB     R0,[R6, #+6]
    225              /* The new timer is the first to expire, so need to be put at the head */
    226              if( pTmr_prev == pTmr_cur )
   \       0x64   0x45A1             CMP      R9,R4
   \       0x66   0xD111             BNE.N    ??sw_tmr_add_to_active_list_7
    227              {
    228                  p3list_entry_add_start( p_list, ( list_item_t* )timer );	    
   \       0x68   0x0031             MOVS     R1,R6
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x.... 0x....      BL       p3list_entry_add_start
    229                  if ( add_to_pend == 0 )
   \       0x70   0x0038             MOVS     R0,R7
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD110             BNE.N    ??sw_tmr_add_to_active_list_8
    230                  {
    231                  /* Stop the timer and start the timer with the new expire time */
    232                      if( NULL != pTmr_cur )
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD002             BEQ.N    ??sw_tmr_add_to_active_list_9
    233                      {
    234                              pTmr_mod_ins->hw_timer_if.hw_tmr_stop(pTmr_mod_ins->hw_timer_if.pHw_tmr_ins );
   \       0x7C   0x6928             LDR      R0,[R5, #+16]
   \       0x7E   0x69E9             LDR      R1,[R5, #+28]
   \       0x80   0x4788             BLX      R1
    235                      }
    236                      //printf("Place3\n\r");    
    237                      pTmr_mod_ins->hw_timer_if.hw_tmr_start(pTmr_mod_ins->hw_timer_if.pHw_tmr_ins, timer->exp_time );
   \                     ??sw_tmr_add_to_active_list_9: (+1)
   \       0x82   0x68B1             LDR      R1,[R6, #+8]
   \       0x84   0x6928             LDR      R0,[R5, #+16]
   \       0x86   0x69AA             LDR      R2,[R5, #+24]
   \       0x88   0x4790             BLX      R2
   \       0x8A   0xE006             B.N      ??sw_tmr_add_to_active_list_8
    238                  }
    239              }
    240              else /* If it is at the end or in between the list */
    241              {
    242                  if( (( list_item_t* )timer)  != (( list_item_t* )pTmr_prev))
   \                     ??sw_tmr_add_to_active_list_7: (+1)
   \       0x8C   0x454E             CMP      R6,R9
   \       0x8E   0xD004             BEQ.N    ??sw_tmr_add_to_active_list_8
    243                  {
    244                  	list_entry_add_after( p_list, ( list_item_t* )timer, ( list_item_t* )pTmr_prev );	    	     
   \       0x90   0x464A             MOV      R2,R9
   \       0x92   0x0031             MOVS     R1,R6
   \       0x94   0x4640             MOV      R0,R8
   \       0x96   0x.... 0x....      BL       list_entry_add_after
    245                  }    	
    246              }                
    247          }
   \                     ??sw_tmr_add_to_active_list_8: (+1)
   \       0x9A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
    248          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    249          void update_expired_tmr_list(sw_tmr_module_t *pTmr_mod_ins)
    250          {
   \                     update_expired_tmr_list: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
    251          	sw_tmr_t *pTmr_prv_ins = NULL;
   \        0x6   0x2500             MOVS     R5,#+0
    252          	p3time_t current_time;
    253          	p3time_t diff;
    254          
    255          	sw_tmr_t *pTmr_cur_ins = ( sw_tmr_t* )list_entry_get_start( &pTmr_mod_ins->tmr_active_list );	
   \        0x8   0xF118 0x0004      ADDS     R0,R8,#+4
   \        0xC   0x.... 0x....      BL       list_entry_get_start
   \       0x10   0x0004             MOVS     R4,R0
    256          	list_concat(&(pTmr_mod_ins->tmr_exp_list),&(pTmr_mod_ins->tmr_active_list) );
   \       0x12   0xF118 0x0104      ADDS     R1,R8,#+4
   \       0x16   0xF118 0x000C      ADDS     R0,R8,#+12
   \       0x1A   0x.... 0x....      BL       list_concat
    257          	
    258          	while( NULL != pTmr_cur_ins )
   \                     ??update_expired_tmr_list_0: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD03C             BEQ.N    ??update_expired_tmr_list_1
    259          	{  
    260                    current_time = pTmr_mod_ins->hw_timer_if.hw_tmr_get_time(pTmr_mod_ins->hw_timer_if.pHw_tmr_ins ); 
   \       0x22   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x26   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \       0x2A   0x4788             BLX      R1
   \       0x2C   0x0006             MOVS     R6,R0
    261                    /* Find all expired timer. A timer is expired if the current  
    262                    time is greater or less than the timer expire time. */
    263                    if( pTmr_cur_ins->exp_time <= current_time )
   \       0x2E   0x68A0             LDR      R0,[R4, #+8]
   \       0x30   0x4286             CMP      R6,R0
   \       0x32   0xD309             BCC.N    ??update_expired_tmr_list_2
    264                    {
    265                        pTmr_cur_ins->state = SW_TMR_EXPIRED;
   \       0x34   0x2003             MOVS     R0,#+3
   \       0x36   0x71A0             STRB     R0,[R4, #+6]
    266                        pTmr_prv_ins = pTmr_cur_ins;
   \       0x38   0x0025             MOVS     R5,R4
    267                        pTmr_cur_ins = ( sw_tmr_t* )list_entry_scan_next( &pTmr_mod_ins->tmr_active_list, ( list_item_t* )pTmr_cur_ins );
   \       0x3A   0x0021             MOVS     R1,R4
   \       0x3C   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x40   0x.... 0x....      BL       list_entry_scan_next
   \       0x44   0x0004             MOVS     R4,R0
   \       0x46   0xE7EA             B.N      ??update_expired_tmr_list_0
    268                    }
    269                    else
    270                    {
    271                        /* Start the timer with the next expire time     NextLocation->expireTime */
    272                        //printf("Place2\n\r");      
    273                        /*may come here as a result of high time (system_time) overflow 
    274                        while timer0 channel is running. So do not again start the same timer.*/
    275                        if( ((hw_tmr_t*)pTmr_mod_ins->hw_timer_if.pHw_tmr_ins)->low_time_us )
   \                     ??update_expired_tmr_list_2: (+1)
   \       0x48   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x4C   0x8980             LDRH     R0,[R0, #+12]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD129             BNE.N    ??update_expired_tmr_list_3
    276                        {
    277                           return;				
    278                        }
    279                        current_time = pTmr_mod_ins->hw_timer_if.hw_tmr_get_time(pTmr_mod_ins->hw_timer_if.pHw_tmr_ins ); 
   \                     ??update_expired_tmr_list_4: (+1)
   \       0x52   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x56   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \       0x5A   0x4788             BLX      R1
   \       0x5C   0x0006             MOVS     R6,R0
    280                        diff = pTmr_cur_ins->exp_time - current_time;
   \       0x5E   0x68A0             LDR      R0,[R4, #+8]
   \       0x60   0x1B80             SUBS     R0,R0,R6
   \       0x62   0x0007             MOVS     R7,R0
    281                        if ( pTmr_cur_ins->exp_time <= current_time )
   \       0x64   0x68A0             LDR      R0,[R4, #+8]
   \       0x66   0x4286             CMP      R6,R0
   \       0x68   0xD301             BCC.N    ??update_expired_tmr_list_5
    282                        {
    283                            diff = 0;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x0007             MOVS     R7,R0
    284                        }
    285                        
    286                        if( diff >= MIN_DIFFERENCE )
   \                     ??update_expired_tmr_list_5: (+1)
   \       0x6E   0x2F0F             CMP      R7,#+15
   \       0x70   0xD30A             BCC.N    ??update_expired_tmr_list_6
    287                        {
    288                            /* NULL check is not needed, but good to have a safe check */	    
    289                            if( NULL != pTmr_prv_ins )
   \       0x72   0x2D00             CMP      R5,#+0
   \       0x74   0xD001             BEQ.N    ??update_expired_tmr_list_7
    290                            {
    291                                /* Terminate the expire link list */										   
    292                                pTmr_prv_ins->next = NULL;					  
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x6028             STR      R0,[R5, #+0]
    293                            }
    294                            pTmr_mod_ins->hw_timer_if.hw_tmr_start( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins, pTmr_cur_ins->exp_time );
   \                     ??update_expired_tmr_list_7: (+1)
   \       0x7A   0x68A1             LDR      R1,[R4, #+8]
   \       0x7C   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x80   0xF8D8 0x2018      LDR      R2,[R8, #+24]
   \       0x84   0x4790             BLX      R2
    295                            break;
   \       0x86   0xE009             B.N      ??update_expired_tmr_list_1
    296                        }
    297                        else
    298                        {				
    299                            pTmr_cur_ins->state = SW_TMR_EXPIRED;
   \                     ??update_expired_tmr_list_6: (+1)
   \       0x88   0x2003             MOVS     R0,#+3
   \       0x8A   0x71A0             STRB     R0,[R4, #+6]
    300                            pTmr_prv_ins = pTmr_cur_ins;
   \       0x8C   0x0025             MOVS     R5,R4
    301                            pTmr_cur_ins = ( sw_tmr_t* )list_entry_scan_next( &pTmr_mod_ins->tmr_active_list, ( list_item_t* )pTmr_cur_ins );
   \       0x8E   0x0021             MOVS     R1,R4
   \       0x90   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0x94   0x.... 0x....      BL       list_entry_scan_next
   \       0x98   0x0004             MOVS     R4,R0
   \       0x9A   0xE7C0             B.N      ??update_expired_tmr_list_0
    302                        }	                  
    303                    }
    304          	}
    305          	/* Detach expired timer list from the the active timer list */
    306          	list_entry_set_start( &pTmr_mod_ins->tmr_active_list, ( list_item_t* )pTmr_cur_ins );	
   \                     ??update_expired_tmr_list_1: (+1)
   \       0x9C   0x0021             MOVS     R1,R4
   \       0x9E   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0xA2   0x.... 0x....      BL       list_entry_set_start
    307          }
   \                     ??update_expired_tmr_list_3: (+1)
   \       0xA6   0xE8BD 0x81F0      POP      {R4-R8,PC}
    308          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    309          void invoke_expired_timer_cbs(sw_tmr_module_t *pTmr_mod_ins)
    310          {
   \                     invoke_expired_timer_cbs: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
    311              sw_tmr_t *pTmr_prv_ins = NULL;
   \        0x4   0x2600             MOVS     R6,#+0
    312              p3time_t tmp = 0;
   \        0x6   0x2700             MOVS     R7,#+0
    313              //irq_state_t flags = irq_disable();
    314              
    315              sw_tmr_t *pTmr_cur_ins = ( sw_tmr_t* )list_entry_get_start( &pTmr_mod_ins->tmr_exp_list );
   \        0x8   0xF115 0x000C      ADDS     R0,R5,#+12
   \        0xC   0x.... 0x....      BL       list_entry_get_start
   \       0x10   0x0004             MOVS     R4,R0
    316              /* If any timer expired then call the cb of the expired timer one by one */
    317              while( NULL != pTmr_cur_ins )
   \                     ??invoke_expired_timer_cbs_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD02C             BEQ.N    ??invoke_expired_timer_cbs_1
    318              {
    319                  pTmr_prv_ins = pTmr_cur_ins;
   \       0x16   0x0026             MOVS     R6,R4
    320                  pTmr_cur_ins = ( sw_tmr_t* )list_entry_scan_next( &(pTmr_mod_ins->tmr_exp_list),( list_item_t* )pTmr_cur_ins );
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x1E   0x.... 0x....      BL       list_entry_scan_next
   \       0x22   0x0004             MOVS     R4,R0
    321                  if( pTmr_prv_ins->state == SW_TMR_EXPIRED )
   \       0x24   0x79B0             LDRB     R0,[R6, #+6]
   \       0x26   0x2803             CMP      R0,#+3
   \       0x28   0xD10B             BNE.N    ??invoke_expired_timer_cbs_2
    322                  {
    323                      //irq_enable( flags );          
    324          	    /* Call the CB of the expired soft timer */
    325                      if( pTmr_prv_ins->cb != NULL )
   \       0x2A   0x6930             LDR      R0,[R6, #+16]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD004             BEQ.N    ??invoke_expired_timer_cbs_3
    326                      {
    327                        pTmr_prv_ins->cb( pTmr_prv_ins->cb_param, pTmr_prv_ins );
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0x6970             LDR      R0,[R6, #+20]
   \       0x34   0x6932             LDR      R2,[R6, #+16]
   \       0x36   0x4790             BLX      R2
   \       0x38   0xE003             B.N      ??invoke_expired_timer_cbs_2
    328                      }
    329                      else            
    330                      {
    331                        a_big_problem++;
   \                     ??invoke_expired_timer_cbs_3: (+1)
   \       0x3A   0x....             LDR.N    R1,??DataTable1_1
   \       0x3C   0x8808             LDRH     R0,[R1, #+0]
   \       0x3E   0x1C40             ADDS     R0,R0,#+1
   \       0x40   0x8008             STRH     R0,[R1, #+0]
    332                      } 	    
    333          	    //flags = irq_disable(); 
    334                   }
    335                  
    336                  /* If it is a periodic timer then start it again by adding it to 
    337                  the active timer list. If the periodic timer is stopped in the cb, 
    338                  then the timer type is marked as stopped ,
    339                  so the timer is not started again below */
    340                  if( ( SW_TMR_PERIODIC == pTmr_prv_ins->type ) &&  ( SW_TMR_STOPPED != pTmr_prv_ins->state ) )
   \                     ??invoke_expired_timer_cbs_2: (+1)
   \       0x42   0x7930             LDRB     R0,[R6, #+4]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD1E4             BNE.N    ??invoke_expired_timer_cbs_0
   \       0x48   0x79B0             LDRB     R0,[R6, #+6]
   \       0x4A   0x2804             CMP      R0,#+4
   \       0x4C   0xD0E1             BEQ.N    ??invoke_expired_timer_cbs_0
    341                  {   
    342                      	tmp = pTmr_prv_ins->exp_time;
   \       0x4E   0x68B0             LDR      R0,[R6, #+8]
   \       0x50   0x0007             MOVS     R7,R0
    343          		pTmr_prv_ins->exp_time = tmp + pTmr_prv_ins->period;
   \       0x52   0x68F0             LDR      R0,[R6, #+12]
   \       0x54   0x19C0             ADDS     R0,R0,R7
   \       0x56   0x60B0             STR      R0,[R6, #+8]
    344          		/*TBD: may be it is good to have a check before deciding 
    345          		to add the timer into the pending Q. After the summation, 
    346          		if the sum is lesser  than the value what it held previosuly 
    347          		before adding the period, then we are deciding it to add into the pending Q. 
    348          		Do we also have to make sure that the sum is lesser than the 
    349          		current time to indicate that it should be put into pending state???? */
    350          		sw_tmr_add_to_active_list( pTmr_mod_ins, pTmr_prv_ins,(pTmr_prv_ins->exp_time < tmp)?1:0);
   \       0x58   0x68B0             LDR      R0,[R6, #+8]
   \       0x5A   0x42B8             CMP      R0,R7
   \       0x5C   0xD201             BCS.N    ??invoke_expired_timer_cbs_4
   \       0x5E   0x2201             MOVS     R2,#+1
   \       0x60   0xE000             B.N      ??invoke_expired_timer_cbs_5
   \                     ??invoke_expired_timer_cbs_4: (+1)
   \       0x62   0x2200             MOVS     R2,#+0
   \                     ??invoke_expired_timer_cbs_5: (+1)
   \       0x64   0xB2D2             UXTB     R2,R2
   \       0x66   0x0031             MOVS     R1,R6
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0x.... 0x....      BL       sw_tmr_add_to_active_list
   \       0x6E   0xE7D0             B.N      ??invoke_expired_timer_cbs_0
    351                  }              
    352              }
    353               list_entry_set_start( &(pTmr_mod_ins->tmr_exp_list), NULL );     
   \                     ??invoke_expired_timer_cbs_1: (+1)
   \       0x70   0x2100             MOVS     R1,#+0
   \       0x72   0xF115 0x000C      ADDS     R0,R5,#+12
   \       0x76   0x.... 0x....      BL       list_entry_set_start
    354              //irq_enable( flags );
    355          }
   \       0x7A   0xBDF1             POP      {R0,R4-R7,PC}
    356          /*----------------------------------------------------------------------------*/
    357          

   \                                 In section .text, align 2, keep-with-next
    358          stime_t sw_tmr_remaining_time_get( sw_tmr_module_t *pTmr_mod_ins, sw_tmr_t *pTmr_ins )
    359          {
   \                     sw_tmr_remaining_time_get: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    360              stime_t remaing_time;
    361              sw_tmr_stime_sub( remaing_time, pTmr_ins->exp_time, pTmr_mod_ins->hw_timer_if.hw_tmr_get_time(pTmr_mod_ins->hw_timer_if.pHw_tmr_ins ));
   \        0x6   0x6920             LDR      R0,[R4, #+16]
   \        0x8   0x6A21             LDR      R1,[R4, #+32]
   \        0xA   0x4788             BLX      R1
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0x68A8             LDR      R0,[R5, #+8]
   \       0x10   0x1A40             SUBS     R0,R0,R1
    362              return remaing_time;
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
    363          }
    364          
    365          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    366          stime_t sw_tmr_get_min_of_all_remaining_time( sw_tmr_module_t *pTmr_mod_ins )
    367          {
   \                     sw_tmr_get_min_of_all_remaining_time: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    368              stime_t remaing_time;
    369              sw_tmr_t* pTmr = ( sw_tmr_t* )( list_entry_get_start( &pTmr_mod_ins->tmr_active_list ));
   \        0x4   0x1D20             ADDS     R0,R4,#+4
   \        0x6   0x.... 0x....      BL       list_entry_get_start
   \        0xA   0x0005             MOVS     R5,R0
    370              sw_tmr_stime_sub( remaing_time, pTmr->exp_time, pTmr_mod_ins->hw_timer_if.hw_tmr_get_time( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins ));
   \        0xC   0x6920             LDR      R0,[R4, #+16]
   \        0xE   0x6A21             LDR      R1,[R4, #+32]
   \       0x10   0x4788             BLX      R1
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0x68A8             LDR      R0,[R5, #+8]
   \       0x16   0x1A40             SUBS     R0,R0,R1
    371              return remaing_time;
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
    372          }
    373          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    374          bool sw_tmr_is_active( sw_tmr_t *pTmr_ins )
    375          {
    376              return ( pTmr_ins->state == SW_TMR_ACTIVE );
   \                     sw_tmr_is_active: (+1)
   \        0x0   0x7980             LDRB     R0,[R0, #+6]
   \        0x2   0x2802             CMP      R0,#+2
   \        0x4   0xD101             BNE.N    ??sw_tmr_is_active_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE000             B.N      ??sw_tmr_is_active_1
   \                     ??sw_tmr_is_active_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \                     ??sw_tmr_is_active_1: (+1)
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x4770             BX       LR
    377          }
    378          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    379          stime_t sw_tmr_period_get( sw_tmr_module_t *pTmr_mod_ins, sw_tmr_t *pTmr_ins )
    380          {
   \                     sw_tmr_period_get: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    381              return pTmr_ins->period;
   \        0x2   0x68C8             LDR      R0,[R1, #+12]
   \        0x4   0x4770             BX       LR
    382          }
    383          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    384          void sw_tmr_time_update_req ( sw_tmr_module_t *pTmr_mod_ins, sw_tmr_cb_t cb, void *param)
    385          {
    386          
    387          }
   \                     sw_tmr_time_update_req: (+1)
   \        0x0   0x4770             BX       LR
    388          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    389          void sw_tmr_deinit( sw_tmr_module_t *pTmr_mod_ins )
    390          {
    391            
    392          }
   \                     sw_tmr_deinit: (+1)
   \        0x0   0x4770             BX       LR
    393          /*----------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    394          uint32_t  sw_tmr_get_sys_time_high( sw_tmr_module_t *pTmr_mod_ins )
    395          {
   \                     sw_tmr_get_sys_time_high: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    396          #if defined (EFM32_TARGET_IAR)
    397              return pTmr_mod_ins->hw_timer_if.hw_tmr_get_time( pTmr_mod_ins->hw_timer_if.pHw_tmr_ins);
   \        0x4   0x6920             LDR      R0,[R4, #+16]
   \        0x6   0x6A21             LDR      R1,[R4, #+32]
   \        0x8   0x4788             BLX      R1
   \        0xA   0xBD10             POP      {R4,PC}
    398          #else
    399               return system_time; 
    400          #endif  
    401          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     gptmr_mod_ins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     a_big_problem
    402          /*----------------------------------------------------------------------------*/
    403          
    404          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   handle_system_time_rollover
        16   -> list_concat
        16   -> list_entry_get_start
        16   -> list_entry_scan_next
        16   -> list_entry_set_start
      24   invoke_expired_timer_cbs
        24   -- Indirect call
        24   -> list_entry_get_start
        24   -> list_entry_scan_next
        24   -> list_entry_set_start
        24   -> sw_tmr_add_to_active_list
       8   sw_current_time_get
         8   -- Indirect call
      32   sw_tmr_add_to_active_list
        32   -- Indirect call
        32   -> list_entry_add_after
        32   -> list_entry_delete
        32   -> list_entry_get_start
        32   -> list_entry_scan_next
        32   -> p3list_entry_add_start
        32   -> sw_tmr_stop
       4   sw_tmr_create
       0   sw_tmr_deinit
      16   sw_tmr_delay
        16   -- Indirect call
      16   sw_tmr_get_min_of_all_remaining_time
        16   -- Indirect call
        16   -> list_entry_get_start
       8   sw_tmr_get_sys_time_high
         8   -- Indirect call
       8   sw_tmr_init
         8   -- Indirect call
         8   -> p3list_init
       0   sw_tmr_is_active
       0   sw_tmr_period_get
       8   sw_tmr_rand_get
         8   -- Indirect call
      16   sw_tmr_remaining_time_get
        16   -- Indirect call
      16   sw_tmr_stop
        16   -- Indirect call
        16   -> list_entry_delete
        16   -> list_entry_is_start
        16   -> list_entry_scan_next
       0   sw_tmr_time_update_req
      24   update_expired_tmr_list
        24   -- Indirect call
        24   -> list_concat
        24   -> list_entry_get_start
        24   -> list_entry_scan_next
        24   -> list_entry_set_start


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       2  a_big_problem
       4  gptmr_mod_ins
      86  handle_system_time_rollover
     124  invoke_expired_timer_cbs
      12  sw_current_time_get
     158  sw_tmr_add_to_active_list
      24  sw_tmr_create
       2  sw_tmr_deinit
      16  sw_tmr_delay
      26  sw_tmr_get_min_of_all_remaining_time
      12  sw_tmr_get_sys_time_high
      48  sw_tmr_init
      16  sw_tmr_is_active
       6  sw_tmr_period_get
      12  sw_tmr_rand_get
      20  sw_tmr_remaining_time_get
      66  sw_tmr_stop
       2  sw_tmr_time_update_req
     170  update_expired_tmr_list

 
   6 bytes in section .bss
 808 bytes in section .text
 
 808 bytes of CODE memory
   6 bytes of DATA memory

Errors: none
Warnings: none
